var data = {lines:[
{"lineNum":"    1","line":"const std = @import(\"std.zig\");"},
{"lineNum":"    2","line":"const builtin = @import(\"builtin\");"},
{"lineNum":"    3","line":"const mem = std.mem;"},
{"lineNum":"    4","line":"const os = std.os;"},
{"lineNum":"    5","line":"const assert = std.debug.assert;"},
{"lineNum":"    6","line":"const testing = std.testing;"},
{"lineNum":"    7","line":"const elf = std.elf;"},
{"lineNum":"    8","line":"const windows = std.os.windows;"},
{"lineNum":"    9","line":"const system = std.os.system;"},
{"lineNum":"   10","line":"const maxInt = std.math.maxInt;"},
{"lineNum":"   11","line":""},
{"lineNum":"   12","line":"pub const DynLib = switch (builtin.os.tag) {"},
{"lineNum":"   13","line":"    .linux => if (builtin.link_libc) DlDynlib else ElfDynLib,"},
{"lineNum":"   14","line":"    .windows => WindowsDynLib,"},
{"lineNum":"   15","line":"    .macos, .tvos, .watchos, .ios, .freebsd, .netbsd, .openbsd, .dragonfly, .solaris => DlDynlib,"},
{"lineNum":"   16","line":"    else => void,"},
{"lineNum":"   17","line":"};"},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"// The link_map structure is not completely specified beside the fields"},
{"lineNum":"   20","line":"// reported below, any libc is free to store additional data in the remaining"},
{"lineNum":"   21","line":"// space."},
{"lineNum":"   22","line":"// An iterator is provided in order to traverse the linked list in a idiomatic"},
{"lineNum":"   23","line":"// fashion."},
{"lineNum":"   24","line":"const LinkMap = extern struct {"},
{"lineNum":"   25","line":"    l_addr: usize,"},
{"lineNum":"   26","line":"    l_name: [*:0]const u8,"},
{"lineNum":"   27","line":"    l_ld: ?*elf.Dyn,"},
{"lineNum":"   28","line":"    l_next: ?*LinkMap,"},
{"lineNum":"   29","line":"    l_prev: ?*LinkMap,"},
{"lineNum":"   30","line":""},
{"lineNum":"   31","line":"    pub const Iterator = struct {"},
{"lineNum":"   32","line":"        current: ?*LinkMap,"},
{"lineNum":"   33","line":""},
{"lineNum":"   34","line":"        pub fn end(self: *Iterator) bool {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   35","line":"            return self.current == null;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   36","line":"        }"},
{"lineNum":"   37","line":""},
{"lineNum":"   38","line":"        pub fn next(self: *Iterator) ?*LinkMap {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   39","line":"            if (self.current) |it| {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   40","line":"                self.current = it.l_next;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   41","line":"                return it;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   42","line":"            }"},
{"lineNum":"   43","line":"            return null;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   44","line":"        }"},
{"lineNum":"   45","line":"    };"},
{"lineNum":"   46","line":"};"},
{"lineNum":"   47","line":""},
{"lineNum":"   48","line":"const RDebug = extern struct {"},
{"lineNum":"   49","line":"    r_version: i32,"},
{"lineNum":"   50","line":"    r_map: ?*LinkMap,"},
{"lineNum":"   51","line":"    r_brk: usize,"},
{"lineNum":"   52","line":"    r_ldbase: usize,"},
{"lineNum":"   53","line":"};"},
{"lineNum":"   54","line":""},
{"lineNum":"   55","line":"/// TODO make it possible to reference this same external symbol 2x so we don\'t need this"},
{"lineNum":"   56","line":"/// helper function."},
{"lineNum":"   57","line":"pub fn get_DYNAMIC() ?[*]elf.Dyn {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   58","line":"    return @extern([*]elf.Dyn, .{ .name = \"_DYNAMIC\", .linkage = .Weak });","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   59","line":"}"},
{"lineNum":"   60","line":""},
{"lineNum":"   61","line":"pub fn linkmap_iterator(phdrs: []elf.Phdr) !LinkMap.Iterator {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   62","line":"    _ = phdrs;"},
{"lineNum":"   63","line":"    const _DYNAMIC = get_DYNAMIC() orelse {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   64","line":"        // No PT_DYNAMIC means this is either a statically-linked program or a"},
{"lineNum":"   65","line":"        // badly corrupted dynamically-linked one."},
{"lineNum":"   66","line":"        return LinkMap.Iterator{ .current = null };","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   67","line":"    };"},
{"lineNum":"   68","line":""},
{"lineNum":"   69","line":"    const link_map_ptr = init: {"},
{"lineNum":"   70","line":"        var i: usize = 0;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   71","line":"        while (_DYNAMIC[i].d_tag != elf.DT_NULL) : (i += 1) {","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   72","line":"            switch (_DYNAMIC[i].d_tag) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   73","line":"                elf.DT_DEBUG => {"},
{"lineNum":"   74","line":"                    const ptr = @as(?*RDebug, @ptrFromInt(_DYNAMIC[i].d_val));","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   75","line":"                    if (ptr) |r_debug| {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   76","line":"                        if (r_debug.r_version != 1) return error.InvalidExe;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   77","line":"                        break :init r_debug.r_map;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   78","line":"                    }"},
{"lineNum":"   79","line":"                },"},
{"lineNum":"   80","line":"                elf.DT_PLTGOT => {"},
{"lineNum":"   81","line":"                    const ptr = @as(?[*]usize, @ptrFromInt(_DYNAMIC[i].d_val));","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   82","line":"                    if (ptr) |got_table| {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   83","line":"                        // The address to the link_map structure is stored in"},
{"lineNum":"   84","line":"                        // the second slot"},
{"lineNum":"   85","line":"                        break :init @as(?*LinkMap, @ptrFromInt(got_table[1]));","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   86","line":"                    }"},
{"lineNum":"   87","line":"                },"},
{"lineNum":"   88","line":"                else => {},"},
{"lineNum":"   89","line":"            }"},
{"lineNum":"   90","line":"        }"},
{"lineNum":"   91","line":"        return LinkMap.Iterator{ .current = null };","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   92","line":"    };"},
{"lineNum":"   93","line":""},
{"lineNum":"   94","line":"    return LinkMap.Iterator{ .current = link_map_ptr };","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   95","line":"}"},
{"lineNum":"   96","line":""},
{"lineNum":"   97","line":"pub const ElfDynLib = struct {"},
{"lineNum":"   98","line":"    strings: [*:0]u8,"},
{"lineNum":"   99","line":"    syms: [*]elf.Sym,"},
{"lineNum":"  100","line":"    hashtab: [*]os.Elf_Symndx,"},
{"lineNum":"  101","line":"    versym: ?[*]u16,"},
{"lineNum":"  102","line":"    verdef: ?*elf.Verdef,"},
{"lineNum":"  103","line":"    memory: []align(mem.page_size) u8,"},
{"lineNum":"  104","line":""},
{"lineNum":"  105","line":"    pub const Error = error{"},
{"lineNum":"  106","line":"        FileTooBig,"},
{"lineNum":"  107","line":"        NotElfFile,"},
{"lineNum":"  108","line":"        NotDynamicLibrary,"},
{"lineNum":"  109","line":"        MissingDynamicLinkingInformation,"},
{"lineNum":"  110","line":"        ElfStringSectionNotFound,"},
{"lineNum":"  111","line":"        ElfSymSectionNotFound,"},
{"lineNum":"  112","line":"        ElfHashTableNotFound,"},
{"lineNum":"  113","line":"    };"},
{"lineNum":"  114","line":""},
{"lineNum":"  115","line":"    /// Trusts the file. Malicious file will be able to execute arbitrary code."},
{"lineNum":"  116","line":"    pub fn open(path: []const u8) !ElfDynLib {"},
{"lineNum":"  117","line":"        const fd = try os.open(path, 0, os.O.RDONLY | os.O.CLOEXEC);"},
{"lineNum":"  118","line":"        defer os.close(fd);"},
{"lineNum":"  119","line":""},
{"lineNum":"  120","line":"        const stat = try os.fstat(fd);"},
{"lineNum":"  121","line":"        const size = std.math.cast(usize, stat.size) orelse return error.FileTooBig;"},
{"lineNum":"  122","line":""},
{"lineNum":"  123","line":"        // This one is to read the ELF info. We do more mmapping later"},
{"lineNum":"  124","line":"        // corresponding to the actual LOAD sections."},
{"lineNum":"  125","line":"        const file_bytes = try os.mmap("},
{"lineNum":"  126","line":"            null,"},
{"lineNum":"  127","line":"            mem.alignForward(usize, size, mem.page_size),"},
{"lineNum":"  128","line":"            os.PROT.READ,"},
{"lineNum":"  129","line":"            os.MAP.PRIVATE,"},
{"lineNum":"  130","line":"            fd,"},
{"lineNum":"  131","line":"            0,"},
{"lineNum":"  132","line":"        );"},
{"lineNum":"  133","line":"        defer os.munmap(file_bytes);"},
{"lineNum":"  134","line":""},
{"lineNum":"  135","line":"        const eh = @as(*elf.Ehdr, @ptrCast(file_bytes.ptr));"},
{"lineNum":"  136","line":"        if (!mem.eql(u8, eh.e_ident[0..4], elf.MAGIC)) return error.NotElfFile;"},
{"lineNum":"  137","line":"        if (eh.e_type != elf.ET.DYN) return error.NotDynamicLibrary;"},
{"lineNum":"  138","line":""},
{"lineNum":"  139","line":"        const elf_addr = @intFromPtr(file_bytes.ptr);"},
{"lineNum":"  140","line":""},
{"lineNum":"  141","line":"        // Iterate over the program header entries to find out the"},
{"lineNum":"  142","line":"        // dynamic vector as well as the total size of the virtual memory."},
{"lineNum":"  143","line":"        var maybe_dynv: ?[*]usize = null;"},
{"lineNum":"  144","line":"        var virt_addr_end: usize = 0;"},
{"lineNum":"  145","line":"        {"},
{"lineNum":"  146","line":"            var i: usize = 0;"},
{"lineNum":"  147","line":"            var ph_addr: usize = elf_addr + eh.e_phoff;"},
{"lineNum":"  148","line":"            while (i < eh.e_phnum) : ({"},
{"lineNum":"  149","line":"                i += 1;"},
{"lineNum":"  150","line":"                ph_addr += eh.e_phentsize;"},
{"lineNum":"  151","line":"            }) {"},
{"lineNum":"  152","line":"                const ph = @as(*elf.Phdr, @ptrFromInt(ph_addr));"},
{"lineNum":"  153","line":"                switch (ph.p_type) {"},
{"lineNum":"  154","line":"                    elf.PT_LOAD => virt_addr_end = @max(virt_addr_end, ph.p_vaddr + ph.p_memsz),"},
{"lineNum":"  155","line":"                    elf.PT_DYNAMIC => maybe_dynv = @as([*]usize, @ptrFromInt(elf_addr + ph.p_offset)),"},
{"lineNum":"  156","line":"                    else => {},"},
{"lineNum":"  157","line":"                }"},
{"lineNum":"  158","line":"            }"},
{"lineNum":"  159","line":"        }"},
{"lineNum":"  160","line":"        const dynv = maybe_dynv orelse return error.MissingDynamicLinkingInformation;"},
{"lineNum":"  161","line":""},
{"lineNum":"  162","line":"        // Reserve the entire range (with no permissions) so that we can do MAP.FIXED below."},
{"lineNum":"  163","line":"        const all_loaded_mem = try os.mmap("},
{"lineNum":"  164","line":"            null,"},
{"lineNum":"  165","line":"            virt_addr_end,"},
{"lineNum":"  166","line":"            os.PROT.NONE,"},
{"lineNum":"  167","line":"            os.MAP.PRIVATE | os.MAP.ANONYMOUS,"},
{"lineNum":"  168","line":"            -1,"},
{"lineNum":"  169","line":"            0,"},
{"lineNum":"  170","line":"        );"},
{"lineNum":"  171","line":"        errdefer os.munmap(all_loaded_mem);"},
{"lineNum":"  172","line":""},
{"lineNum":"  173","line":"        const base = @intFromPtr(all_loaded_mem.ptr);"},
{"lineNum":"  174","line":""},
{"lineNum":"  175","line":"        // Now iterate again and actually load all the program sections."},
{"lineNum":"  176","line":"        {"},
{"lineNum":"  177","line":"            var i: usize = 0;"},
{"lineNum":"  178","line":"            var ph_addr: usize = elf_addr + eh.e_phoff;"},
{"lineNum":"  179","line":"            while (i < eh.e_phnum) : ({"},
{"lineNum":"  180","line":"                i += 1;"},
{"lineNum":"  181","line":"                ph_addr += eh.e_phentsize;"},
{"lineNum":"  182","line":"            }) {"},
{"lineNum":"  183","line":"                const ph = @as(*elf.Phdr, @ptrFromInt(ph_addr));"},
{"lineNum":"  184","line":"                switch (ph.p_type) {"},
{"lineNum":"  185","line":"                    elf.PT_LOAD => {"},
{"lineNum":"  186","line":"                        // The VirtAddr may not be page-aligned; in such case there will be"},
{"lineNum":"  187","line":"                        // extra nonsense mapped before/after the VirtAddr,MemSiz"},
{"lineNum":"  188","line":"                        const aligned_addr = (base + ph.p_vaddr) & ~(@as(usize, mem.page_size) - 1);"},
{"lineNum":"  189","line":"                        const extra_bytes = (base + ph.p_vaddr) - aligned_addr;"},
{"lineNum":"  190","line":"                        const extended_memsz = mem.alignForward(usize, ph.p_memsz + extra_bytes, mem.page_size);"},
{"lineNum":"  191","line":"                        const ptr = @as([*]align(mem.page_size) u8, @ptrFromInt(aligned_addr));"},
{"lineNum":"  192","line":"                        const prot = elfToMmapProt(ph.p_flags);"},
{"lineNum":"  193","line":"                        if ((ph.p_flags & elf.PF_W) == 0) {"},
{"lineNum":"  194","line":"                            // If it does not need write access, it can be mapped from the fd."},
{"lineNum":"  195","line":"                            _ = try os.mmap("},
{"lineNum":"  196","line":"                                ptr,"},
{"lineNum":"  197","line":"                                extended_memsz,"},
{"lineNum":"  198","line":"                                prot,"},
{"lineNum":"  199","line":"                                os.MAP.PRIVATE | os.MAP.FIXED,"},
{"lineNum":"  200","line":"                                fd,"},
{"lineNum":"  201","line":"                                ph.p_offset - extra_bytes,"},
{"lineNum":"  202","line":"                            );"},
{"lineNum":"  203","line":"                        } else {"},
{"lineNum":"  204","line":"                            const sect_mem = try os.mmap("},
{"lineNum":"  205","line":"                                ptr,"},
{"lineNum":"  206","line":"                                extended_memsz,"},
{"lineNum":"  207","line":"                                prot,"},
{"lineNum":"  208","line":"                                os.MAP.PRIVATE | os.MAP.FIXED | os.MAP.ANONYMOUS,"},
{"lineNum":"  209","line":"                                -1,"},
{"lineNum":"  210","line":"                                0,"},
{"lineNum":"  211","line":"                            );"},
{"lineNum":"  212","line":"                            @memcpy(sect_mem[0..ph.p_filesz], file_bytes[0..ph.p_filesz]);"},
{"lineNum":"  213","line":"                        }"},
{"lineNum":"  214","line":"                    },"},
{"lineNum":"  215","line":"                    else => {},"},
{"lineNum":"  216","line":"                }"},
{"lineNum":"  217","line":"            }"},
{"lineNum":"  218","line":"        }"},
{"lineNum":"  219","line":""},
{"lineNum":"  220","line":"        var maybe_strings: ?[*:0]u8 = null;"},
{"lineNum":"  221","line":"        var maybe_syms: ?[*]elf.Sym = null;"},
{"lineNum":"  222","line":"        var maybe_hashtab: ?[*]os.Elf_Symndx = null;"},
{"lineNum":"  223","line":"        var maybe_versym: ?[*]u16 = null;"},
{"lineNum":"  224","line":"        var maybe_verdef: ?*elf.Verdef = null;"},
{"lineNum":"  225","line":""},
{"lineNum":"  226","line":"        {"},
{"lineNum":"  227","line":"            var i: usize = 0;"},
{"lineNum":"  228","line":"            while (dynv[i] != 0) : (i += 2) {"},
{"lineNum":"  229","line":"                const p = base + dynv[i + 1];"},
{"lineNum":"  230","line":"                switch (dynv[i]) {"},
{"lineNum":"  231","line":"                    elf.DT_STRTAB => maybe_strings = @as([*:0]u8, @ptrFromInt(p)),"},
{"lineNum":"  232","line":"                    elf.DT_SYMTAB => maybe_syms = @as([*]elf.Sym, @ptrFromInt(p)),"},
{"lineNum":"  233","line":"                    elf.DT_HASH => maybe_hashtab = @as([*]os.Elf_Symndx, @ptrFromInt(p)),"},
{"lineNum":"  234","line":"                    elf.DT_VERSYM => maybe_versym = @as([*]u16, @ptrFromInt(p)),"},
{"lineNum":"  235","line":"                    elf.DT_VERDEF => maybe_verdef = @as(*elf.Verdef, @ptrFromInt(p)),"},
{"lineNum":"  236","line":"                    else => {},"},
{"lineNum":"  237","line":"                }"},
{"lineNum":"  238","line":"            }"},
{"lineNum":"  239","line":"        }"},
{"lineNum":"  240","line":""},
{"lineNum":"  241","line":"        return ElfDynLib{"},
{"lineNum":"  242","line":"            .memory = all_loaded_mem,"},
{"lineNum":"  243","line":"            .strings = maybe_strings orelse return error.ElfStringSectionNotFound,"},
{"lineNum":"  244","line":"            .syms = maybe_syms orelse return error.ElfSymSectionNotFound,"},
{"lineNum":"  245","line":"            .hashtab = maybe_hashtab orelse return error.ElfHashTableNotFound,"},
{"lineNum":"  246","line":"            .versym = maybe_versym,"},
{"lineNum":"  247","line":"            .verdef = maybe_verdef,"},
{"lineNum":"  248","line":"        };"},
{"lineNum":"  249","line":"    }"},
{"lineNum":"  250","line":""},
{"lineNum":"  251","line":"    /// Trusts the file. Malicious file will be able to execute arbitrary code."},
{"lineNum":"  252","line":"    pub fn openZ(path_c: [*:0]const u8) !ElfDynLib {"},
{"lineNum":"  253","line":"        return open(mem.sliceTo(path_c, 0));"},
{"lineNum":"  254","line":"    }"},
{"lineNum":"  255","line":""},
{"lineNum":"  256","line":"    /// Trusts the file"},
{"lineNum":"  257","line":"    pub fn close(self: *ElfDynLib) void {"},
{"lineNum":"  258","line":"        os.munmap(self.memory);"},
{"lineNum":"  259","line":"        self.* = undefined;"},
{"lineNum":"  260","line":"    }"},
{"lineNum":"  261","line":""},
{"lineNum":"  262","line":"    pub fn lookup(self: *ElfDynLib, comptime T: type, name: [:0]const u8) ?T {"},
{"lineNum":"  263","line":"        if (self.lookupAddress(\"\", name)) |symbol| {"},
{"lineNum":"  264","line":"            return @as(T, @ptrFromInt(symbol));"},
{"lineNum":"  265","line":"        } else {"},
{"lineNum":"  266","line":"            return null;"},
{"lineNum":"  267","line":"        }"},
{"lineNum":"  268","line":"    }"},
{"lineNum":"  269","line":""},
{"lineNum":"  270","line":"    /// Returns the address of the symbol"},
{"lineNum":"  271","line":"    pub fn lookupAddress(self: *const ElfDynLib, vername: []const u8, name: []const u8) ?usize {"},
{"lineNum":"  272","line":"        const maybe_versym = if (self.verdef == null) null else self.versym;"},
{"lineNum":"  273","line":""},
{"lineNum":"  274","line":"        const OK_TYPES = (1 << elf.STT_NOTYPE | 1 << elf.STT_OBJECT | 1 << elf.STT_FUNC | 1 << elf.STT_COMMON);"},
{"lineNum":"  275","line":"        const OK_BINDS = (1 << elf.STB_GLOBAL | 1 << elf.STB_WEAK | 1 << elf.STB_GNU_UNIQUE);"},
{"lineNum":"  276","line":""},
{"lineNum":"  277","line":"        var i: usize = 0;"},
{"lineNum":"  278","line":"        while (i < self.hashtab[1]) : (i += 1) {"},
{"lineNum":"  279","line":"            if (0 == (@as(u32, 1) << @as(u5, @intCast(self.syms[i].st_info & 0xf)) & OK_TYPES)) continue;"},
{"lineNum":"  280","line":"            if (0 == (@as(u32, 1) << @as(u5, @intCast(self.syms[i].st_info >> 4)) & OK_BINDS)) continue;"},
{"lineNum":"  281","line":"            if (0 == self.syms[i].st_shndx) continue;"},
{"lineNum":"  282","line":"            if (!mem.eql(u8, name, mem.sliceTo(self.strings + self.syms[i].st_name, 0))) continue;"},
{"lineNum":"  283","line":"            if (maybe_versym) |versym| {"},
{"lineNum":"  284","line":"                if (!checkver(self.verdef.?, versym[i], vername, self.strings))"},
{"lineNum":"  285","line":"                    continue;"},
{"lineNum":"  286","line":"            }"},
{"lineNum":"  287","line":"            return @intFromPtr(self.memory.ptr) + self.syms[i].st_value;"},
{"lineNum":"  288","line":"        }"},
{"lineNum":"  289","line":""},
{"lineNum":"  290","line":"        return null;"},
{"lineNum":"  291","line":"    }"},
{"lineNum":"  292","line":""},
{"lineNum":"  293","line":"    fn elfToMmapProt(elf_prot: u64) u32 {"},
{"lineNum":"  294","line":"        var result: u32 = os.PROT.NONE;"},
{"lineNum":"  295","line":"        if ((elf_prot & elf.PF_R) != 0) result |= os.PROT.READ;"},
{"lineNum":"  296","line":"        if ((elf_prot & elf.PF_W) != 0) result |= os.PROT.WRITE;"},
{"lineNum":"  297","line":"        if ((elf_prot & elf.PF_X) != 0) result |= os.PROT.EXEC;"},
{"lineNum":"  298","line":"        return result;"},
{"lineNum":"  299","line":"    }"},
{"lineNum":"  300","line":"};"},
{"lineNum":"  301","line":""},
{"lineNum":"  302","line":"fn checkver(def_arg: *elf.Verdef, vsym_arg: i32, vername: []const u8, strings: [*:0]u8) bool {"},
{"lineNum":"  303","line":"    var def = def_arg;"},
{"lineNum":"  304","line":"    const vsym = @as(u32, @bitCast(vsym_arg)) & 0x7fff;"},
{"lineNum":"  305","line":"    while (true) {"},
{"lineNum":"  306","line":"        if (0 == (def.vd_flags & elf.VER_FLG_BASE) and (def.vd_ndx & 0x7fff) == vsym)"},
{"lineNum":"  307","line":"            break;"},
{"lineNum":"  308","line":"        if (def.vd_next == 0)"},
{"lineNum":"  309","line":"            return false;"},
{"lineNum":"  310","line":"        def = @as(*elf.Verdef, @ptrFromInt(@intFromPtr(def) + def.vd_next));"},
{"lineNum":"  311","line":"    }"},
{"lineNum":"  312","line":"    const aux = @as(*elf.Verdaux, @ptrFromInt(@intFromPtr(def) + def.vd_aux));"},
{"lineNum":"  313","line":"    return mem.eql(u8, vername, mem.sliceTo(strings + aux.vda_name, 0));"},
{"lineNum":"  314","line":"}"},
{"lineNum":"  315","line":""},
{"lineNum":"  316","line":"pub const WindowsDynLib = struct {"},
{"lineNum":"  317","line":"    pub const Error = error{FileNotFound};"},
{"lineNum":"  318","line":""},
{"lineNum":"  319","line":"    dll: windows.HMODULE,"},
{"lineNum":"  320","line":""},
{"lineNum":"  321","line":"    pub fn open(path: []const u8) !WindowsDynLib {"},
{"lineNum":"  322","line":"        const path_w = try windows.sliceToPrefixedFileW(path);"},
{"lineNum":"  323","line":"        return openW(path_w.span().ptr);"},
{"lineNum":"  324","line":"    }"},
{"lineNum":"  325","line":""},
{"lineNum":"  326","line":"    pub fn openZ(path_c: [*:0]const u8) !WindowsDynLib {"},
{"lineNum":"  327","line":"        const path_w = try windows.cStrToPrefixedFileW(path_c);"},
{"lineNum":"  328","line":"        return openW(path_w.span().ptr);"},
{"lineNum":"  329","line":"    }"},
{"lineNum":"  330","line":""},
{"lineNum":"  331","line":"    pub fn openW(path_w: [*:0]const u16) !WindowsDynLib {"},
{"lineNum":"  332","line":"        var offset: usize = 0;"},
{"lineNum":"  333","line":"        if (path_w[0] == \'\\\\\' and path_w[1] == \'?\' and path_w[2] == \'?\' and path_w[3] == \'\\\\\') {"},
{"lineNum":"  334","line":"            // + 4 to skip over the \\??\\"},
{"lineNum":"  335","line":"            offset = 4;"},
{"lineNum":"  336","line":"        }"},
{"lineNum":"  337","line":""},
{"lineNum":"  338","line":"        return WindowsDynLib{"},
{"lineNum":"  339","line":"            .dll = try windows.LoadLibraryW(path_w + offset),"},
{"lineNum":"  340","line":"        };"},
{"lineNum":"  341","line":"    }"},
{"lineNum":"  342","line":""},
{"lineNum":"  343","line":"    pub fn close(self: *WindowsDynLib) void {"},
{"lineNum":"  344","line":"        windows.FreeLibrary(self.dll);"},
{"lineNum":"  345","line":"        self.* = undefined;"},
{"lineNum":"  346","line":"    }"},
{"lineNum":"  347","line":""},
{"lineNum":"  348","line":"    pub fn lookup(self: *WindowsDynLib, comptime T: type, name: [:0]const u8) ?T {"},
{"lineNum":"  349","line":"        if (windows.kernel32.GetProcAddress(self.dll, name.ptr)) |addr| {"},
{"lineNum":"  350","line":"            return @as(T, @ptrCast(@alignCast(addr)));"},
{"lineNum":"  351","line":"        } else {"},
{"lineNum":"  352","line":"            return null;"},
{"lineNum":"  353","line":"        }"},
{"lineNum":"  354","line":"    }"},
{"lineNum":"  355","line":"};"},
{"lineNum":"  356","line":""},
{"lineNum":"  357","line":"pub const DlDynlib = struct {"},
{"lineNum":"  358","line":"    pub const Error = error{FileNotFound};"},
{"lineNum":"  359","line":""},
{"lineNum":"  360","line":"    handle: *anyopaque,"},
{"lineNum":"  361","line":""},
{"lineNum":"  362","line":"    pub fn open(path: []const u8) !DlDynlib {"},
{"lineNum":"  363","line":"        const path_c = try os.toPosixPath(path);"},
{"lineNum":"  364","line":"        return openZ(&path_c);"},
{"lineNum":"  365","line":"    }"},
{"lineNum":"  366","line":""},
{"lineNum":"  367","line":"    pub fn openZ(path_c: [*:0]const u8) !DlDynlib {"},
{"lineNum":"  368","line":"        return DlDynlib{"},
{"lineNum":"  369","line":"            .handle = system.dlopen(path_c, system.RTLD.LAZY) orelse {"},
{"lineNum":"  370","line":"                return error.FileNotFound;"},
{"lineNum":"  371","line":"            },"},
{"lineNum":"  372","line":"        };"},
{"lineNum":"  373","line":"    }"},
{"lineNum":"  374","line":""},
{"lineNum":"  375","line":"    pub fn close(self: *DlDynlib) void {"},
{"lineNum":"  376","line":"        _ = system.dlclose(self.handle);"},
{"lineNum":"  377","line":"        self.* = undefined;"},
{"lineNum":"  378","line":"    }"},
{"lineNum":"  379","line":""},
{"lineNum":"  380","line":"    pub fn lookup(self: *DlDynlib, comptime T: type, name: [:0]const u8) ?T {"},
{"lineNum":"  381","line":"        // dlsym (and other dl-functions) secretly take shadow parameter - return address on stack"},
{"lineNum":"  382","line":"        // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=66826"},
{"lineNum":"  383","line":"        if (@call(.never_tail, system.dlsym, .{ self.handle, name.ptr })) |symbol| {"},
{"lineNum":"  384","line":"            return @as(T, @ptrCast(@alignCast(symbol)));"},
{"lineNum":"  385","line":"        } else {"},
{"lineNum":"  386","line":"            return null;"},
{"lineNum":"  387","line":"        }"},
{"lineNum":"  388","line":"    }"},
{"lineNum":"  389","line":"};"},
{"lineNum":"  390","line":""},
{"lineNum":"  391","line":"test \"dynamic_library\" {"},
{"lineNum":"  392","line":"    const libname = switch (builtin.os.tag) {"},
{"lineNum":"  393","line":"        .linux, .freebsd, .openbsd => \"invalid_so.so\","},
{"lineNum":"  394","line":"        .windows => \"invalid_dll.dll\","},
{"lineNum":"  395","line":"        .macos, .tvos, .watchos, .ios => \"invalid_dylib.dylib\","},
{"lineNum":"  396","line":"        else => return error.SkipZigTest,"},
{"lineNum":"  397","line":"    };"},
{"lineNum":"  398","line":""},
{"lineNum":"  399","line":"    _ = DynLib.open(libname) catch |err| {"},
{"lineNum":"  400","line":"        try testing.expect(err == error.FileNotFound);"},
{"lineNum":"  401","line":"        return;"},
{"lineNum":"  402","line":"    };"},
{"lineNum":"  403","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test", "date" : "2024-04-26 16:14:49", "instrumented" : 24, "covered" : 0,};
var merged_data = [];
