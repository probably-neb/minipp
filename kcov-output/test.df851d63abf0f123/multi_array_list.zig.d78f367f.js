var data = {lines:[
{"lineNum":"    1","line":"const std = @import(\"std\");"},
{"lineNum":"    2","line":"const builtin = @import(\"builtin\");"},
{"lineNum":"    3","line":"const assert = std.debug.assert;"},
{"lineNum":"    4","line":"const meta = std.meta;"},
{"lineNum":"    5","line":"const mem = std.mem;"},
{"lineNum":"    6","line":"const Allocator = mem.Allocator;"},
{"lineNum":"    7","line":"const testing = std.testing;"},
{"lineNum":"    8","line":""},
{"lineNum":"    9","line":"/// A MultiArrayList stores a list of a struct or tagged union type."},
{"lineNum":"   10","line":"/// Instead of storing a single list of items, MultiArrayList"},
{"lineNum":"   11","line":"/// stores separate lists for each field of the struct or"},
{"lineNum":"   12","line":"/// lists of tags and bare unions."},
{"lineNum":"   13","line":"/// This allows for memory savings if the struct or union has padding,"},
{"lineNum":"   14","line":"/// and also improves cache usage if only some fields or just tags"},
{"lineNum":"   15","line":"/// are needed for a computation.  The primary API for accessing fields is"},
{"lineNum":"   16","line":"/// the `slice()` function, which computes the start pointers"},
{"lineNum":"   17","line":"/// for the array of each field.  From the slice you can call"},
{"lineNum":"   18","line":"/// `.items(.<field_name>)` to obtain a slice of field values."},
{"lineNum":"   19","line":"/// For unions you can call `.items(.tags)` or `.items(.data)`."},
{"lineNum":"   20","line":"pub fn MultiArrayList(comptime T: type) type {"},
{"lineNum":"   21","line":"    return struct {"},
{"lineNum":"   22","line":"        bytes: [*]align(@alignOf(T)) u8 = undefined,"},
{"lineNum":"   23","line":"        len: usize = 0,"},
{"lineNum":"   24","line":"        capacity: usize = 0,"},
{"lineNum":"   25","line":""},
{"lineNum":"   26","line":"        const Elem = switch (@typeInfo(T)) {"},
{"lineNum":"   27","line":"            .Struct => T,"},
{"lineNum":"   28","line":"            .Union => |u| struct {"},
{"lineNum":"   29","line":"                pub const Bare ="},
{"lineNum":"   30","line":"                    @Type(.{ .Union = .{"},
{"lineNum":"   31","line":"                    .layout = u.layout,"},
{"lineNum":"   32","line":"                    .tag_type = null,"},
{"lineNum":"   33","line":"                    .fields = u.fields,"},
{"lineNum":"   34","line":"                    .decls = &.{},"},
{"lineNum":"   35","line":"                } });"},
{"lineNum":"   36","line":"                pub const Tag ="},
{"lineNum":"   37","line":"                    u.tag_type orelse @compileError(\"MultiArrayList does not support untagged unions\");"},
{"lineNum":"   38","line":"                tags: Tag,"},
{"lineNum":"   39","line":"                data: Bare,"},
{"lineNum":"   40","line":""},
{"lineNum":"   41","line":"                pub fn fromT(outer: T) @This() {"},
{"lineNum":"   42","line":"                    const tag = meta.activeTag(outer);"},
{"lineNum":"   43","line":"                    return .{"},
{"lineNum":"   44","line":"                        .tags = tag,"},
{"lineNum":"   45","line":"                        .data = switch (tag) {"},
{"lineNum":"   46","line":"                            inline else => |t| @unionInit(Bare, @tagName(t), @field(outer, @tagName(t))),"},
{"lineNum":"   47","line":"                        },"},
{"lineNum":"   48","line":"                    };"},
{"lineNum":"   49","line":"                }"},
{"lineNum":"   50","line":"                pub fn toT(tag: Tag, bare: Bare) T {"},
{"lineNum":"   51","line":"                    return switch (tag) {"},
{"lineNum":"   52","line":"                        inline else => |t| @unionInit(T, @tagName(t), @field(bare, @tagName(t))),"},
{"lineNum":"   53","line":"                    };"},
{"lineNum":"   54","line":"                }"},
{"lineNum":"   55","line":"            },"},
{"lineNum":"   56","line":"            else => @compileError(\"MultiArrayList only supports structs and tagged unions\"),"},
{"lineNum":"   57","line":"        };"},
{"lineNum":"   58","line":""},
{"lineNum":"   59","line":"        pub const Field = meta.FieldEnum(Elem);"},
{"lineNum":"   60","line":""},
{"lineNum":"   61","line":"        /// A MultiArrayList.Slice contains cached start pointers for each field in the list."},
{"lineNum":"   62","line":"        /// These pointers are not normally stored to reduce the size of the list in memory."},
{"lineNum":"   63","line":"        /// If you are accessing multiple fields, call slice() first to compute the pointers,"},
{"lineNum":"   64","line":"        /// and then get the field arrays from the slice."},
{"lineNum":"   65","line":"        pub const Slice = struct {"},
{"lineNum":"   66","line":"            /// This array is indexed by the field index which can be obtained"},
{"lineNum":"   67","line":"            /// by using @intFromEnum() on the Field enum"},
{"lineNum":"   68","line":"            ptrs: [fields.len][*]u8,"},
{"lineNum":"   69","line":"            len: usize,"},
{"lineNum":"   70","line":"            capacity: usize,"},
{"lineNum":"   71","line":""},
{"lineNum":"   72","line":"            pub fn items(self: Slice, comptime field: Field) []FieldType(field) {","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   73","line":"                const F = FieldType(field);"},
{"lineNum":"   74","line":"                if (self.capacity == 0) {","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   75","line":"                    return &[_]F{};","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   76","line":"                }"},
{"lineNum":"   77","line":"                const byte_ptr = self.ptrs[@intFromEnum(field)];","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   78","line":"                const casted_ptr: [*]F = if (@sizeOf(F) == 0)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   79","line":"                    undefined"},
{"lineNum":"   80","line":"                else"},
{"lineNum":"   81","line":"                    @ptrCast(@alignCast(byte_ptr));","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"   82","line":"                return casted_ptr[0..self.len];","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"   83","line":"            }"},
{"lineNum":"   84","line":""},
{"lineNum":"   85","line":"            pub fn set(self: *Slice, index: usize, elem: T) void {"},
{"lineNum":"   86","line":"                const e = switch (@typeInfo(T)) {"},
{"lineNum":"   87","line":"                    .Struct => elem,"},
{"lineNum":"   88","line":"                    .Union => Elem.fromT(elem),"},
{"lineNum":"   89","line":"                    else => unreachable,"},
{"lineNum":"   90","line":"                };"},
{"lineNum":"   91","line":"                inline for (fields, 0..) |field_info, i| {"},
{"lineNum":"   92","line":"                    self.items(@as(Field, @enumFromInt(i)))[index] = @field(e, field_info.name);"},
{"lineNum":"   93","line":"                }"},
{"lineNum":"   94","line":"            }"},
{"lineNum":"   95","line":""},
{"lineNum":"   96","line":"            pub fn get(self: Slice, index: usize) T {"},
{"lineNum":"   97","line":"                var result: Elem = undefined;"},
{"lineNum":"   98","line":"                inline for (fields, 0..) |field_info, i| {"},
{"lineNum":"   99","line":"                    @field(result, field_info.name) = self.items(@as(Field, @enumFromInt(i)))[index];"},
{"lineNum":"  100","line":"                }"},
{"lineNum":"  101","line":"                return switch (@typeInfo(T)) {"},
{"lineNum":"  102","line":"                    .Struct => result,"},
{"lineNum":"  103","line":"                    .Union => Elem.toT(result.tags, result.data),"},
{"lineNum":"  104","line":"                    else => unreachable,"},
{"lineNum":"  105","line":"                };"},
{"lineNum":"  106","line":"            }"},
{"lineNum":"  107","line":""},
{"lineNum":"  108","line":"            pub fn toMultiArrayList(self: Slice) Self {"},
{"lineNum":"  109","line":"                if (self.ptrs.len == 0) {"},
{"lineNum":"  110","line":"                    return .{};"},
{"lineNum":"  111","line":"                }"},
{"lineNum":"  112","line":"                const unaligned_ptr = self.ptrs[sizes.fields[0]];"},
{"lineNum":"  113","line":"                const aligned_ptr: [*]align(@alignOf(Elem)) u8 = @alignCast(unaligned_ptr);"},
{"lineNum":"  114","line":"                return .{"},
{"lineNum":"  115","line":"                    .bytes = aligned_ptr,"},
{"lineNum":"  116","line":"                    .len = self.len,"},
{"lineNum":"  117","line":"                    .capacity = self.capacity,"},
{"lineNum":"  118","line":"                };"},
{"lineNum":"  119","line":"            }"},
{"lineNum":"  120","line":""},
{"lineNum":"  121","line":"            pub fn deinit(self: *Slice, gpa: Allocator) void {"},
{"lineNum":"  122","line":"                var other = self.toMultiArrayList();"},
{"lineNum":"  123","line":"                other.deinit(gpa);"},
{"lineNum":"  124","line":"                self.* = undefined;"},
{"lineNum":"  125","line":"            }"},
{"lineNum":"  126","line":""},
{"lineNum":"  127","line":"            /// This function is used in the debugger pretty formatters in tools/ to fetch the"},
{"lineNum":"  128","line":"            /// child field order and entry type to facilitate fancy debug printing for this type."},
{"lineNum":"  129","line":"            fn dbHelper(self: *Slice, child: *Elem, field: *Field, entry: *Entry) void {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  130","line":"                _ = self;"},
{"lineNum":"  131","line":"                _ = child;"},
{"lineNum":"  132","line":"                _ = field;"},
{"lineNum":"  133","line":"                _ = entry;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  134","line":"            }"},
{"lineNum":"  135","line":"        };"},
{"lineNum":"  136","line":""},
{"lineNum":"  137","line":"        const Self = @This();"},
{"lineNum":"  138","line":""},
{"lineNum":"  139","line":"        const fields = meta.fields(Elem);"},
{"lineNum":"  140","line":"        /// `sizes.bytes` is an array of @sizeOf each T field. Sorted by alignment, descending."},
{"lineNum":"  141","line":"        /// `sizes.fields` is an array mapping from `sizes.bytes` array index to field index."},
{"lineNum":"  142","line":"        const sizes = blk: {"},
{"lineNum":"  143","line":"            const Data = struct {"},
{"lineNum":"  144","line":"                size: usize,"},
{"lineNum":"  145","line":"                size_index: usize,"},
{"lineNum":"  146","line":"                alignment: usize,"},
{"lineNum":"  147","line":"            };"},
{"lineNum":"  148","line":"            var data: [fields.len]Data = undefined;"},
{"lineNum":"  149","line":"            for (fields, 0..) |field_info, i| {"},
{"lineNum":"  150","line":"                data[i] = .{"},
{"lineNum":"  151","line":"                    .size = @sizeOf(field_info.type),"},
{"lineNum":"  152","line":"                    .size_index = i,"},
{"lineNum":"  153","line":"                    .alignment = if (@sizeOf(field_info.type) == 0) 1 else field_info.alignment,"},
{"lineNum":"  154","line":"                };"},
{"lineNum":"  155","line":"            }"},
{"lineNum":"  156","line":"            const Sort = struct {"},
{"lineNum":"  157","line":"                fn lessThan(context: void, lhs: Data, rhs: Data) bool {"},
{"lineNum":"  158","line":"                    _ = context;"},
{"lineNum":"  159","line":"                    return lhs.alignment > rhs.alignment;"},
{"lineNum":"  160","line":"                }"},
{"lineNum":"  161","line":"            };"},
{"lineNum":"  162","line":"            mem.sort(Data, &data, {}, Sort.lessThan);"},
{"lineNum":"  163","line":"            var sizes_bytes: [fields.len]usize = undefined;"},
{"lineNum":"  164","line":"            var field_indexes: [fields.len]usize = undefined;"},
{"lineNum":"  165","line":"            for (data, 0..) |elem, i| {"},
{"lineNum":"  166","line":"                sizes_bytes[i] = elem.size;"},
{"lineNum":"  167","line":"                field_indexes[i] = elem.size_index;"},
{"lineNum":"  168","line":"            }"},
{"lineNum":"  169","line":"            break :blk .{"},
{"lineNum":"  170","line":"                .bytes = sizes_bytes,"},
{"lineNum":"  171","line":"                .fields = field_indexes,"},
{"lineNum":"  172","line":"            };"},
{"lineNum":"  173","line":"        };"},
{"lineNum":"  174","line":""},
{"lineNum":"  175","line":"        /// Release all allocated memory."},
{"lineNum":"  176","line":"        pub fn deinit(self: *Self, gpa: Allocator) void {"},
{"lineNum":"  177","line":"            gpa.free(self.allocatedBytes());"},
{"lineNum":"  178","line":"            self.* = undefined;"},
{"lineNum":"  179","line":"        }"},
{"lineNum":"  180","line":""},
{"lineNum":"  181","line":"        /// The caller owns the returned memory. Empties this MultiArrayList."},
{"lineNum":"  182","line":"        pub fn toOwnedSlice(self: *Self) Slice {"},
{"lineNum":"  183","line":"            const result = self.slice();"},
{"lineNum":"  184","line":"            self.* = .{};"},
{"lineNum":"  185","line":"            return result;"},
{"lineNum":"  186","line":"        }"},
{"lineNum":"  187","line":""},
{"lineNum":"  188","line":"        /// Compute pointers to the start of each field of the array."},
{"lineNum":"  189","line":"        /// If you need to access multiple fields, calling this may"},
{"lineNum":"  190","line":"        /// be more efficient than calling `items()` multiple times."},
{"lineNum":"  191","line":"        pub fn slice(self: Self) Slice {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  192","line":"            var result: Slice = .{","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  193","line":"                .ptrs = undefined,"},
{"lineNum":"  194","line":"                .len = self.len,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  195","line":"                .capacity = self.capacity,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  196","line":"            };"},
{"lineNum":"  197","line":"            var ptr: [*]u8 = self.bytes;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  198","line":"            for (sizes.bytes, sizes.fields) |field_size, i| {","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  199","line":"                result.ptrs[i] = ptr;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  200","line":"                ptr += field_size * self.capacity;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  201","line":"            }"},
{"lineNum":"  202","line":"            return result;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  203","line":"        }"},
{"lineNum":"  204","line":""},
{"lineNum":"  205","line":"        /// Get the slice of values for a specified field."},
{"lineNum":"  206","line":"        /// If you need multiple fields, consider calling slice()"},
{"lineNum":"  207","line":"        /// instead."},
{"lineNum":"  208","line":"        pub fn items(self: Self, comptime field: Field) []FieldType(field) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  209","line":"            return self.slice().items(field);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  210","line":"        }"},
{"lineNum":"  211","line":""},
{"lineNum":"  212","line":"        /// Overwrite one array element with new data."},
{"lineNum":"  213","line":"        pub fn set(self: *Self, index: usize, elem: T) void {"},
{"lineNum":"  214","line":"            var slices = self.slice();"},
{"lineNum":"  215","line":"            slices.set(index, elem);"},
{"lineNum":"  216","line":"        }"},
{"lineNum":"  217","line":""},
{"lineNum":"  218","line":"        /// Obtain all the data for one array element."},
{"lineNum":"  219","line":"        pub fn get(self: Self, index: usize) T {"},
{"lineNum":"  220","line":"            return self.slice().get(index);"},
{"lineNum":"  221","line":"        }"},
{"lineNum":"  222","line":""},
{"lineNum":"  223","line":"        /// Extend the list by 1 element. Allocates more memory as necessary."},
{"lineNum":"  224","line":"        pub fn append(self: *Self, gpa: Allocator, elem: T) !void {"},
{"lineNum":"  225","line":"            try self.ensureUnusedCapacity(gpa, 1);"},
{"lineNum":"  226","line":"            self.appendAssumeCapacity(elem);"},
{"lineNum":"  227","line":"        }"},
{"lineNum":"  228","line":""},
{"lineNum":"  229","line":"        /// Extend the list by 1 element, but asserting `self.capacity`"},
{"lineNum":"  230","line":"        /// is sufficient to hold an additional item."},
{"lineNum":"  231","line":"        pub fn appendAssumeCapacity(self: *Self, elem: T) void {"},
{"lineNum":"  232","line":"            assert(self.len < self.capacity);"},
{"lineNum":"  233","line":"            self.len += 1;"},
{"lineNum":"  234","line":"            self.set(self.len - 1, elem);"},
{"lineNum":"  235","line":"        }"},
{"lineNum":"  236","line":""},
{"lineNum":"  237","line":"        /// Extend the list by 1 element, returning the newly reserved"},
{"lineNum":"  238","line":"        /// index with uninitialized data."},
{"lineNum":"  239","line":"        /// Allocates more memory as necesasry."},
{"lineNum":"  240","line":"        pub fn addOne(self: *Self, allocator: Allocator) Allocator.Error!usize {"},
{"lineNum":"  241","line":"            try self.ensureUnusedCapacity(allocator, 1);"},
{"lineNum":"  242","line":"            return self.addOneAssumeCapacity();"},
{"lineNum":"  243","line":"        }"},
{"lineNum":"  244","line":""},
{"lineNum":"  245","line":"        /// Extend the list by 1 element, asserting `self.capacity`"},
{"lineNum":"  246","line":"        /// is sufficient to hold an additional item.  Returns the"},
{"lineNum":"  247","line":"        /// newly reserved index with uninitialized data."},
{"lineNum":"  248","line":"        pub fn addOneAssumeCapacity(self: *Self) usize {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  249","line":"            assert(self.len < self.capacity);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  250","line":"            const index = self.len;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  251","line":"            self.len += 1;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  252","line":"            return index;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  253","line":"        }"},
{"lineNum":"  254","line":""},
{"lineNum":"  255","line":"        /// Remove and return the last element from the list."},
{"lineNum":"  256","line":"        /// Asserts the list has at least one item."},
{"lineNum":"  257","line":"        /// Invalidates pointers to fields of the removed element."},
{"lineNum":"  258","line":"        pub fn pop(self: *Self) T {"},
{"lineNum":"  259","line":"            const val = self.get(self.len - 1);"},
{"lineNum":"  260","line":"            self.len -= 1;"},
{"lineNum":"  261","line":"            return val;"},
{"lineNum":"  262","line":"        }"},
{"lineNum":"  263","line":""},
{"lineNum":"  264","line":"        /// Remove and return the last element from the list, or"},
{"lineNum":"  265","line":"        /// return `null` if list is empty."},
{"lineNum":"  266","line":"        /// Invalidates pointers to fields of the removed element, if any."},
{"lineNum":"  267","line":"        pub fn popOrNull(self: *Self) ?T {"},
{"lineNum":"  268","line":"            if (self.len == 0) return null;"},
{"lineNum":"  269","line":"            return self.pop();"},
{"lineNum":"  270","line":"        }"},
{"lineNum":"  271","line":""},
{"lineNum":"  272","line":"        /// Inserts an item into an ordered list.  Shifts all elements"},
{"lineNum":"  273","line":"        /// after and including the specified index back by one and"},
{"lineNum":"  274","line":"        /// sets the given index to the specified element.  May reallocate"},
{"lineNum":"  275","line":"        /// and invalidate iterators."},
{"lineNum":"  276","line":"        pub fn insert(self: *Self, gpa: Allocator, index: usize, elem: T) !void {"},
{"lineNum":"  277","line":"            try self.ensureUnusedCapacity(gpa, 1);"},
{"lineNum":"  278","line":"            self.insertAssumeCapacity(index, elem);"},
{"lineNum":"  279","line":"        }"},
{"lineNum":"  280","line":""},
{"lineNum":"  281","line":"        /// Inserts an item into an ordered list which has room for it."},
{"lineNum":"  282","line":"        /// Shifts all elements after and including the specified index"},
{"lineNum":"  283","line":"        /// back by one and sets the given index to the specified element."},
{"lineNum":"  284","line":"        /// Will not reallocate the array, does not invalidate iterators."},
{"lineNum":"  285","line":"        pub fn insertAssumeCapacity(self: *Self, index: usize, elem: T) void {"},
{"lineNum":"  286","line":"            assert(self.len < self.capacity);"},
{"lineNum":"  287","line":"            assert(index <= self.len);"},
{"lineNum":"  288","line":"            self.len += 1;"},
{"lineNum":"  289","line":"            const entry = switch (@typeInfo(T)) {"},
{"lineNum":"  290","line":"                .Struct => elem,"},
{"lineNum":"  291","line":"                .Union => Elem.fromT(elem),"},
{"lineNum":"  292","line":"                else => unreachable,"},
{"lineNum":"  293","line":"            };"},
{"lineNum":"  294","line":"            const slices = self.slice();"},
{"lineNum":"  295","line":"            inline for (fields, 0..) |field_info, field_index| {"},
{"lineNum":"  296","line":"                const field_slice = slices.items(@as(Field, @enumFromInt(field_index)));"},
{"lineNum":"  297","line":"                var i: usize = self.len - 1;"},
{"lineNum":"  298","line":"                while (i > index) : (i -= 1) {"},
{"lineNum":"  299","line":"                    field_slice[i] = field_slice[i - 1];"},
{"lineNum":"  300","line":"                }"},
{"lineNum":"  301","line":"                field_slice[index] = @field(entry, field_info.name);"},
{"lineNum":"  302","line":"            }"},
{"lineNum":"  303","line":"        }"},
{"lineNum":"  304","line":""},
{"lineNum":"  305","line":"        /// Remove the specified item from the list, swapping the last"},
{"lineNum":"  306","line":"        /// item in the list into its position.  Fast, but does not"},
{"lineNum":"  307","line":"        /// retain list ordering."},
{"lineNum":"  308","line":"        pub fn swapRemove(self: *Self, index: usize) void {"},
{"lineNum":"  309","line":"            const slices = self.slice();"},
{"lineNum":"  310","line":"            inline for (fields, 0..) |_, i| {"},
{"lineNum":"  311","line":"                const field_slice = slices.items(@as(Field, @enumFromInt(i)));"},
{"lineNum":"  312","line":"                field_slice[index] = field_slice[self.len - 1];"},
{"lineNum":"  313","line":"                field_slice[self.len - 1] = undefined;"},
{"lineNum":"  314","line":"            }"},
{"lineNum":"  315","line":"            self.len -= 1;"},
{"lineNum":"  316","line":"        }"},
{"lineNum":"  317","line":""},
{"lineNum":"  318","line":"        /// Remove the specified item from the list, shifting items"},
{"lineNum":"  319","line":"        /// after it to preserve order."},
{"lineNum":"  320","line":"        pub fn orderedRemove(self: *Self, index: usize) void {"},
{"lineNum":"  321","line":"            const slices = self.slice();"},
{"lineNum":"  322","line":"            inline for (fields, 0..) |_, field_index| {"},
{"lineNum":"  323","line":"                const field_slice = slices.items(@as(Field, @enumFromInt(field_index)));"},
{"lineNum":"  324","line":"                var i = index;"},
{"lineNum":"  325","line":"                while (i < self.len - 1) : (i += 1) {"},
{"lineNum":"  326","line":"                    field_slice[i] = field_slice[i + 1];"},
{"lineNum":"  327","line":"                }"},
{"lineNum":"  328","line":"                field_slice[i] = undefined;"},
{"lineNum":"  329","line":"            }"},
{"lineNum":"  330","line":"            self.len -= 1;"},
{"lineNum":"  331","line":"        }"},
{"lineNum":"  332","line":""},
{"lineNum":"  333","line":"        /// Adjust the list\'s length to `new_len`."},
{"lineNum":"  334","line":"        /// Does not initialize added items, if any."},
{"lineNum":"  335","line":"        pub fn resize(self: *Self, gpa: Allocator, new_len: usize) !void {"},
{"lineNum":"  336","line":"            try self.ensureTotalCapacity(gpa, new_len);"},
{"lineNum":"  337","line":"            self.len = new_len;"},
{"lineNum":"  338","line":"        }"},
{"lineNum":"  339","line":""},
{"lineNum":"  340","line":"        /// Attempt to reduce allocated capacity to `new_len`."},
{"lineNum":"  341","line":"        /// If `new_len` is greater than zero, this may fail to reduce the capacity,"},
{"lineNum":"  342","line":"        /// but the data remains intact and the length is updated to new_len."},
{"lineNum":"  343","line":"        pub fn shrinkAndFree(self: *Self, gpa: Allocator, new_len: usize) void {"},
{"lineNum":"  344","line":"            if (new_len == 0) {"},
{"lineNum":"  345","line":"                gpa.free(self.allocatedBytes());"},
{"lineNum":"  346","line":"                self.* = .{};"},
{"lineNum":"  347","line":"                return;"},
{"lineNum":"  348","line":"            }"},
{"lineNum":"  349","line":"            assert(new_len <= self.capacity);"},
{"lineNum":"  350","line":"            assert(new_len <= self.len);"},
{"lineNum":"  351","line":""},
{"lineNum":"  352","line":"            const other_bytes = gpa.alignedAlloc("},
{"lineNum":"  353","line":"                u8,"},
{"lineNum":"  354","line":"                @alignOf(Elem),"},
{"lineNum":"  355","line":"                capacityInBytes(new_len),"},
{"lineNum":"  356","line":"            ) catch {"},
{"lineNum":"  357","line":"                const self_slice = self.slice();"},
{"lineNum":"  358","line":"                inline for (fields, 0..) |field_info, i| {"},
{"lineNum":"  359","line":"                    if (@sizeOf(field_info.type) != 0) {"},
{"lineNum":"  360","line":"                        const field = @as(Field, @enumFromInt(i));"},
{"lineNum":"  361","line":"                        const dest_slice = self_slice.items(field)[new_len..];"},
{"lineNum":"  362","line":"                        // We use memset here for more efficient codegen in safety-checked,"},
{"lineNum":"  363","line":"                        // valgrind-enabled builds. Otherwise the valgrind client request"},
{"lineNum":"  364","line":"                        // will be repeated for every element."},
{"lineNum":"  365","line":"                        @memset(dest_slice, undefined);"},
{"lineNum":"  366","line":"                    }"},
{"lineNum":"  367","line":"                }"},
{"lineNum":"  368","line":"                self.len = new_len;"},
{"lineNum":"  369","line":"                return;"},
{"lineNum":"  370","line":"            };"},
{"lineNum":"  371","line":"            var other = Self{"},
{"lineNum":"  372","line":"                .bytes = other_bytes.ptr,"},
{"lineNum":"  373","line":"                .capacity = new_len,"},
{"lineNum":"  374","line":"                .len = new_len,"},
{"lineNum":"  375","line":"            };"},
{"lineNum":"  376","line":"            self.len = new_len;"},
{"lineNum":"  377","line":"            const self_slice = self.slice();"},
{"lineNum":"  378","line":"            const other_slice = other.slice();"},
{"lineNum":"  379","line":"            inline for (fields, 0..) |field_info, i| {"},
{"lineNum":"  380","line":"                if (@sizeOf(field_info.type) != 0) {"},
{"lineNum":"  381","line":"                    const field = @as(Field, @enumFromInt(i));"},
{"lineNum":"  382","line":"                    @memcpy(other_slice.items(field), self_slice.items(field));"},
{"lineNum":"  383","line":"                }"},
{"lineNum":"  384","line":"            }"},
{"lineNum":"  385","line":"            gpa.free(self.allocatedBytes());"},
{"lineNum":"  386","line":"            self.* = other;"},
{"lineNum":"  387","line":"        }"},
{"lineNum":"  388","line":""},
{"lineNum":"  389","line":"        /// Reduce length to `new_len`."},
{"lineNum":"  390","line":"        /// Invalidates pointers to elements `items[new_len..]`."},
{"lineNum":"  391","line":"        /// Keeps capacity the same."},
{"lineNum":"  392","line":"        pub fn shrinkRetainingCapacity(self: *Self, new_len: usize) void {"},
{"lineNum":"  393","line":"            self.len = new_len;"},
{"lineNum":"  394","line":"        }"},
{"lineNum":"  395","line":""},
{"lineNum":"  396","line":"        /// Modify the array so that it can hold at least `new_capacity` items."},
{"lineNum":"  397","line":"        /// Implements super-linear growth to achieve amortized O(1) append operations."},
{"lineNum":"  398","line":"        /// Invalidates pointers if additional memory is needed."},
{"lineNum":"  399","line":"        pub fn ensureTotalCapacity(self: *Self, gpa: Allocator, new_capacity: usize) !void {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  400","line":"            var better_capacity = self.capacity;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  401","line":"            if (better_capacity >= new_capacity) return;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  402","line":""},
{"lineNum":"  403","line":"            while (true) {"},
{"lineNum":"  404","line":"                better_capacity += better_capacity / 2 + 8;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  405","line":"                if (better_capacity >= new_capacity) break;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  406","line":"            }"},
{"lineNum":"  407","line":""},
{"lineNum":"  408","line":"            return self.setCapacity(gpa, better_capacity);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  409","line":"        }"},
{"lineNum":"  410","line":""},
{"lineNum":"  411","line":"        /// Modify the array so that it can hold at least `additional_count` **more** items."},
{"lineNum":"  412","line":"        /// Invalidates pointers if additional memory is needed."},
{"lineNum":"  413","line":"        pub fn ensureUnusedCapacity(self: *Self, gpa: Allocator, additional_count: usize) !void {"},
{"lineNum":"  414","line":"            return self.ensureTotalCapacity(gpa, self.len + additional_count);"},
{"lineNum":"  415","line":"        }"},
{"lineNum":"  416","line":""},
{"lineNum":"  417","line":"        /// Modify the array so that it can hold exactly `new_capacity` items."},
{"lineNum":"  418","line":"        /// Invalidates pointers if additional memory is needed."},
{"lineNum":"  419","line":"        /// `new_capacity` must be greater or equal to `len`."},
{"lineNum":"  420","line":"        pub fn setCapacity(self: *Self, gpa: Allocator, new_capacity: usize) !void {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  421","line":"            assert(new_capacity >= self.len);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  422","line":"            const new_bytes = try gpa.alignedAlloc(","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  423","line":"                u8,"},
{"lineNum":"  424","line":"                @alignOf(Elem),"},
{"lineNum":"  425","line":"                capacityInBytes(new_capacity),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  426","line":"            );"},
{"lineNum":"  427","line":"            if (self.len == 0) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  428","line":"                gpa.free(self.allocatedBytes());","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  429","line":"                self.bytes = new_bytes.ptr;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  430","line":"                self.capacity = new_capacity;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  431","line":"                return;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  432","line":"            }"},
{"lineNum":"  433","line":"            var other = Self{"},
{"lineNum":"  434","line":"                .bytes = new_bytes.ptr,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  435","line":"                .capacity = new_capacity,"},
{"lineNum":"  436","line":"                .len = self.len,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  437","line":"            };"},
{"lineNum":"  438","line":"            const self_slice = self.slice();","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  439","line":"            const other_slice = other.slice();","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  440","line":"            inline for (fields, 0..) |field_info, i| {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  441","line":"                if (@sizeOf(field_info.type) != 0) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  442","line":"                    const field = @as(Field, @enumFromInt(i));","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  443","line":"                    @memcpy(other_slice.items(field), self_slice.items(field));","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  444","line":"                }"},
{"lineNum":"  445","line":"            }"},
{"lineNum":"  446","line":"            gpa.free(self.allocatedBytes());","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  447","line":"            self.* = other;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  448","line":"        }"},
{"lineNum":"  449","line":""},
{"lineNum":"  450","line":"        /// Create a copy of this list with a new backing store,"},
{"lineNum":"  451","line":"        /// using the specified allocator."},
{"lineNum":"  452","line":"        pub fn clone(self: Self, gpa: Allocator) !Self {"},
{"lineNum":"  453","line":"            var result = Self{};"},
{"lineNum":"  454","line":"            errdefer result.deinit(gpa);"},
{"lineNum":"  455","line":"            try result.ensureTotalCapacity(gpa, self.len);"},
{"lineNum":"  456","line":"            result.len = self.len;"},
{"lineNum":"  457","line":"            const self_slice = self.slice();"},
{"lineNum":"  458","line":"            const result_slice = result.slice();"},
{"lineNum":"  459","line":"            inline for (fields, 0..) |field_info, i| {"},
{"lineNum":"  460","line":"                if (@sizeOf(field_info.type) != 0) {"},
{"lineNum":"  461","line":"                    const field = @as(Field, @enumFromInt(i));"},
{"lineNum":"  462","line":"                    @memcpy(result_slice.items(field), self_slice.items(field));"},
{"lineNum":"  463","line":"                }"},
{"lineNum":"  464","line":"            }"},
{"lineNum":"  465","line":"            return result;"},
{"lineNum":"  466","line":"        }"},
{"lineNum":"  467","line":""},
{"lineNum":"  468","line":"        /// `ctx` has the following method:"},
{"lineNum":"  469","line":"        /// `fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool`"},
{"lineNum":"  470","line":"        fn sortInternal(self: Self, a: usize, b: usize, ctx: anytype, comptime mode: enum { stable, unstable }) void {"},
{"lineNum":"  471","line":"            const sort_context: struct {"},
{"lineNum":"  472","line":"                sub_ctx: @TypeOf(ctx),"},
{"lineNum":"  473","line":"                slice: Slice,"},
{"lineNum":"  474","line":""},
{"lineNum":"  475","line":"                pub fn swap(sc: @This(), a_index: usize, b_index: usize) void {"},
{"lineNum":"  476","line":"                    inline for (fields, 0..) |field_info, i| {"},
{"lineNum":"  477","line":"                        if (@sizeOf(field_info.type) != 0) {"},
{"lineNum":"  478","line":"                            const field = @as(Field, @enumFromInt(i));"},
{"lineNum":"  479","line":"                            const ptr = sc.slice.items(field);"},
{"lineNum":"  480","line":"                            mem.swap(field_info.type, &ptr[a_index], &ptr[b_index]);"},
{"lineNum":"  481","line":"                        }"},
{"lineNum":"  482","line":"                    }"},
{"lineNum":"  483","line":"                }"},
{"lineNum":"  484","line":""},
{"lineNum":"  485","line":"                pub fn lessThan(sc: @This(), a_index: usize, b_index: usize) bool {"},
{"lineNum":"  486","line":"                    return sc.sub_ctx.lessThan(a_index, b_index);"},
{"lineNum":"  487","line":"                }"},
{"lineNum":"  488","line":"            } = .{"},
{"lineNum":"  489","line":"                .sub_ctx = ctx,"},
{"lineNum":"  490","line":"                .slice = self.slice(),"},
{"lineNum":"  491","line":"            };"},
{"lineNum":"  492","line":""},
{"lineNum":"  493","line":"            switch (mode) {"},
{"lineNum":"  494","line":"                .stable => mem.sortContext(a, b, sort_context),"},
{"lineNum":"  495","line":"                .unstable => mem.sortUnstableContext(a, b, sort_context),"},
{"lineNum":"  496","line":"            }"},
{"lineNum":"  497","line":"        }"},
{"lineNum":"  498","line":""},
{"lineNum":"  499","line":"        /// This function guarantees a stable sort, i.e the relative order of equal elements is preserved during sorting."},
{"lineNum":"  500","line":"        /// Read more about stable sorting here: https://en.wikipedia.org/wiki/Sorting_algorithm#Stability"},
{"lineNum":"  501","line":"        /// If this guarantee does not matter, `sortUnstable` might be a faster alternative."},
{"lineNum":"  502","line":"        /// `ctx` has the following method:"},
{"lineNum":"  503","line":"        /// `fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool`"},
{"lineNum":"  504","line":"        pub fn sort(self: Self, ctx: anytype) void {"},
{"lineNum":"  505","line":"            self.sortInternal(0, self.len, ctx, .stable);"},
{"lineNum":"  506","line":"        }"},
{"lineNum":"  507","line":""},
{"lineNum":"  508","line":"        /// Sorts only the subsection of items between indices `a` and `b` (excluding `b`)"},
{"lineNum":"  509","line":"        /// This function guarantees a stable sort, i.e the relative order of equal elements is preserved during sorting."},
{"lineNum":"  510","line":"        /// Read more about stable sorting here: https://en.wikipedia.org/wiki/Sorting_algorithm#Stability"},
{"lineNum":"  511","line":"        /// If this guarantee does not matter, `sortSpanUnstable` might be a faster alternative."},
{"lineNum":"  512","line":"        /// `ctx` has the following method:"},
{"lineNum":"  513","line":"        /// `fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool`"},
{"lineNum":"  514","line":"        pub fn sortSpan(self: Self, a: usize, b: usize, ctx: anytype) void {"},
{"lineNum":"  515","line":"            self.sortInternal(a, b, ctx, .stable);"},
{"lineNum":"  516","line":"        }"},
{"lineNum":"  517","line":""},
{"lineNum":"  518","line":"        /// This function does NOT guarantee a stable sort, i.e the relative order of equal elements may change during sorting."},
{"lineNum":"  519","line":"        /// Due to the weaker guarantees of this function, this may be faster than the stable `sort` method."},
{"lineNum":"  520","line":"        /// Read more about stable sorting here: https://en.wikipedia.org/wiki/Sorting_algorithm#Stability"},
{"lineNum":"  521","line":"        /// `ctx` has the following method:"},
{"lineNum":"  522","line":"        /// `fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool`"},
{"lineNum":"  523","line":"        pub fn sortUnstable(self: Self, ctx: anytype) void {"},
{"lineNum":"  524","line":"            self.sortInternal(0, self.len, ctx, .unstable);"},
{"lineNum":"  525","line":"        }"},
{"lineNum":"  526","line":""},
{"lineNum":"  527","line":"        /// Sorts only the subsection of items between indices `a` and `b` (excluding `b`)"},
{"lineNum":"  528","line":"        /// This function does NOT guarantee a stable sort, i.e the relative order of equal elements may change during sorting."},
{"lineNum":"  529","line":"        /// Due to the weaker guarantees of this function, this may be faster than the stable `sortSpan` method."},
{"lineNum":"  530","line":"        /// Read more about stable sorting here: https://en.wikipedia.org/wiki/Sorting_algorithm#Stability"},
{"lineNum":"  531","line":"        /// `ctx` has the following method:"},
{"lineNum":"  532","line":"        /// `fn lessThan(ctx: @TypeOf(ctx), a_index: usize, b_index: usize) bool`"},
{"lineNum":"  533","line":"        pub fn sortSpanUnstable(self: Self, a: usize, b: usize, ctx: anytype) void {"},
{"lineNum":"  534","line":"            self.sortInternal(a, b, ctx, .unstable);"},
{"lineNum":"  535","line":"        }"},
{"lineNum":"  536","line":""},
{"lineNum":"  537","line":"        fn capacityInBytes(capacity: usize) usize {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  538","line":"            comptime var elem_bytes: usize = 0;"},
{"lineNum":"  539","line":"            inline for (sizes.bytes) |size| elem_bytes += size;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  540","line":"            return elem_bytes * capacity;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  541","line":"        }"},
{"lineNum":"  542","line":""},
{"lineNum":"  543","line":"        fn allocatedBytes(self: Self) []align(@alignOf(Elem)) u8 {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  544","line":"            return self.bytes[0..capacityInBytes(self.capacity)];","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  545","line":"        }"},
{"lineNum":"  546","line":""},
{"lineNum":"  547","line":"        fn FieldType(comptime field: Field) type {"},
{"lineNum":"  548","line":"            return meta.fieldInfo(Elem, field).type;"},
{"lineNum":"  549","line":"        }"},
{"lineNum":"  550","line":""},
{"lineNum":"  551","line":"        const Entry = entry: {"},
{"lineNum":"  552","line":"            var entry_fields: [fields.len]std.builtin.Type.StructField = undefined;"},
{"lineNum":"  553","line":"            for (&entry_fields, sizes.fields) |*entry_field, i| entry_field.* = .{"},
{"lineNum":"  554","line":"                .name = fields[i].name ++ \"_ptr\","},
{"lineNum":"  555","line":"                .type = *fields[i].type,"},
{"lineNum":"  556","line":"                .default_value = null,"},
{"lineNum":"  557","line":"                .is_comptime = fields[i].is_comptime,"},
{"lineNum":"  558","line":"                .alignment = fields[i].alignment,"},
{"lineNum":"  559","line":"            };"},
{"lineNum":"  560","line":"            break :entry @Type(.{ .Struct = .{"},
{"lineNum":"  561","line":"                .layout = .Extern,"},
{"lineNum":"  562","line":"                .fields = &entry_fields,"},
{"lineNum":"  563","line":"                .decls = &.{},"},
{"lineNum":"  564","line":"                .is_tuple = false,"},
{"lineNum":"  565","line":"            } });"},
{"lineNum":"  566","line":"        };"},
{"lineNum":"  567","line":"        /// This function is used in the debugger pretty formatters in tools/ to fetch the"},
{"lineNum":"  568","line":"        /// child field order and entry type to facilitate fancy debug printing for this type."},
{"lineNum":"  569","line":"        fn dbHelper(self: *Self, child: *Elem, field: *Field, entry: *Entry) void {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  570","line":"            _ = self;"},
{"lineNum":"  571","line":"            _ = child;"},
{"lineNum":"  572","line":"            _ = field;"},
{"lineNum":"  573","line":"            _ = entry;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  574","line":"        }"},
{"lineNum":"  575","line":""},
{"lineNum":"  576","line":"        comptime {"},
{"lineNum":"  577","line":"            if (builtin.mode == .Debug) {"},
{"lineNum":"  578","line":"                _ = &dbHelper;"},
{"lineNum":"  579","line":"                _ = &Slice.dbHelper;"},
{"lineNum":"  580","line":"            }"},
{"lineNum":"  581","line":"        }"},
{"lineNum":"  582","line":"    };"},
{"lineNum":"  583","line":"}"},
{"lineNum":"  584","line":""},
{"lineNum":"  585","line":"test \"basic usage\" {"},
{"lineNum":"  586","line":"    const ally = testing.allocator;"},
{"lineNum":"  587","line":""},
{"lineNum":"  588","line":"    const Foo = struct {"},
{"lineNum":"  589","line":"        a: u32,"},
{"lineNum":"  590","line":"        b: []const u8,"},
{"lineNum":"  591","line":"        c: u8,"},
{"lineNum":"  592","line":"    };"},
{"lineNum":"  593","line":""},
{"lineNum":"  594","line":"    var list = MultiArrayList(Foo){};"},
{"lineNum":"  595","line":"    defer list.deinit(ally);"},
{"lineNum":"  596","line":""},
{"lineNum":"  597","line":"    try testing.expectEqual(@as(usize, 0), list.items(.a).len);"},
{"lineNum":"  598","line":""},
{"lineNum":"  599","line":"    try list.ensureTotalCapacity(ally, 2);"},
{"lineNum":"  600","line":""},
{"lineNum":"  601","line":"    list.appendAssumeCapacity(.{"},
{"lineNum":"  602","line":"        .a = 1,"},
{"lineNum":"  603","line":"        .b = \"foobar\","},
{"lineNum":"  604","line":"        .c = \'a\',"},
{"lineNum":"  605","line":"    });"},
{"lineNum":"  606","line":""},
{"lineNum":"  607","line":"    list.appendAssumeCapacity(.{"},
{"lineNum":"  608","line":"        .a = 2,"},
{"lineNum":"  609","line":"        .b = \"zigzag\","},
{"lineNum":"  610","line":"        .c = \'b\',"},
{"lineNum":"  611","line":"    });"},
{"lineNum":"  612","line":""},
{"lineNum":"  613","line":"    try testing.expectEqualSlices(u32, list.items(.a), &[_]u32{ 1, 2 });"},
{"lineNum":"  614","line":"    try testing.expectEqualSlices(u8, list.items(.c), &[_]u8{ \'a\', \'b\' });"},
{"lineNum":"  615","line":""},
{"lineNum":"  616","line":"    try testing.expectEqual(@as(usize, 2), list.items(.b).len);"},
{"lineNum":"  617","line":"    try testing.expectEqualStrings(\"foobar\", list.items(.b)[0]);"},
{"lineNum":"  618","line":"    try testing.expectEqualStrings(\"zigzag\", list.items(.b)[1]);"},
{"lineNum":"  619","line":""},
{"lineNum":"  620","line":"    try list.append(ally, .{"},
{"lineNum":"  621","line":"        .a = 3,"},
{"lineNum":"  622","line":"        .b = \"fizzbuzz\","},
{"lineNum":"  623","line":"        .c = \'c\',"},
{"lineNum":"  624","line":"    });"},
{"lineNum":"  625","line":""},
{"lineNum":"  626","line":"    try testing.expectEqualSlices(u32, list.items(.a), &[_]u32{ 1, 2, 3 });"},
{"lineNum":"  627","line":"    try testing.expectEqualSlices(u8, list.items(.c), &[_]u8{ \'a\', \'b\', \'c\' });"},
{"lineNum":"  628","line":""},
{"lineNum":"  629","line":"    try testing.expectEqual(@as(usize, 3), list.items(.b).len);"},
{"lineNum":"  630","line":"    try testing.expectEqualStrings(\"foobar\", list.items(.b)[0]);"},
{"lineNum":"  631","line":"    try testing.expectEqualStrings(\"zigzag\", list.items(.b)[1]);"},
{"lineNum":"  632","line":"    try testing.expectEqualStrings(\"fizzbuzz\", list.items(.b)[2]);"},
{"lineNum":"  633","line":""},
{"lineNum":"  634","line":"    // Add 6 more things to force a capacity increase."},
{"lineNum":"  635","line":"    var i: usize = 0;"},
{"lineNum":"  636","line":"    while (i < 6) : (i += 1) {"},
{"lineNum":"  637","line":"        try list.append(ally, .{"},
{"lineNum":"  638","line":"            .a = @as(u32, @intCast(4 + i)),"},
{"lineNum":"  639","line":"            .b = \"whatever\","},
{"lineNum":"  640","line":"            .c = @as(u8, @intCast(\'d\' + i)),"},
{"lineNum":"  641","line":"        });"},
{"lineNum":"  642","line":"    }"},
{"lineNum":"  643","line":""},
{"lineNum":"  644","line":"    try testing.expectEqualSlices("},
{"lineNum":"  645","line":"        u32,"},
{"lineNum":"  646","line":"        &[_]u32{ 1, 2, 3, 4, 5, 6, 7, 8, 9 },"},
{"lineNum":"  647","line":"        list.items(.a),"},
{"lineNum":"  648","line":"    );"},
{"lineNum":"  649","line":"    try testing.expectEqualSlices("},
{"lineNum":"  650","line":"        u8,"},
{"lineNum":"  651","line":"        &[_]u8{ \'a\', \'b\', \'c\', \'d\', \'e\', \'f\', \'g\', \'h\', \'i\' },"},
{"lineNum":"  652","line":"        list.items(.c),"},
{"lineNum":"  653","line":"    );"},
{"lineNum":"  654","line":""},
{"lineNum":"  655","line":"    list.shrinkAndFree(ally, 3);"},
{"lineNum":"  656","line":""},
{"lineNum":"  657","line":"    try testing.expectEqualSlices(u32, list.items(.a), &[_]u32{ 1, 2, 3 });"},
{"lineNum":"  658","line":"    try testing.expectEqualSlices(u8, list.items(.c), &[_]u8{ \'a\', \'b\', \'c\' });"},
{"lineNum":"  659","line":""},
{"lineNum":"  660","line":"    try testing.expectEqual(@as(usize, 3), list.items(.b).len);"},
{"lineNum":"  661","line":"    try testing.expectEqualStrings(\"foobar\", list.items(.b)[0]);"},
{"lineNum":"  662","line":"    try testing.expectEqualStrings(\"zigzag\", list.items(.b)[1]);"},
{"lineNum":"  663","line":"    try testing.expectEqualStrings(\"fizzbuzz\", list.items(.b)[2]);"},
{"lineNum":"  664","line":""},
{"lineNum":"  665","line":"    list.set(try list.addOne(ally), .{"},
{"lineNum":"  666","line":"        .a = 4,"},
{"lineNum":"  667","line":"        .b = \"xnopyt\","},
{"lineNum":"  668","line":"        .c = \'d\',"},
{"lineNum":"  669","line":"    });"},
{"lineNum":"  670","line":"    try testing.expectEqualStrings(\"xnopyt\", list.pop().b);"},
{"lineNum":"  671","line":"    try testing.expectEqual(@as(?u8, \'c\'), if (list.popOrNull()) |elem| elem.c else null);"},
{"lineNum":"  672","line":"    try testing.expectEqual(@as(u32, 2), list.pop().a);"},
{"lineNum":"  673","line":"    try testing.expectEqual(@as(u8, \'a\'), list.pop().c);"},
{"lineNum":"  674","line":"    try testing.expectEqual(@as(?Foo, null), list.popOrNull());"},
{"lineNum":"  675","line":"}"},
{"lineNum":"  676","line":""},
{"lineNum":"  677","line":"// This was observed to fail on aarch64 with LLVM 11, when the capacityInBytes"},
{"lineNum":"  678","line":"// function used the @reduce code path."},
{"lineNum":"  679","line":"test \"regression test for @reduce bug\" {"},
{"lineNum":"  680","line":"    const ally = testing.allocator;"},
{"lineNum":"  681","line":"    var list = MultiArrayList(struct {"},
{"lineNum":"  682","line":"        tag: std.zig.Token.Tag,"},
{"lineNum":"  683","line":"        start: u32,"},
{"lineNum":"  684","line":"    }){};"},
{"lineNum":"  685","line":"    defer list.deinit(ally);"},
{"lineNum":"  686","line":""},
{"lineNum":"  687","line":"    try list.ensureTotalCapacity(ally, 20);"},
{"lineNum":"  688","line":""},
{"lineNum":"  689","line":"    try list.append(ally, .{ .tag = .keyword_const, .start = 0 });"},
{"lineNum":"  690","line":"    try list.append(ally, .{ .tag = .identifier, .start = 6 });"},
{"lineNum":"  691","line":"    try list.append(ally, .{ .tag = .equal, .start = 10 });"},
{"lineNum":"  692","line":"    try list.append(ally, .{ .tag = .builtin, .start = 12 });"},
{"lineNum":"  693","line":"    try list.append(ally, .{ .tag = .l_paren, .start = 19 });"},
{"lineNum":"  694","line":"    try list.append(ally, .{ .tag = .string_literal, .start = 20 });"},
{"lineNum":"  695","line":"    try list.append(ally, .{ .tag = .r_paren, .start = 25 });"},
{"lineNum":"  696","line":"    try list.append(ally, .{ .tag = .semicolon, .start = 26 });"},
{"lineNum":"  697","line":"    try list.append(ally, .{ .tag = .keyword_pub, .start = 29 });"},
{"lineNum":"  698","line":"    try list.append(ally, .{ .tag = .keyword_fn, .start = 33 });"},
{"lineNum":"  699","line":"    try list.append(ally, .{ .tag = .identifier, .start = 36 });"},
{"lineNum":"  700","line":"    try list.append(ally, .{ .tag = .l_paren, .start = 40 });"},
{"lineNum":"  701","line":"    try list.append(ally, .{ .tag = .r_paren, .start = 41 });"},
{"lineNum":"  702","line":"    try list.append(ally, .{ .tag = .identifier, .start = 43 });"},
{"lineNum":"  703","line":"    try list.append(ally, .{ .tag = .bang, .start = 51 });"},
{"lineNum":"  704","line":"    try list.append(ally, .{ .tag = .identifier, .start = 52 });"},
{"lineNum":"  705","line":"    try list.append(ally, .{ .tag = .l_brace, .start = 57 });"},
{"lineNum":"  706","line":"    try list.append(ally, .{ .tag = .identifier, .start = 63 });"},
{"lineNum":"  707","line":"    try list.append(ally, .{ .tag = .period, .start = 66 });"},
{"lineNum":"  708","line":"    try list.append(ally, .{ .tag = .identifier, .start = 67 });"},
{"lineNum":"  709","line":"    try list.append(ally, .{ .tag = .period, .start = 70 });"},
{"lineNum":"  710","line":"    try list.append(ally, .{ .tag = .identifier, .start = 71 });"},
{"lineNum":"  711","line":"    try list.append(ally, .{ .tag = .l_paren, .start = 75 });"},
{"lineNum":"  712","line":"    try list.append(ally, .{ .tag = .string_literal, .start = 76 });"},
{"lineNum":"  713","line":"    try list.append(ally, .{ .tag = .comma, .start = 113 });"},
{"lineNum":"  714","line":"    try list.append(ally, .{ .tag = .period, .start = 115 });"},
{"lineNum":"  715","line":"    try list.append(ally, .{ .tag = .l_brace, .start = 116 });"},
{"lineNum":"  716","line":"    try list.append(ally, .{ .tag = .r_brace, .start = 117 });"},
{"lineNum":"  717","line":"    try list.append(ally, .{ .tag = .r_paren, .start = 118 });"},
{"lineNum":"  718","line":"    try list.append(ally, .{ .tag = .semicolon, .start = 119 });"},
{"lineNum":"  719","line":"    try list.append(ally, .{ .tag = .r_brace, .start = 121 });"},
{"lineNum":"  720","line":"    try list.append(ally, .{ .tag = .eof, .start = 123 });"},
{"lineNum":"  721","line":""},
{"lineNum":"  722","line":"    const tags = list.items(.tag);"},
{"lineNum":"  723","line":"    try testing.expectEqual(tags[1], .identifier);"},
{"lineNum":"  724","line":"    try testing.expectEqual(tags[2], .equal);"},
{"lineNum":"  725","line":"    try testing.expectEqual(tags[3], .builtin);"},
{"lineNum":"  726","line":"    try testing.expectEqual(tags[4], .l_paren);"},
{"lineNum":"  727","line":"    try testing.expectEqual(tags[5], .string_literal);"},
{"lineNum":"  728","line":"    try testing.expectEqual(tags[6], .r_paren);"},
{"lineNum":"  729","line":"    try testing.expectEqual(tags[7], .semicolon);"},
{"lineNum":"  730","line":"    try testing.expectEqual(tags[8], .keyword_pub);"},
{"lineNum":"  731","line":"    try testing.expectEqual(tags[9], .keyword_fn);"},
{"lineNum":"  732","line":"    try testing.expectEqual(tags[10], .identifier);"},
{"lineNum":"  733","line":"    try testing.expectEqual(tags[11], .l_paren);"},
{"lineNum":"  734","line":"    try testing.expectEqual(tags[12], .r_paren);"},
{"lineNum":"  735","line":"    try testing.expectEqual(tags[13], .identifier);"},
{"lineNum":"  736","line":"    try testing.expectEqual(tags[14], .bang);"},
{"lineNum":"  737","line":"    try testing.expectEqual(tags[15], .identifier);"},
{"lineNum":"  738","line":"    try testing.expectEqual(tags[16], .l_brace);"},
{"lineNum":"  739","line":"    try testing.expectEqual(tags[17], .identifier);"},
{"lineNum":"  740","line":"    try testing.expectEqual(tags[18], .period);"},
{"lineNum":"  741","line":"    try testing.expectEqual(tags[19], .identifier);"},
{"lineNum":"  742","line":"    try testing.expectEqual(tags[20], .period);"},
{"lineNum":"  743","line":"    try testing.expectEqual(tags[21], .identifier);"},
{"lineNum":"  744","line":"    try testing.expectEqual(tags[22], .l_paren);"},
{"lineNum":"  745","line":"    try testing.expectEqual(tags[23], .string_literal);"},
{"lineNum":"  746","line":"    try testing.expectEqual(tags[24], .comma);"},
{"lineNum":"  747","line":"    try testing.expectEqual(tags[25], .period);"},
{"lineNum":"  748","line":"    try testing.expectEqual(tags[26], .l_brace);"},
{"lineNum":"  749","line":"    try testing.expectEqual(tags[27], .r_brace);"},
{"lineNum":"  750","line":"    try testing.expectEqual(tags[28], .r_paren);"},
{"lineNum":"  751","line":"    try testing.expectEqual(tags[29], .semicolon);"},
{"lineNum":"  752","line":"    try testing.expectEqual(tags[30], .r_brace);"},
{"lineNum":"  753","line":"    try testing.expectEqual(tags[31], .eof);"},
{"lineNum":"  754","line":"}"},
{"lineNum":"  755","line":""},
{"lineNum":"  756","line":"test \"ensure capacity on empty list\" {"},
{"lineNum":"  757","line":"    const ally = testing.allocator;"},
{"lineNum":"  758","line":""},
{"lineNum":"  759","line":"    const Foo = struct {"},
{"lineNum":"  760","line":"        a: u32,"},
{"lineNum":"  761","line":"        b: u8,"},
{"lineNum":"  762","line":"    };"},
{"lineNum":"  763","line":""},
{"lineNum":"  764","line":"    var list = MultiArrayList(Foo){};"},
{"lineNum":"  765","line":"    defer list.deinit(ally);"},
{"lineNum":"  766","line":""},
{"lineNum":"  767","line":"    try list.ensureTotalCapacity(ally, 2);"},
{"lineNum":"  768","line":"    list.appendAssumeCapacity(.{ .a = 1, .b = 2 });"},
{"lineNum":"  769","line":"    list.appendAssumeCapacity(.{ .a = 3, .b = 4 });"},
{"lineNum":"  770","line":""},
{"lineNum":"  771","line":"    try testing.expectEqualSlices(u32, &[_]u32{ 1, 3 }, list.items(.a));"},
{"lineNum":"  772","line":"    try testing.expectEqualSlices(u8, &[_]u8{ 2, 4 }, list.items(.b));"},
{"lineNum":"  773","line":""},
{"lineNum":"  774","line":"    list.len = 0;"},
{"lineNum":"  775","line":"    list.appendAssumeCapacity(.{ .a = 5, .b = 6 });"},
{"lineNum":"  776","line":"    list.appendAssumeCapacity(.{ .a = 7, .b = 8 });"},
{"lineNum":"  777","line":""},
{"lineNum":"  778","line":"    try testing.expectEqualSlices(u32, &[_]u32{ 5, 7 }, list.items(.a));"},
{"lineNum":"  779","line":"    try testing.expectEqualSlices(u8, &[_]u8{ 6, 8 }, list.items(.b));"},
{"lineNum":"  780","line":""},
{"lineNum":"  781","line":"    list.len = 0;"},
{"lineNum":"  782","line":"    try list.ensureTotalCapacity(ally, 16);"},
{"lineNum":"  783","line":""},
{"lineNum":"  784","line":"    list.appendAssumeCapacity(.{ .a = 9, .b = 10 });"},
{"lineNum":"  785","line":"    list.appendAssumeCapacity(.{ .a = 11, .b = 12 });"},
{"lineNum":"  786","line":""},
{"lineNum":"  787","line":"    try testing.expectEqualSlices(u32, &[_]u32{ 9, 11 }, list.items(.a));"},
{"lineNum":"  788","line":"    try testing.expectEqualSlices(u8, &[_]u8{ 10, 12 }, list.items(.b));"},
{"lineNum":"  789","line":"}"},
{"lineNum":"  790","line":""},
{"lineNum":"  791","line":"test \"insert elements\" {"},
{"lineNum":"  792","line":"    const ally = testing.allocator;"},
{"lineNum":"  793","line":""},
{"lineNum":"  794","line":"    const Foo = struct {"},
{"lineNum":"  795","line":"        a: u8,"},
{"lineNum":"  796","line":"        b: u32,"},
{"lineNum":"  797","line":"    };"},
{"lineNum":"  798","line":""},
{"lineNum":"  799","line":"    var list = MultiArrayList(Foo){};"},
{"lineNum":"  800","line":"    defer list.deinit(ally);"},
{"lineNum":"  801","line":""},
{"lineNum":"  802","line":"    try list.insert(ally, 0, .{ .a = 1, .b = 2 });"},
{"lineNum":"  803","line":"    try list.ensureUnusedCapacity(ally, 1);"},
{"lineNum":"  804","line":"    list.insertAssumeCapacity(1, .{ .a = 2, .b = 3 });"},
{"lineNum":"  805","line":""},
{"lineNum":"  806","line":"    try testing.expectEqualSlices(u8, &[_]u8{ 1, 2 }, list.items(.a));"},
{"lineNum":"  807","line":"    try testing.expectEqualSlices(u32, &[_]u32{ 2, 3 }, list.items(.b));"},
{"lineNum":"  808","line":"}"},
{"lineNum":"  809","line":""},
{"lineNum":"  810","line":"test \"union\" {"},
{"lineNum":"  811","line":"    const ally = testing.allocator;"},
{"lineNum":"  812","line":""},
{"lineNum":"  813","line":"    const Foo = union(enum) {"},
{"lineNum":"  814","line":"        a: u32,"},
{"lineNum":"  815","line":"        b: []const u8,"},
{"lineNum":"  816","line":"    };"},
{"lineNum":"  817","line":""},
{"lineNum":"  818","line":"    var list = MultiArrayList(Foo){};"},
{"lineNum":"  819","line":"    defer list.deinit(ally);"},
{"lineNum":"  820","line":""},
{"lineNum":"  821","line":"    try testing.expectEqual(@as(usize, 0), list.items(.tags).len);"},
{"lineNum":"  822","line":""},
{"lineNum":"  823","line":"    try list.ensureTotalCapacity(ally, 2);"},
{"lineNum":"  824","line":""},
{"lineNum":"  825","line":"    list.appendAssumeCapacity(.{ .a = 1 });"},
{"lineNum":"  826","line":"    list.appendAssumeCapacity(.{ .b = \"zigzag\" });"},
{"lineNum":"  827","line":""},
{"lineNum":"  828","line":"    try testing.expectEqualSlices(meta.Tag(Foo), list.items(.tags), &.{ .a, .b });"},
{"lineNum":"  829","line":"    try testing.expectEqual(@as(usize, 2), list.items(.tags).len);"},
{"lineNum":"  830","line":""},
{"lineNum":"  831","line":"    list.appendAssumeCapacity(.{ .b = \"foobar\" });"},
{"lineNum":"  832","line":"    try testing.expectEqualStrings(\"zigzag\", list.items(.data)[1].b);"},
{"lineNum":"  833","line":"    try testing.expectEqualStrings(\"foobar\", list.items(.data)[2].b);"},
{"lineNum":"  834","line":""},
{"lineNum":"  835","line":"    // Add 6 more things to force a capacity increase."},
{"lineNum":"  836","line":"    for (0..6) |i| {"},
{"lineNum":"  837","line":"        try list.append(ally, .{ .a = @as(u32, @intCast(4 + i)) });"},
{"lineNum":"  838","line":"    }"},
{"lineNum":"  839","line":""},
{"lineNum":"  840","line":"    try testing.expectEqualSlices("},
{"lineNum":"  841","line":"        meta.Tag(Foo),"},
{"lineNum":"  842","line":"        &.{ .a, .b, .b, .a, .a, .a, .a, .a, .a },"},
{"lineNum":"  843","line":"        list.items(.tags),"},
{"lineNum":"  844","line":"    );"},
{"lineNum":"  845","line":"    try testing.expectEqual(list.get(0), .{ .a = 1 });"},
{"lineNum":"  846","line":"    try testing.expectEqual(list.get(1), .{ .b = \"zigzag\" });"},
{"lineNum":"  847","line":"    try testing.expectEqual(list.get(2), .{ .b = \"foobar\" });"},
{"lineNum":"  848","line":"    try testing.expectEqual(list.get(3), .{ .a = 4 });"},
{"lineNum":"  849","line":"    try testing.expectEqual(list.get(4), .{ .a = 5 });"},
{"lineNum":"  850","line":"    try testing.expectEqual(list.get(5), .{ .a = 6 });"},
{"lineNum":"  851","line":"    try testing.expectEqual(list.get(6), .{ .a = 7 });"},
{"lineNum":"  852","line":"    try testing.expectEqual(list.get(7), .{ .a = 8 });"},
{"lineNum":"  853","line":"    try testing.expectEqual(list.get(8), .{ .a = 9 });"},
{"lineNum":"  854","line":""},
{"lineNum":"  855","line":"    list.shrinkAndFree(ally, 3);"},
{"lineNum":"  856","line":""},
{"lineNum":"  857","line":"    try testing.expectEqual(@as(usize, 3), list.items(.tags).len);"},
{"lineNum":"  858","line":"    try testing.expectEqualSlices(meta.Tag(Foo), list.items(.tags), &.{ .a, .b, .b });"},
{"lineNum":"  859","line":""},
{"lineNum":"  860","line":"    try testing.expectEqual(list.get(0), .{ .a = 1 });"},
{"lineNum":"  861","line":"    try testing.expectEqual(list.get(1), .{ .b = \"zigzag\" });"},
{"lineNum":"  862","line":"    try testing.expectEqual(list.get(2), .{ .b = \"foobar\" });"},
{"lineNum":"  863","line":"}"},
{"lineNum":"  864","line":""},
{"lineNum":"  865","line":"test \"sorting a span\" {"},
{"lineNum":"  866","line":"    var list: MultiArrayList(struct { score: u32, chr: u8 }) = .{};"},
{"lineNum":"  867","line":"    defer list.deinit(testing.allocator);"},
{"lineNum":"  868","line":""},
{"lineNum":"  869","line":"    try list.ensureTotalCapacity(testing.allocator, 42);"},
{"lineNum":"  870","line":"    for ("},
{"lineNum":"  871","line":"        // zig fmt: off"},
{"lineNum":"  872","line":"        [42]u8{ \'b\', \'a\', \'c\', \'a\', \'b\', \'c\', \'b\', \'c\', \'b\', \'a\', \'b\', \'a\', \'b\', \'c\', \'b\', \'a\', \'a\', \'c\', \'c\', \'a\', \'c\', \'b\', \'a\', \'c\', \'a\', \'b\', \'b\', \'c\', \'c\', \'b\', \'a\', \'b\', \'a\', \'b\', \'c\', \'b\', \'a\', \'a\', \'c\', \'c\', \'a\', \'c\' },"},
{"lineNum":"  873","line":"        [42]u32{ 1,   1,   1,   2,   2,   2,   3,   3,   4,   3,   5,   4,   6,   4,   7,   5,   6,   5,   6,   7,   7,   8,   8,   8,   9,   9,  10,   9,  10,  11,  10,  12,  11,  13,  11,  14,  12,  13,  12,  13,  14,  14 },"},
{"lineNum":"  874","line":"        // zig fmt: on"},
{"lineNum":"  875","line":"    ) |chr, score| {"},
{"lineNum":"  876","line":"        list.appendAssumeCapacity(.{ .chr = chr, .score = score });"},
{"lineNum":"  877","line":"    }"},
{"lineNum":"  878","line":""},
{"lineNum":"  879","line":"    const sliced = list.slice();"},
{"lineNum":"  880","line":"    list.sortSpan(6, 21, struct {"},
{"lineNum":"  881","line":"        chars: []const u8,"},
{"lineNum":"  882","line":""},
{"lineNum":"  883","line":"        fn lessThan(ctx: @This(), a: usize, b: usize) bool {"},
{"lineNum":"  884","line":"            return ctx.chars[a] < ctx.chars[b];"},
{"lineNum":"  885","line":"        }"},
{"lineNum":"  886","line":"    }{ .chars = sliced.items(.chr) });"},
{"lineNum":"  887","line":""},
{"lineNum":"  888","line":"    var i: u32 = undefined;"},
{"lineNum":"  889","line":"    var j: u32 = 6;"},
{"lineNum":"  890","line":"    var c: u8 = \'a\';"},
{"lineNum":"  891","line":""},
{"lineNum":"  892","line":"    while (j < 21) {"},
{"lineNum":"  893","line":"        i = j;"},
{"lineNum":"  894","line":"        j += 5;"},
{"lineNum":"  895","line":"        var n: u32 = 3;"},
{"lineNum":"  896","line":"        for (sliced.items(.chr)[i..j], sliced.items(.score)[i..j]) |chr, score| {"},
{"lineNum":"  897","line":"            try testing.expectEqual(score, n);"},
{"lineNum":"  898","line":"            try testing.expectEqual(chr, c);"},
{"lineNum":"  899","line":"            n += 1;"},
{"lineNum":"  900","line":"        }"},
{"lineNum":"  901","line":"        c += 1;"},
{"lineNum":"  902","line":"    }"},
{"lineNum":"  903","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test", "date" : "2024-04-26 16:14:49", "instrumented" : 57, "covered" : 0,};
var merged_data = [];
