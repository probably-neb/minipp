var data = {lines:[
{"lineNum":"    1","line":"//! Futex is a mechanism used to block (`wait`) and unblock (`wake`) threads using a 32bit memory address as hints."},
{"lineNum":"    2","line":"//! Blocking a thread is acknowledged only if the 32bit memory address is equal to a given value."},
{"lineNum":"    3","line":"//! This check helps avoid block/unblock deadlocks which occur if a `wake()` happens before a `wait()`."},
{"lineNum":"    4","line":"//! Using Futex, other Thread synchronization primitives can be built which efficiently wait for cross-thread events or signals."},
{"lineNum":"    5","line":""},
{"lineNum":"    6","line":"const std = @import(\"../std.zig\");"},
{"lineNum":"    7","line":"const builtin = @import(\"builtin\");"},
{"lineNum":"    8","line":"const Futex = @This();"},
{"lineNum":"    9","line":""},
{"lineNum":"   10","line":"const os = std.os;"},
{"lineNum":"   11","line":"const assert = std.debug.assert;"},
{"lineNum":"   12","line":"const testing = std.testing;"},
{"lineNum":"   13","line":"const Atomic = std.atomic.Atomic;"},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"/// Checks if `ptr` still contains the value `expect` and, if so, blocks the caller until either:"},
{"lineNum":"   16","line":"/// - The value at `ptr` is no longer equal to `expect`."},
{"lineNum":"   17","line":"/// - The caller is unblocked by a matching `wake()`."},
{"lineNum":"   18","line":"/// - The caller is unblocked spuriously (\"at random\")."},
{"lineNum":"   19","line":"///"},
{"lineNum":"   20","line":"/// The checking of `ptr` and `expect`, along with blocking the caller, is done atomically"},
{"lineNum":"   21","line":"/// and totally ordered (sequentially consistent) with respect to other wait()/wake() calls on the same `ptr`."},
{"lineNum":"   22","line":"pub fn wait(ptr: *const Atomic(u32), expect: u32) void {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   23","line":"    @setCold(true);"},
{"lineNum":"   24","line":""},
{"lineNum":"   25","line":"    Impl.wait(ptr, expect, null) catch |err| switch (err) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   26","line":"        error.Timeout => unreachable, // null timeout meant to wait forever","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   27","line":"    };"},
{"lineNum":"   28","line":"}"},
{"lineNum":"   29","line":""},
{"lineNum":"   30","line":"/// Checks if `ptr` still contains the value `expect` and, if so, blocks the caller until either:"},
{"lineNum":"   31","line":"/// - The value at `ptr` is no longer equal to `expect`."},
{"lineNum":"   32","line":"/// - The caller is unblocked by a matching `wake()`."},
{"lineNum":"   33","line":"/// - The caller is unblocked spuriously (\"at random\")."},
{"lineNum":"   34","line":"/// - The caller blocks for longer than the given timeout. In which case, `error.Timeout` is returned."},
{"lineNum":"   35","line":"///"},
{"lineNum":"   36","line":"/// The checking of `ptr` and `expect`, along with blocking the caller, is done atomically"},
{"lineNum":"   37","line":"/// and totally ordered (sequentially consistent) with respect to other wait()/wake() calls on the same `ptr`."},
{"lineNum":"   38","line":"pub fn timedWait(ptr: *const Atomic(u32), expect: u32, timeout_ns: u64) error{Timeout}!void {"},
{"lineNum":"   39","line":"    @setCold(true);"},
{"lineNum":"   40","line":""},
{"lineNum":"   41","line":"    // Avoid calling into the OS for no-op timeouts."},
{"lineNum":"   42","line":"    if (timeout_ns == 0) {"},
{"lineNum":"   43","line":"        if (ptr.load(.SeqCst) != expect) return;"},
{"lineNum":"   44","line":"        return error.Timeout;"},
{"lineNum":"   45","line":"    }"},
{"lineNum":"   46","line":""},
{"lineNum":"   47","line":"    return Impl.wait(ptr, expect, timeout_ns);"},
{"lineNum":"   48","line":"}"},
{"lineNum":"   49","line":""},
{"lineNum":"   50","line":"/// Unblocks at most `max_waiters` callers blocked in a `wait()` call on `ptr`."},
{"lineNum":"   51","line":"pub fn wake(ptr: *const Atomic(u32), max_waiters: u32) void {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   52","line":"    @setCold(true);"},
{"lineNum":"   53","line":""},
{"lineNum":"   54","line":"    // Avoid calling into the OS if there\'s nothing to wake up."},
{"lineNum":"   55","line":"    if (max_waiters == 0) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   56","line":"        return;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   57","line":"    }"},
{"lineNum":"   58","line":""},
{"lineNum":"   59","line":"    Impl.wake(ptr, max_waiters);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   60","line":"}"},
{"lineNum":"   61","line":""},
{"lineNum":"   62","line":"const Impl = if (builtin.single_threaded)"},
{"lineNum":"   63","line":"    SingleThreadedImpl"},
{"lineNum":"   64","line":"else if (builtin.os.tag == .windows)"},
{"lineNum":"   65","line":"    WindowsImpl"},
{"lineNum":"   66","line":"else if (builtin.os.tag.isDarwin())"},
{"lineNum":"   67","line":"    DarwinImpl"},
{"lineNum":"   68","line":"else if (builtin.os.tag == .linux)"},
{"lineNum":"   69","line":"    LinuxImpl"},
{"lineNum":"   70","line":"else if (builtin.os.tag == .freebsd)"},
{"lineNum":"   71","line":"    FreebsdImpl"},
{"lineNum":"   72","line":"else if (builtin.os.tag == .openbsd)"},
{"lineNum":"   73","line":"    OpenbsdImpl"},
{"lineNum":"   74","line":"else if (builtin.os.tag == .dragonfly)"},
{"lineNum":"   75","line":"    DragonflyImpl"},
{"lineNum":"   76","line":"else if (builtin.target.isWasm())"},
{"lineNum":"   77","line":"    WasmImpl"},
{"lineNum":"   78","line":"else if (std.Thread.use_pthreads)"},
{"lineNum":"   79","line":"    PosixImpl"},
{"lineNum":"   80","line":"else"},
{"lineNum":"   81","line":"    UnsupportedImpl;"},
{"lineNum":"   82","line":""},
{"lineNum":"   83","line":"/// We can\'t do @compileError() in the `Impl` switch statement above as its eagerly evaluated."},
{"lineNum":"   84","line":"/// So instead, we @compileError() on the methods themselves for platforms which don\'t support futex."},
{"lineNum":"   85","line":"const UnsupportedImpl = struct {"},
{"lineNum":"   86","line":"    fn wait(ptr: *const Atomic(u32), expect: u32, timeout: ?u64) error{Timeout}!void {"},
{"lineNum":"   87","line":"        return unsupported(.{ ptr, expect, timeout });"},
{"lineNum":"   88","line":"    }"},
{"lineNum":"   89","line":""},
{"lineNum":"   90","line":"    fn wake(ptr: *const Atomic(u32), max_waiters: u32) void {"},
{"lineNum":"   91","line":"        return unsupported(.{ ptr, max_waiters });"},
{"lineNum":"   92","line":"    }"},
{"lineNum":"   93","line":""},
{"lineNum":"   94","line":"    fn unsupported(unused: anytype) noreturn {"},
{"lineNum":"   95","line":"        _ = unused;"},
{"lineNum":"   96","line":"        @compileError(\"Unsupported operating system \" ++ @tagName(builtin.target.os.tag));"},
{"lineNum":"   97","line":"    }"},
{"lineNum":"   98","line":"};"},
{"lineNum":"   99","line":""},
{"lineNum":"  100","line":"const SingleThreadedImpl = struct {"},
{"lineNum":"  101","line":"    fn wait(ptr: *const Atomic(u32), expect: u32, timeout: ?u64) error{Timeout}!void {"},
{"lineNum":"  102","line":"        if (ptr.loadUnchecked() != expect) {"},
{"lineNum":"  103","line":"            return;"},
{"lineNum":"  104","line":"        }"},
{"lineNum":"  105","line":""},
{"lineNum":"  106","line":"        // There are no threads to wake us up."},
{"lineNum":"  107","line":"        // So if we wait without a timeout we would never wake up."},
{"lineNum":"  108","line":"        const delay = timeout orelse {"},
{"lineNum":"  109","line":"            unreachable; // deadlock detected"},
{"lineNum":"  110","line":"        };"},
{"lineNum":"  111","line":""},
{"lineNum":"  112","line":"        std.time.sleep(delay);"},
{"lineNum":"  113","line":"        return error.Timeout;"},
{"lineNum":"  114","line":"    }"},
{"lineNum":"  115","line":""},
{"lineNum":"  116","line":"    fn wake(ptr: *const Atomic(u32), max_waiters: u32) void {"},
{"lineNum":"  117","line":"        // There are no other threads to possibly wake up"},
{"lineNum":"  118","line":"        _ = ptr;"},
{"lineNum":"  119","line":"        _ = max_waiters;"},
{"lineNum":"  120","line":"    }"},
{"lineNum":"  121","line":"};"},
{"lineNum":"  122","line":""},
{"lineNum":"  123","line":"// We use WaitOnAddress through NtDll instead of API-MS-Win-Core-Synch-l1-2-0.dll"},
{"lineNum":"  124","line":"// as it\'s generally already a linked target and is autoloaded into all processes anyway."},
{"lineNum":"  125","line":"const WindowsImpl = struct {"},
{"lineNum":"  126","line":"    fn wait(ptr: *const Atomic(u32), expect: u32, timeout: ?u64) error{Timeout}!void {"},
{"lineNum":"  127","line":"        var timeout_value: os.windows.LARGE_INTEGER = undefined;"},
{"lineNum":"  128","line":"        var timeout_ptr: ?*const os.windows.LARGE_INTEGER = null;"},
{"lineNum":"  129","line":""},
{"lineNum":"  130","line":"        // NTDLL functions work with time in units of 100 nanoseconds."},
{"lineNum":"  131","line":"        // Positive values are absolute deadlines while negative values are relative durations."},
{"lineNum":"  132","line":"        if (timeout) |delay| {"},
{"lineNum":"  133","line":"            timeout_value = @as(os.windows.LARGE_INTEGER, @intCast(delay / 100));"},
{"lineNum":"  134","line":"            timeout_value = -timeout_value;"},
{"lineNum":"  135","line":"            timeout_ptr = &timeout_value;"},
{"lineNum":"  136","line":"        }"},
{"lineNum":"  137","line":""},
{"lineNum":"  138","line":"        const rc = os.windows.ntdll.RtlWaitOnAddress("},
{"lineNum":"  139","line":"            @as(?*const anyopaque, @ptrCast(ptr)),"},
{"lineNum":"  140","line":"            @as(?*const anyopaque, @ptrCast(&expect)),"},
{"lineNum":"  141","line":"            @sizeOf(@TypeOf(expect)),"},
{"lineNum":"  142","line":"            timeout_ptr,"},
{"lineNum":"  143","line":"        );"},
{"lineNum":"  144","line":""},
{"lineNum":"  145","line":"        switch (rc) {"},
{"lineNum":"  146","line":"            .SUCCESS => {},"},
{"lineNum":"  147","line":"            .TIMEOUT => {"},
{"lineNum":"  148","line":"                assert(timeout != null);"},
{"lineNum":"  149","line":"                return error.Timeout;"},
{"lineNum":"  150","line":"            },"},
{"lineNum":"  151","line":"            else => unreachable,"},
{"lineNum":"  152","line":"        }"},
{"lineNum":"  153","line":"    }"},
{"lineNum":"  154","line":""},
{"lineNum":"  155","line":"    fn wake(ptr: *const Atomic(u32), max_waiters: u32) void {"},
{"lineNum":"  156","line":"        const address = @as(?*const anyopaque, @ptrCast(ptr));"},
{"lineNum":"  157","line":"        assert(max_waiters != 0);"},
{"lineNum":"  158","line":""},
{"lineNum":"  159","line":"        switch (max_waiters) {"},
{"lineNum":"  160","line":"            1 => os.windows.ntdll.RtlWakeAddressSingle(address),"},
{"lineNum":"  161","line":"            else => os.windows.ntdll.RtlWakeAddressAll(address),"},
{"lineNum":"  162","line":"        }"},
{"lineNum":"  163","line":"    }"},
{"lineNum":"  164","line":"};"},
{"lineNum":"  165","line":""},
{"lineNum":"  166","line":"const DarwinImpl = struct {"},
{"lineNum":"  167","line":"    fn wait(ptr: *const Atomic(u32), expect: u32, timeout: ?u64) error{Timeout}!void {"},
{"lineNum":"  168","line":"        // Darwin XNU 7195.50.7.100.1 introduced __ulock_wait2 and migrated code paths (notably pthread_cond_t) towards it:"},
{"lineNum":"  169","line":"        // https://github.com/apple/darwin-xnu/commit/d4061fb0260b3ed486147341b72468f836ed6c8f#diff-08f993cc40af475663274687b7c326cc6c3031e0db3ac8de7b24624610616be6"},
{"lineNum":"  170","line":"        //"},
{"lineNum":"  171","line":"        // This XNU version appears to correspond to 11.0.1:"},
{"lineNum":"  172","line":"        // https://kernelshaman.blogspot.com/2021/01/building-xnu-for-macos-big-sur-1101.html"},
{"lineNum":"  173","line":"        //"},
{"lineNum":"  174","line":"        // ulock_wait() uses 32-bit micro-second timeouts where 0 = INFINITE or no-timeout"},
{"lineNum":"  175","line":"        // ulock_wait2() uses 64-bit nano-second timeouts (with the same convention)"},
{"lineNum":"  176","line":"        const supports_ulock_wait2 = builtin.target.os.version_range.semver.min.major >= 11;"},
{"lineNum":"  177","line":""},
{"lineNum":"  178","line":"        var timeout_ns: u64 = 0;"},
{"lineNum":"  179","line":"        if (timeout) |delay| {"},
{"lineNum":"  180","line":"            assert(delay != 0); // handled by timedWait()"},
{"lineNum":"  181","line":"            timeout_ns = delay;"},
{"lineNum":"  182","line":"        }"},
{"lineNum":"  183","line":""},
{"lineNum":"  184","line":"        // If we\'re using `__ulock_wait` and `timeout` is too big to fit inside a `u32` count of"},
{"lineNum":"  185","line":"        // micro-seconds (around 70min), we\'ll request a shorter timeout. This is fine (users"},
{"lineNum":"  186","line":"        // should handle spurious wakeups), but we need to remember that we did so, so that"},
{"lineNum":"  187","line":"        // we don\'t return `Timeout` incorrectly. If that happens, we set this variable to"},
{"lineNum":"  188","line":"        // true so that we we know to ignore the ETIMEDOUT result."},
{"lineNum":"  189","line":"        var timeout_overflowed = false;"},
{"lineNum":"  190","line":""},
{"lineNum":"  191","line":"        const addr = @as(*const anyopaque, @ptrCast(ptr));"},
{"lineNum":"  192","line":"        const flags = os.darwin.UL_COMPARE_AND_WAIT | os.darwin.ULF_NO_ERRNO;"},
{"lineNum":"  193","line":"        const status = blk: {"},
{"lineNum":"  194","line":"            if (supports_ulock_wait2) {"},
{"lineNum":"  195","line":"                break :blk os.darwin.__ulock_wait2(flags, addr, expect, timeout_ns, 0);"},
{"lineNum":"  196","line":"            }"},
{"lineNum":"  197","line":""},
{"lineNum":"  198","line":"            const timeout_us = std.math.cast(u32, timeout_ns / std.time.ns_per_us) orelse overflow: {"},
{"lineNum":"  199","line":"                timeout_overflowed = true;"},
{"lineNum":"  200","line":"                break :overflow std.math.maxInt(u32);"},
{"lineNum":"  201","line":"            };"},
{"lineNum":"  202","line":""},
{"lineNum":"  203","line":"            break :blk os.darwin.__ulock_wait(flags, addr, expect, timeout_us);"},
{"lineNum":"  204","line":"        };"},
{"lineNum":"  205","line":""},
{"lineNum":"  206","line":"        if (status >= 0) return;"},
{"lineNum":"  207","line":"        switch (@as(std.os.E, @enumFromInt(-status))) {"},
{"lineNum":"  208","line":"            // Wait was interrupted by the OS or other spurious signalling."},
{"lineNum":"  209","line":"            .INTR => {},"},
{"lineNum":"  210","line":"            // Address of the futex was paged out. This is unlikely, but possible in theory, and"},
{"lineNum":"  211","line":"            // pthread/libdispatch on darwin bother to handle it. In this case we\'ll return"},
{"lineNum":"  212","line":"            // without waiting, but the caller should retry anyway."},
{"lineNum":"  213","line":"            .FAULT => {},"},
{"lineNum":"  214","line":"            // Only report Timeout if we didn\'t have to cap the timeout"},
{"lineNum":"  215","line":"            .TIMEDOUT => {"},
{"lineNum":"  216","line":"                assert(timeout != null);"},
{"lineNum":"  217","line":"                if (!timeout_overflowed) return error.Timeout;"},
{"lineNum":"  218","line":"            },"},
{"lineNum":"  219","line":"            else => unreachable,"},
{"lineNum":"  220","line":"        }"},
{"lineNum":"  221","line":"    }"},
{"lineNum":"  222","line":""},
{"lineNum":"  223","line":"    fn wake(ptr: *const Atomic(u32), max_waiters: u32) void {"},
{"lineNum":"  224","line":"        var flags: u32 = os.darwin.UL_COMPARE_AND_WAIT | os.darwin.ULF_NO_ERRNO;"},
{"lineNum":"  225","line":"        if (max_waiters > 1) {"},
{"lineNum":"  226","line":"            flags |= os.darwin.ULF_WAKE_ALL;"},
{"lineNum":"  227","line":"        }"},
{"lineNum":"  228","line":""},
{"lineNum":"  229","line":"        while (true) {"},
{"lineNum":"  230","line":"            const addr = @as(*const anyopaque, @ptrCast(ptr));"},
{"lineNum":"  231","line":"            const status = os.darwin.__ulock_wake(flags, addr, 0);"},
{"lineNum":"  232","line":""},
{"lineNum":"  233","line":"            if (status >= 0) return;"},
{"lineNum":"  234","line":"            switch (@as(std.os.E, @enumFromInt(-status))) {"},
{"lineNum":"  235","line":"                .INTR => continue, // spurious wake()"},
{"lineNum":"  236","line":"                .FAULT => unreachable, // __ulock_wake doesn\'t generate EFAULT according to darwin pthread_cond_t"},
{"lineNum":"  237","line":"                .NOENT => return, // nothing was woken up"},
{"lineNum":"  238","line":"                .ALREADY => unreachable, // only for ULF_WAKE_THREAD"},
{"lineNum":"  239","line":"                else => unreachable,"},
{"lineNum":"  240","line":"            }"},
{"lineNum":"  241","line":"        }"},
{"lineNum":"  242","line":"    }"},
{"lineNum":"  243","line":"};"},
{"lineNum":"  244","line":""},
{"lineNum":"  245","line":"// https://man7.org/linux/man-pages/man2/futex.2.html"},
{"lineNum":"  246","line":"const LinuxImpl = struct {"},
{"lineNum":"  247","line":"    fn wait(ptr: *const Atomic(u32), expect: u32, timeout: ?u64) error{Timeout}!void {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  248","line":"        var ts: os.timespec = undefined;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  249","line":"        if (timeout) |timeout_ns| {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  250","line":"            ts.tv_sec = @as(@TypeOf(ts.tv_sec), @intCast(timeout_ns / std.time.ns_per_s));","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  251","line":"            ts.tv_nsec = @as(@TypeOf(ts.tv_nsec), @intCast(timeout_ns % std.time.ns_per_s));","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  252","line":"        }"},
{"lineNum":"  253","line":""},
{"lineNum":"  254","line":"        const rc = os.linux.futex_wait(","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  255","line":"            @as(*const i32, @ptrCast(&ptr.value)),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  256","line":"            os.linux.FUTEX.PRIVATE_FLAG | os.linux.FUTEX.WAIT,"},
{"lineNum":"  257","line":"            @as(i32, @bitCast(expect)),"},
{"lineNum":"  258","line":"            if (timeout != null) &ts else null,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  259","line":"        );"},
{"lineNum":"  260","line":""},
{"lineNum":"  261","line":"        switch (os.linux.getErrno(rc)) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  262","line":"            .SUCCESS => {}, // notified by `wake()`"},
{"lineNum":"  263","line":"            .INTR => {}, // spurious wakeup"},
{"lineNum":"  264","line":"            .AGAIN => {}, // ptr.* != expect"},
{"lineNum":"  265","line":"            .TIMEDOUT => {"},
{"lineNum":"  266","line":"                assert(timeout != null);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  267","line":"                return error.Timeout;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  268","line":"            },"},
{"lineNum":"  269","line":"            .INVAL => {}, // possibly timeout overflow"},
{"lineNum":"  270","line":"            .FAULT => unreachable, // ptr was invalid","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  271","line":"            else => unreachable,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  272","line":"        }"},
{"lineNum":"  273","line":"    }"},
{"lineNum":"  274","line":""},
{"lineNum":"  275","line":"    fn wake(ptr: *const Atomic(u32), max_waiters: u32) void {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  276","line":"        const rc = os.linux.futex_wake(","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  277","line":"            @as(*const i32, @ptrCast(&ptr.value)),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  278","line":"            os.linux.FUTEX.PRIVATE_FLAG | os.linux.FUTEX.WAKE,"},
{"lineNum":"  279","line":"            std.math.cast(i32, max_waiters) orelse std.math.maxInt(i32),","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  280","line":"        );"},
{"lineNum":"  281","line":""},
{"lineNum":"  282","line":"        switch (os.linux.getErrno(rc)) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  283","line":"            .SUCCESS => {}, // successful wake up"},
{"lineNum":"  284","line":"            .INVAL => {}, // invalid futex_wait() on ptr done elsewhere"},
{"lineNum":"  285","line":"            .FAULT => {}, // pointer became invalid while doing the wake"},
{"lineNum":"  286","line":"            else => unreachable,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  287","line":"        }"},
{"lineNum":"  288","line":"    }"},
{"lineNum":"  289","line":"};"},
{"lineNum":"  290","line":""},
{"lineNum":"  291","line":"// https://www.freebsd.org/cgi/man.cgi?query=_umtx_op&sektion=2&n=1"},
{"lineNum":"  292","line":"const FreebsdImpl = struct {"},
{"lineNum":"  293","line":"    fn wait(ptr: *const Atomic(u32), expect: u32, timeout: ?u64) error{Timeout}!void {"},
{"lineNum":"  294","line":"        var tm_size: usize = 0;"},
{"lineNum":"  295","line":"        var tm: os.freebsd._umtx_time = undefined;"},
{"lineNum":"  296","line":"        var tm_ptr: ?*const os.freebsd._umtx_time = null;"},
{"lineNum":"  297","line":""},
{"lineNum":"  298","line":"        if (timeout) |timeout_ns| {"},
{"lineNum":"  299","line":"            tm_ptr = &tm;"},
{"lineNum":"  300","line":"            tm_size = @sizeOf(@TypeOf(tm));"},
{"lineNum":"  301","line":""},
{"lineNum":"  302","line":"            tm._flags = 0; // use relative time not UMTX_ABSTIME"},
{"lineNum":"  303","line":"            tm._clockid = os.CLOCK.MONOTONIC;"},
{"lineNum":"  304","line":"            tm._timeout.tv_sec = @as(@TypeOf(tm._timeout.tv_sec), @intCast(timeout_ns / std.time.ns_per_s));"},
{"lineNum":"  305","line":"            tm._timeout.tv_nsec = @as(@TypeOf(tm._timeout.tv_nsec), @intCast(timeout_ns % std.time.ns_per_s));"},
{"lineNum":"  306","line":"        }"},
{"lineNum":"  307","line":""},
{"lineNum":"  308","line":"        const rc = os.freebsd._umtx_op("},
{"lineNum":"  309","line":"            @intFromPtr(&ptr.value),"},
{"lineNum":"  310","line":"            @intFromEnum(os.freebsd.UMTX_OP.WAIT_UINT_PRIVATE),"},
{"lineNum":"  311","line":"            @as(c_ulong, expect),"},
{"lineNum":"  312","line":"            tm_size,"},
{"lineNum":"  313","line":"            @intFromPtr(tm_ptr),"},
{"lineNum":"  314","line":"        );"},
{"lineNum":"  315","line":""},
{"lineNum":"  316","line":"        switch (os.errno(rc)) {"},
{"lineNum":"  317","line":"            .SUCCESS => {},"},
{"lineNum":"  318","line":"            .FAULT => unreachable, // one of the args points to invalid memory"},
{"lineNum":"  319","line":"            .INVAL => unreachable, // arguments should be correct"},
{"lineNum":"  320","line":"            .TIMEDOUT => {"},
{"lineNum":"  321","line":"                assert(timeout != null);"},
{"lineNum":"  322","line":"                return error.Timeout;"},
{"lineNum":"  323","line":"            },"},
{"lineNum":"  324","line":"            .INTR => {}, // spurious wake"},
{"lineNum":"  325","line":"            else => unreachable,"},
{"lineNum":"  326","line":"        }"},
{"lineNum":"  327","line":"    }"},
{"lineNum":"  328","line":""},
{"lineNum":"  329","line":"    fn wake(ptr: *const Atomic(u32), max_waiters: u32) void {"},
{"lineNum":"  330","line":"        const rc = os.freebsd._umtx_op("},
{"lineNum":"  331","line":"            @intFromPtr(&ptr.value),"},
{"lineNum":"  332","line":"            @intFromEnum(os.freebsd.UMTX_OP.WAKE_PRIVATE),"},
{"lineNum":"  333","line":"            @as(c_ulong, max_waiters),"},
{"lineNum":"  334","line":"            0, // there is no timeout struct"},
{"lineNum":"  335","line":"            0, // there is no timeout struct pointer"},
{"lineNum":"  336","line":"        );"},
{"lineNum":"  337","line":""},
{"lineNum":"  338","line":"        switch (os.errno(rc)) {"},
{"lineNum":"  339","line":"            .SUCCESS => {},"},
{"lineNum":"  340","line":"            .FAULT => {}, // it\'s ok if the ptr doesn\'t point to valid memory"},
{"lineNum":"  341","line":"            .INVAL => unreachable, // arguments should be correct"},
{"lineNum":"  342","line":"            else => unreachable,"},
{"lineNum":"  343","line":"        }"},
{"lineNum":"  344","line":"    }"},
{"lineNum":"  345","line":"};"},
{"lineNum":"  346","line":""},
{"lineNum":"  347","line":"// https://man.openbsd.org/futex.2"},
{"lineNum":"  348","line":"const OpenbsdImpl = struct {"},
{"lineNum":"  349","line":"    fn wait(ptr: *const Atomic(u32), expect: u32, timeout: ?u64) error{Timeout}!void {"},
{"lineNum":"  350","line":"        var ts: os.timespec = undefined;"},
{"lineNum":"  351","line":"        if (timeout) |timeout_ns| {"},
{"lineNum":"  352","line":"            ts.tv_sec = @as(@TypeOf(ts.tv_sec), @intCast(timeout_ns / std.time.ns_per_s));"},
{"lineNum":"  353","line":"            ts.tv_nsec = @as(@TypeOf(ts.tv_nsec), @intCast(timeout_ns % std.time.ns_per_s));"},
{"lineNum":"  354","line":"        }"},
{"lineNum":"  355","line":""},
{"lineNum":"  356","line":"        const rc = os.openbsd.futex("},
{"lineNum":"  357","line":"            @as(*const volatile u32, @ptrCast(&ptr.value)),"},
{"lineNum":"  358","line":"            os.openbsd.FUTEX_WAIT | os.openbsd.FUTEX_PRIVATE_FLAG,"},
{"lineNum":"  359","line":"            @as(c_int, @bitCast(expect)),"},
{"lineNum":"  360","line":"            if (timeout != null) &ts else null,"},
{"lineNum":"  361","line":"            null, // FUTEX_WAIT takes no requeue address"},
{"lineNum":"  362","line":"        );"},
{"lineNum":"  363","line":""},
{"lineNum":"  364","line":"        switch (os.errno(rc)) {"},
{"lineNum":"  365","line":"            .SUCCESS => {}, // woken up by wake"},
{"lineNum":"  366","line":"            .NOSYS => unreachable, // the futex operation shouldn\'t be invalid"},
{"lineNum":"  367","line":"            .FAULT => unreachable, // ptr was invalid"},
{"lineNum":"  368","line":"            .AGAIN => {}, // ptr != expect"},
{"lineNum":"  369","line":"            .INVAL => unreachable, // invalid timeout"},
{"lineNum":"  370","line":"            .TIMEDOUT => {"},
{"lineNum":"  371","line":"                assert(timeout != null);"},
{"lineNum":"  372","line":"                return error.Timeout;"},
{"lineNum":"  373","line":"            },"},
{"lineNum":"  374","line":"            .INTR => {}, // spurious wake from signal"},
{"lineNum":"  375","line":"            .CANCELED => {}, // spurious wake from signal with SA_RESTART"},
{"lineNum":"  376","line":"            else => unreachable,"},
{"lineNum":"  377","line":"        }"},
{"lineNum":"  378","line":"    }"},
{"lineNum":"  379","line":""},
{"lineNum":"  380","line":"    fn wake(ptr: *const Atomic(u32), max_waiters: u32) void {"},
{"lineNum":"  381","line":"        const rc = os.openbsd.futex("},
{"lineNum":"  382","line":"            @as(*const volatile u32, @ptrCast(&ptr.value)),"},
{"lineNum":"  383","line":"            os.openbsd.FUTEX_WAKE | os.openbsd.FUTEX_PRIVATE_FLAG,"},
{"lineNum":"  384","line":"            std.math.cast(c_int, max_waiters) orelse std.math.maxInt(c_int),"},
{"lineNum":"  385","line":"            null, // FUTEX_WAKE takes no timeout ptr"},
{"lineNum":"  386","line":"            null, // FUTEX_WAKE takes no requeue address"},
{"lineNum":"  387","line":"        );"},
{"lineNum":"  388","line":""},
{"lineNum":"  389","line":"        // returns number of threads woken up."},
{"lineNum":"  390","line":"        assert(rc >= 0);"},
{"lineNum":"  391","line":"    }"},
{"lineNum":"  392","line":"};"},
{"lineNum":"  393","line":""},
{"lineNum":"  394","line":"// https://man.dragonflybsd.org/?command=umtx&section=2"},
{"lineNum":"  395","line":"const DragonflyImpl = struct {"},
{"lineNum":"  396","line":"    fn wait(ptr: *const Atomic(u32), expect: u32, timeout: ?u64) error{Timeout}!void {"},
{"lineNum":"  397","line":"        // Dragonfly uses a scheme where 0 timeout means wait until signaled or spurious wake."},
{"lineNum":"  398","line":"        // It\'s reporting of timeout\'s is also unrealiable so we use an external timing source (Timer) instead."},
{"lineNum":"  399","line":"        var timeout_us: c_int = 0;"},
{"lineNum":"  400","line":"        var timeout_overflowed = false;"},
{"lineNum":"  401","line":"        var sleep_timer: std.time.Timer = undefined;"},
{"lineNum":"  402","line":""},
{"lineNum":"  403","line":"        if (timeout) |delay| {"},
{"lineNum":"  404","line":"            assert(delay != 0); // handled by timedWait()."},
{"lineNum":"  405","line":"            timeout_us = std.math.cast(c_int, delay / std.time.ns_per_us) orelse blk: {"},
{"lineNum":"  406","line":"                timeout_overflowed = true;"},
{"lineNum":"  407","line":"                break :blk std.math.maxInt(c_int);"},
{"lineNum":"  408","line":"            };"},
{"lineNum":"  409","line":""},
{"lineNum":"  410","line":"            // Only need to record the start time if we can provide somewhat accurate error.Timeout\'s"},
{"lineNum":"  411","line":"            if (!timeout_overflowed) {"},
{"lineNum":"  412","line":"                sleep_timer = std.time.Timer.start() catch unreachable;"},
{"lineNum":"  413","line":"            }"},
{"lineNum":"  414","line":"        }"},
{"lineNum":"  415","line":""},
{"lineNum":"  416","line":"        const value = @as(c_int, @bitCast(expect));"},
{"lineNum":"  417","line":"        const addr = @as(*const volatile c_int, @ptrCast(&ptr.value));"},
{"lineNum":"  418","line":"        const rc = os.dragonfly.umtx_sleep(addr, value, timeout_us);"},
{"lineNum":"  419","line":""},
{"lineNum":"  420","line":"        switch (os.errno(rc)) {"},
{"lineNum":"  421","line":"            .SUCCESS => {},"},
{"lineNum":"  422","line":"            .BUSY => {}, // ptr != expect"},
{"lineNum":"  423","line":"            .AGAIN => { // maybe timed out, or paged out, or hit 2s kernel refresh"},
{"lineNum":"  424","line":"                if (timeout) |timeout_ns| {"},
{"lineNum":"  425","line":"                    // Report error.Timeout only if we know the timeout duration has passed."},
{"lineNum":"  426","line":"                    // If not, there\'s not much choice other than treating it as a spurious wake."},
{"lineNum":"  427","line":"                    if (!timeout_overflowed and sleep_timer.read() >= timeout_ns) {"},
{"lineNum":"  428","line":"                        return error.Timeout;"},
{"lineNum":"  429","line":"                    }"},
{"lineNum":"  430","line":"                }"},
{"lineNum":"  431","line":"            },"},
{"lineNum":"  432","line":"            .INTR => {}, // spurious wake"},
{"lineNum":"  433","line":"            .INVAL => unreachable, // invalid timeout"},
{"lineNum":"  434","line":"            else => unreachable,"},
{"lineNum":"  435","line":"        }"},
{"lineNum":"  436","line":"    }"},
{"lineNum":"  437","line":""},
{"lineNum":"  438","line":"    fn wake(ptr: *const Atomic(u32), max_waiters: u32) void {"},
{"lineNum":"  439","line":"        // A count of zero means wake all waiters."},
{"lineNum":"  440","line":"        assert(max_waiters != 0);"},
{"lineNum":"  441","line":"        const to_wake = std.math.cast(c_int, max_waiters) orelse 0;"},
{"lineNum":"  442","line":""},
{"lineNum":"  443","line":"        // https://man.dragonflybsd.org/?command=umtx&section=2"},
{"lineNum":"  444","line":"        // > umtx_wakeup() will generally return 0 unless the address is bad."},
{"lineNum":"  445","line":"        // We are fine with the address being bad (e.g. for Semaphore.post() where Semaphore.wait() frees the Semaphore)"},
{"lineNum":"  446","line":"        const addr = @as(*const volatile c_int, @ptrCast(&ptr.value));"},
{"lineNum":"  447","line":"        _ = os.dragonfly.umtx_wakeup(addr, to_wake);"},
{"lineNum":"  448","line":"    }"},
{"lineNum":"  449","line":"};"},
{"lineNum":"  450","line":""},
{"lineNum":"  451","line":"const WasmImpl = struct {"},
{"lineNum":"  452","line":"    fn wait(ptr: *const Atomic(u32), expect: u32, timeout: ?u64) error{Timeout}!void {"},
{"lineNum":"  453","line":"        if (!comptime std.Target.wasm.featureSetHas(builtin.target.cpu.features, .atomics)) {"},
{"lineNum":"  454","line":"            @compileError(\"WASI target missing cpu feature \'atomics\'\");"},
{"lineNum":"  455","line":"        }"},
{"lineNum":"  456","line":"        const to: i64 = if (timeout) |to| @intCast(to) else -1;"},
{"lineNum":"  457","line":"        const result = asm ("},
{"lineNum":"  458","line":"            \\\\local.get %[ptr]"},
{"lineNum":"  459","line":"            \\\\local.get %[expected]"},
{"lineNum":"  460","line":"            \\\\local.get %[timeout]"},
{"lineNum":"  461","line":"            \\\\memory.atomic.wait32 0"},
{"lineNum":"  462","line":"            \\\\local.set %[ret]"},
{"lineNum":"  463","line":"            : [ret] \"=r\" (-> u32),"},
{"lineNum":"  464","line":"            : [ptr] \"r\" (&ptr.value),"},
{"lineNum":"  465","line":"              [expected] \"r\" (@as(i32, @bitCast(expect))),"},
{"lineNum":"  466","line":"              [timeout] \"r\" (to),"},
{"lineNum":"  467","line":"        );"},
{"lineNum":"  468","line":"        switch (result) {"},
{"lineNum":"  469","line":"            0 => {}, // ok"},
{"lineNum":"  470","line":"            1 => {}, // expected =! loaded"},
{"lineNum":"  471","line":"            2 => return error.Timeout,"},
{"lineNum":"  472","line":"            else => unreachable,"},
{"lineNum":"  473","line":"        }"},
{"lineNum":"  474","line":"    }"},
{"lineNum":"  475","line":""},
{"lineNum":"  476","line":"    fn wake(ptr: *const Atomic(u32), max_waiters: u32) void {"},
{"lineNum":"  477","line":"        if (!comptime std.Target.wasm.featureSetHas(builtin.target.cpu.features, .atomics)) {"},
{"lineNum":"  478","line":"            @compileError(\"WASI target missing cpu feature \'atomics\'\");"},
{"lineNum":"  479","line":"        }"},
{"lineNum":"  480","line":"        assert(max_waiters != 0);"},
{"lineNum":"  481","line":"        const woken_count = asm ("},
{"lineNum":"  482","line":"            \\\\local.get %[ptr]"},
{"lineNum":"  483","line":"            \\\\local.get %[waiters]"},
{"lineNum":"  484","line":"            \\\\memory.atomic.notify 0"},
{"lineNum":"  485","line":"            \\\\local.set %[ret]"},
{"lineNum":"  486","line":"            : [ret] \"=r\" (-> u32),"},
{"lineNum":"  487","line":"            : [ptr] \"r\" (&ptr.value),"},
{"lineNum":"  488","line":"              [waiters] \"r\" (max_waiters),"},
{"lineNum":"  489","line":"        );"},
{"lineNum":"  490","line":"        _ = woken_count; // can be 0 when linker flag \'shared-memory\' is not enabled"},
{"lineNum":"  491","line":"    }"},
{"lineNum":"  492","line":"};"},
{"lineNum":"  493","line":""},
{"lineNum":"  494","line":"/// Modified version of linux\'s futex and Go\'s sema to implement userspace wait queues with pthread:"},
{"lineNum":"  495","line":"/// https://code.woboq.org/linux/linux/kernel/futex.c.html"},
{"lineNum":"  496","line":"/// https://go.dev/src/runtime/sema.go"},
{"lineNum":"  497","line":"const PosixImpl = struct {"},
{"lineNum":"  498","line":"    const Event = struct {"},
{"lineNum":"  499","line":"        cond: std.c.pthread_cond_t,"},
{"lineNum":"  500","line":"        mutex: std.c.pthread_mutex_t,"},
{"lineNum":"  501","line":"        state: enum { empty, waiting, notified },"},
{"lineNum":"  502","line":""},
{"lineNum":"  503","line":"        fn init(self: *Event) void {"},
{"lineNum":"  504","line":"            // Use static init instead of pthread_cond/mutex_init() since this is generally faster."},
{"lineNum":"  505","line":"            self.cond = .{};"},
{"lineNum":"  506","line":"            self.mutex = .{};"},
{"lineNum":"  507","line":"            self.state = .empty;"},
{"lineNum":"  508","line":"        }"},
{"lineNum":"  509","line":""},
{"lineNum":"  510","line":"        fn deinit(self: *Event) void {"},
{"lineNum":"  511","line":"            // Some platforms reportedly give EINVAL for statically initialized pthread types."},
{"lineNum":"  512","line":"            const rc = std.c.pthread_cond_destroy(&self.cond);"},
{"lineNum":"  513","line":"            assert(rc == .SUCCESS or rc == .INVAL);"},
{"lineNum":"  514","line":""},
{"lineNum":"  515","line":"            const rm = std.c.pthread_mutex_destroy(&self.mutex);"},
{"lineNum":"  516","line":"            assert(rm == .SUCCESS or rm == .INVAL);"},
{"lineNum":"  517","line":""},
{"lineNum":"  518","line":"            self.* = undefined;"},
{"lineNum":"  519","line":"        }"},
{"lineNum":"  520","line":""},
{"lineNum":"  521","line":"        fn wait(self: *Event, timeout: ?u64) error{Timeout}!void {"},
{"lineNum":"  522","line":"            assert(std.c.pthread_mutex_lock(&self.mutex) == .SUCCESS);"},
{"lineNum":"  523","line":"            defer assert(std.c.pthread_mutex_unlock(&self.mutex) == .SUCCESS);"},
{"lineNum":"  524","line":""},
{"lineNum":"  525","line":"            // Early return if the event was already set."},
{"lineNum":"  526","line":"            if (self.state == .notified) {"},
{"lineNum":"  527","line":"                return;"},
{"lineNum":"  528","line":"            }"},
{"lineNum":"  529","line":""},
{"lineNum":"  530","line":"            // Compute the absolute timeout if one was specified."},
{"lineNum":"  531","line":"            // POSIX requires that REALTIME is used by default for the pthread timedwait functions."},
{"lineNum":"  532","line":"            // This can be changed with pthread_condattr_setclock, but it\'s an extension and may not be available everywhere."},
{"lineNum":"  533","line":"            var ts: os.timespec = undefined;"},
{"lineNum":"  534","line":"            if (timeout) |timeout_ns| {"},
{"lineNum":"  535","line":"                os.clock_gettime(os.CLOCK.REALTIME, &ts) catch unreachable;"},
{"lineNum":"  536","line":"                ts.tv_sec +|= @as(@TypeOf(ts.tv_sec), @intCast(timeout_ns / std.time.ns_per_s));"},
{"lineNum":"  537","line":"                ts.tv_nsec += @as(@TypeOf(ts.tv_nsec), @intCast(timeout_ns % std.time.ns_per_s));"},
{"lineNum":"  538","line":""},
{"lineNum":"  539","line":"                if (ts.tv_nsec >= std.time.ns_per_s) {"},
{"lineNum":"  540","line":"                    ts.tv_sec +|= 1;"},
{"lineNum":"  541","line":"                    ts.tv_nsec -= std.time.ns_per_s;"},
{"lineNum":"  542","line":"                }"},
{"lineNum":"  543","line":"            }"},
{"lineNum":"  544","line":""},
{"lineNum":"  545","line":"            // Start waiting on the event - there can be only one thread waiting."},
{"lineNum":"  546","line":"            assert(self.state == .empty);"},
{"lineNum":"  547","line":"            self.state = .waiting;"},
{"lineNum":"  548","line":""},
{"lineNum":"  549","line":"            while (true) {"},
{"lineNum":"  550","line":"                // Block using either pthread_cond_wait or pthread_cond_timewait if there\'s an absolute timeout."},
{"lineNum":"  551","line":"                const rc = blk: {"},
{"lineNum":"  552","line":"                    if (timeout == null) break :blk std.c.pthread_cond_wait(&self.cond, &self.mutex);"},
{"lineNum":"  553","line":"                    break :blk std.c.pthread_cond_timedwait(&self.cond, &self.mutex, &ts);"},
{"lineNum":"  554","line":"                };"},
{"lineNum":"  555","line":""},
{"lineNum":"  556","line":"                // After waking up, check if the event was set."},
{"lineNum":"  557","line":"                if (self.state == .notified) {"},
{"lineNum":"  558","line":"                    return;"},
{"lineNum":"  559","line":"                }"},
{"lineNum":"  560","line":""},
{"lineNum":"  561","line":"                assert(self.state == .waiting);"},
{"lineNum":"  562","line":"                switch (rc) {"},
{"lineNum":"  563","line":"                    .SUCCESS => {},"},
{"lineNum":"  564","line":"                    .TIMEDOUT => {"},
{"lineNum":"  565","line":"                        // If timed out, reset the event to avoid the set() thread doing an unnecessary signal()."},
{"lineNum":"  566","line":"                        self.state = .empty;"},
{"lineNum":"  567","line":"                        return error.Timeout;"},
{"lineNum":"  568","line":"                    },"},
{"lineNum":"  569","line":"                    .INVAL => unreachable, // cond, mutex, and potentially ts should all be valid"},
{"lineNum":"  570","line":"                    .PERM => unreachable, // mutex is locked when cond_*wait() functions are called"},
{"lineNum":"  571","line":"                    else => unreachable,"},
{"lineNum":"  572","line":"                }"},
{"lineNum":"  573","line":"            }"},
{"lineNum":"  574","line":"        }"},
{"lineNum":"  575","line":""},
{"lineNum":"  576","line":"        fn set(self: *Event) void {"},
{"lineNum":"  577","line":"            assert(std.c.pthread_mutex_lock(&self.mutex) == .SUCCESS);"},
{"lineNum":"  578","line":"            defer assert(std.c.pthread_mutex_unlock(&self.mutex) == .SUCCESS);"},
{"lineNum":"  579","line":""},
{"lineNum":"  580","line":"            // Make sure that multiple calls to set() were not done on the same Event."},
{"lineNum":"  581","line":"            const old_state = self.state;"},
{"lineNum":"  582","line":"            assert(old_state != .notified);"},
{"lineNum":"  583","line":""},
{"lineNum":"  584","line":"            // Mark the event as set and wake up the waiting thread if there was one."},
{"lineNum":"  585","line":"            // This must be done while the mutex as the wait() thread could deallocate"},
{"lineNum":"  586","line":"            // the condition variable once it observes the new state, potentially causing a UAF if done unlocked."},
{"lineNum":"  587","line":"            self.state = .notified;"},
{"lineNum":"  588","line":"            if (old_state == .waiting) {"},
{"lineNum":"  589","line":"                assert(std.c.pthread_cond_signal(&self.cond) == .SUCCESS);"},
{"lineNum":"  590","line":"            }"},
{"lineNum":"  591","line":"        }"},
{"lineNum":"  592","line":"    };"},
{"lineNum":"  593","line":""},
{"lineNum":"  594","line":"    const Treap = std.Treap(usize, std.math.order);"},
{"lineNum":"  595","line":"    const Waiter = struct {"},
{"lineNum":"  596","line":"        node: Treap.Node,"},
{"lineNum":"  597","line":"        prev: ?*Waiter,"},
{"lineNum":"  598","line":"        next: ?*Waiter,"},
{"lineNum":"  599","line":"        tail: ?*Waiter,"},
{"lineNum":"  600","line":"        is_queued: bool,"},
{"lineNum":"  601","line":"        event: Event,"},
{"lineNum":"  602","line":"    };"},
{"lineNum":"  603","line":""},
{"lineNum":"  604","line":"    // An unordered set of Waiters"},
{"lineNum":"  605","line":"    const WaitList = struct {"},
{"lineNum":"  606","line":"        top: ?*Waiter = null,"},
{"lineNum":"  607","line":"        len: usize = 0,"},
{"lineNum":"  608","line":""},
{"lineNum":"  609","line":"        fn push(self: *WaitList, waiter: *Waiter) void {"},
{"lineNum":"  610","line":"            waiter.next = self.top;"},
{"lineNum":"  611","line":"            self.top = waiter;"},
{"lineNum":"  612","line":"            self.len += 1;"},
{"lineNum":"  613","line":"        }"},
{"lineNum":"  614","line":""},
{"lineNum":"  615","line":"        fn pop(self: *WaitList) ?*Waiter {"},
{"lineNum":"  616","line":"            const waiter = self.top orelse return null;"},
{"lineNum":"  617","line":"            self.top = waiter.next;"},
{"lineNum":"  618","line":"            self.len -= 1;"},
{"lineNum":"  619","line":"            return waiter;"},
{"lineNum":"  620","line":"        }"},
{"lineNum":"  621","line":"    };"},
{"lineNum":"  622","line":""},
{"lineNum":"  623","line":"    const WaitQueue = struct {"},
{"lineNum":"  624","line":"        fn insert(treap: *Treap, address: usize, waiter: *Waiter) void {"},
{"lineNum":"  625","line":"            // prepare the waiter to be inserted."},
{"lineNum":"  626","line":"            waiter.next = null;"},
{"lineNum":"  627","line":"            waiter.is_queued = true;"},
{"lineNum":"  628","line":""},
{"lineNum":"  629","line":"            // Find the wait queue entry associated with the address."},
{"lineNum":"  630","line":"            // If there isn\'t a wait queue on the address, this waiter creates the queue."},
{"lineNum":"  631","line":"            var entry = treap.getEntryFor(address);"},
{"lineNum":"  632","line":"            const entry_node = entry.node orelse {"},
{"lineNum":"  633","line":"                waiter.prev = null;"},
{"lineNum":"  634","line":"                waiter.tail = waiter;"},
{"lineNum":"  635","line":"                entry.set(&waiter.node);"},
{"lineNum":"  636","line":"                return;"},
{"lineNum":"  637","line":"            };"},
{"lineNum":"  638","line":""},
{"lineNum":"  639","line":"            // There\'s a wait queue on the address; get the queue head and tail."},
{"lineNum":"  640","line":"            const head = @fieldParentPtr(Waiter, \"node\", entry_node);"},
{"lineNum":"  641","line":"            const tail = head.tail orelse unreachable;"},
{"lineNum":"  642","line":""},
{"lineNum":"  643","line":"            // Push the waiter to the tail by replacing it and linking to the previous tail."},
{"lineNum":"  644","line":"            head.tail = waiter;"},
{"lineNum":"  645","line":"            tail.next = waiter;"},
{"lineNum":"  646","line":"            waiter.prev = tail;"},
{"lineNum":"  647","line":"        }"},
{"lineNum":"  648","line":""},
{"lineNum":"  649","line":"        fn remove(treap: *Treap, address: usize, max_waiters: usize) WaitList {"},
{"lineNum":"  650","line":"            // Find the wait queue associated with this address and get the head/tail if any."},
{"lineNum":"  651","line":"            var entry = treap.getEntryFor(address);"},
{"lineNum":"  652","line":"            var queue_head = if (entry.node) |node| @fieldParentPtr(Waiter, \"node\", node) else null;"},
{"lineNum":"  653","line":"            const queue_tail = if (queue_head) |head| head.tail else null;"},
{"lineNum":"  654","line":""},
{"lineNum":"  655","line":"            // Once we\'re done updating the head, fix it\'s tail pointer and update the treap\'s queue head as well."},
{"lineNum":"  656","line":"            defer entry.set(blk: {"},
{"lineNum":"  657","line":"                const new_head = queue_head orelse break :blk null;"},
{"lineNum":"  658","line":"                new_head.tail = queue_tail;"},
{"lineNum":"  659","line":"                break :blk &new_head.node;"},
{"lineNum":"  660","line":"            });"},
{"lineNum":"  661","line":""},
{"lineNum":"  662","line":"            var removed = WaitList{};"},
{"lineNum":"  663","line":"            while (removed.len < max_waiters) {"},
{"lineNum":"  664","line":"                // dequeue and collect waiters from their wait queue."},
{"lineNum":"  665","line":"                const waiter = queue_head orelse break;"},
{"lineNum":"  666","line":"                queue_head = waiter.next;"},
{"lineNum":"  667","line":"                removed.push(waiter);"},
{"lineNum":"  668","line":""},
{"lineNum":"  669","line":"                // When dequeueing, we must mark is_queued as false."},
{"lineNum":"  670","line":"                // This ensures that a waiter which calls tryRemove() returns false."},
{"lineNum":"  671","line":"                assert(waiter.is_queued);"},
{"lineNum":"  672","line":"                waiter.is_queued = false;"},
{"lineNum":"  673","line":"            }"},
{"lineNum":"  674","line":""},
{"lineNum":"  675","line":"            return removed;"},
{"lineNum":"  676","line":"        }"},
{"lineNum":"  677","line":""},
{"lineNum":"  678","line":"        fn tryRemove(treap: *Treap, address: usize, waiter: *Waiter) bool {"},
{"lineNum":"  679","line":"            if (!waiter.is_queued) {"},
{"lineNum":"  680","line":"                return false;"},
{"lineNum":"  681","line":"            }"},
{"lineNum":"  682","line":""},
{"lineNum":"  683","line":"            queue_remove: {"},
{"lineNum":"  684","line":"                // Find the wait queue associated with the address."},
{"lineNum":"  685","line":"                var entry = blk: {"},
{"lineNum":"  686","line":"                    // A waiter without a previous link means it\'s the queue head that\'s in the treap so we can avoid lookup."},
{"lineNum":"  687","line":"                    if (waiter.prev == null) {"},
{"lineNum":"  688","line":"                        assert(waiter.node.key == address);"},
{"lineNum":"  689","line":"                        break :blk treap.getEntryForExisting(&waiter.node);"},
{"lineNum":"  690","line":"                    }"},
{"lineNum":"  691","line":"                    break :blk treap.getEntryFor(address);"},
{"lineNum":"  692","line":"                };"},
{"lineNum":"  693","line":""},
{"lineNum":"  694","line":"                // The queue head and tail must exist if we\'re removing a queued waiter."},
{"lineNum":"  695","line":"                const head = @fieldParentPtr(Waiter, \"node\", entry.node orelse unreachable);"},
{"lineNum":"  696","line":"                const tail = head.tail orelse unreachable;"},
{"lineNum":"  697","line":""},
{"lineNum":"  698","line":"                // A waiter with a previous link is never the head of the queue."},
{"lineNum":"  699","line":"                if (waiter.prev) |prev| {"},
{"lineNum":"  700","line":"                    assert(waiter != head);"},
{"lineNum":"  701","line":"                    prev.next = waiter.next;"},
{"lineNum":"  702","line":""},
{"lineNum":"  703","line":"                    // A waiter with both a previous and next link is in the middle."},
{"lineNum":"  704","line":"                    // We only need to update the surrounding waiter\'s links to remove it."},
{"lineNum":"  705","line":"                    if (waiter.next) |next| {"},
{"lineNum":"  706","line":"                        assert(waiter != tail);"},
{"lineNum":"  707","line":"                        next.prev = waiter.prev;"},
{"lineNum":"  708","line":"                        break :queue_remove;"},
{"lineNum":"  709","line":"                    }"},
{"lineNum":"  710","line":""},
{"lineNum":"  711","line":"                    // A waiter with a previous but no next link means it\'s the tail of the queue."},
{"lineNum":"  712","line":"                    // In that case, we need to update the head\'s tail reference."},
{"lineNum":"  713","line":"                    assert(waiter == tail);"},
{"lineNum":"  714","line":"                    head.tail = waiter.prev;"},
{"lineNum":"  715","line":"                    break :queue_remove;"},
{"lineNum":"  716","line":"                }"},
{"lineNum":"  717","line":""},
{"lineNum":"  718","line":"                // A waiter with no previous link means it\'s the queue head of queue."},
{"lineNum":"  719","line":"                // We must replace (or remove) the head waiter reference in the treap."},
{"lineNum":"  720","line":"                assert(waiter == head);"},
{"lineNum":"  721","line":"                entry.set(blk: {"},
{"lineNum":"  722","line":"                    const new_head = waiter.next orelse break :blk null;"},
{"lineNum":"  723","line":"                    new_head.tail = head.tail;"},
{"lineNum":"  724","line":"                    break :blk &new_head.node;"},
{"lineNum":"  725","line":"                });"},
{"lineNum":"  726","line":"            }"},
{"lineNum":"  727","line":""},
{"lineNum":"  728","line":"            // Mark the waiter as successfully removed."},
{"lineNum":"  729","line":"            waiter.is_queued = false;"},
{"lineNum":"  730","line":"            return true;"},
{"lineNum":"  731","line":"        }"},
{"lineNum":"  732","line":"    };"},
{"lineNum":"  733","line":""},
{"lineNum":"  734","line":"    const Bucket = struct {"},
{"lineNum":"  735","line":"        mutex: std.c.pthread_mutex_t align(std.atomic.cache_line) = .{},"},
{"lineNum":"  736","line":"        pending: Atomic(usize) = Atomic(usize).init(0),"},
{"lineNum":"  737","line":"        treap: Treap = .{},"},
{"lineNum":"  738","line":""},
{"lineNum":"  739","line":"        // Global array of buckets that addresses map to."},
{"lineNum":"  740","line":"        // Bucket array size is pretty much arbitrary here, but it must be a power of two for fibonacci hashing."},
{"lineNum":"  741","line":"        var buckets = [_]Bucket{.{}} ** @bitSizeOf(usize);"},
{"lineNum":"  742","line":""},
{"lineNum":"  743","line":"        // https://github.com/Amanieu/parking_lot/blob/1cf12744d097233316afa6c8b7d37389e4211756/core/src/parking_lot.rs#L343-L353"},
{"lineNum":"  744","line":"        fn from(address: usize) *Bucket {"},
{"lineNum":"  745","line":"            // The upper `@bitSizeOf(usize)` bits of the fibonacci golden ratio."},
{"lineNum":"  746","line":"            // Hashing this via (h * k) >> (64 - b) where k=golden-ration and b=bitsize-of-array"},
{"lineNum":"  747","line":"            // evenly lays out h=hash values over the bit range even when the hash has poor entropy (identity-hash for pointers)."},
{"lineNum":"  748","line":"            const max_multiplier_bits = @bitSizeOf(usize);"},
{"lineNum":"  749","line":"            const fibonacci_multiplier = 0x9E3779B97F4A7C15 >> (64 - max_multiplier_bits);"},
{"lineNum":"  750","line":""},
{"lineNum":"  751","line":"            const max_bucket_bits = @ctz(buckets.len);"},
{"lineNum":"  752","line":"            comptime assert(std.math.isPowerOfTwo(buckets.len));"},
{"lineNum":"  753","line":""},
{"lineNum":"  754","line":"            const index = (address *% fibonacci_multiplier) >> (max_multiplier_bits - max_bucket_bits);"},
{"lineNum":"  755","line":"            return &buckets[index];"},
{"lineNum":"  756","line":"        }"},
{"lineNum":"  757","line":"    };"},
{"lineNum":"  758","line":""},
{"lineNum":"  759","line":"    const Address = struct {"},
{"lineNum":"  760","line":"        fn from(ptr: *const Atomic(u32)) usize {"},
{"lineNum":"  761","line":"            // Get the alignment of the pointer."},
{"lineNum":"  762","line":"            const alignment = @alignOf(Atomic(u32));"},
{"lineNum":"  763","line":"            comptime assert(std.math.isPowerOfTwo(alignment));"},
{"lineNum":"  764","line":""},
{"lineNum":"  765","line":"            // Make sure the pointer is aligned,"},
{"lineNum":"  766","line":"            // then cut off the zero bits from the alignment to get the unique address."},
{"lineNum":"  767","line":"            const addr = @intFromPtr(ptr);"},
{"lineNum":"  768","line":"            assert(addr & (alignment - 1) == 0);"},
{"lineNum":"  769","line":"            return addr >> @ctz(@as(usize, alignment));"},
{"lineNum":"  770","line":"        }"},
{"lineNum":"  771","line":"    };"},
{"lineNum":"  772","line":""},
{"lineNum":"  773","line":"    fn wait(ptr: *const Atomic(u32), expect: u32, timeout: ?u64) error{Timeout}!void {"},
{"lineNum":"  774","line":"        const address = Address.from(ptr);"},
{"lineNum":"  775","line":"        const bucket = Bucket.from(address);"},
{"lineNum":"  776","line":""},
{"lineNum":"  777","line":"        // Announce that there\'s a waiter in the bucket before checking the ptr/expect condition."},
{"lineNum":"  778","line":"        // If the announcement is reordered after the ptr check, the waiter could deadlock:"},
{"lineNum":"  779","line":"        //"},
{"lineNum":"  780","line":"        // - T1: checks ptr == expect which is true"},
{"lineNum":"  781","line":"        // - T2: updates ptr to != expect"},
{"lineNum":"  782","line":"        // - T2: does Futex.wake(), sees no pending waiters, exits"},
{"lineNum":"  783","line":"        // - T1: bumps pending waiters (was reordered after the ptr == expect check)"},
{"lineNum":"  784","line":"        // - T1: goes to sleep and misses both the ptr change and T2\'s wake up"},
{"lineNum":"  785","line":"        //"},
{"lineNum":"  786","line":"        // SeqCst as Acquire barrier to ensure the announcement happens before the ptr check below."},
{"lineNum":"  787","line":"        // SeqCst as shared modification order to form a happens-before edge with the fence(.SeqCst)+load() in wake()."},
{"lineNum":"  788","line":"        var pending = bucket.pending.fetchAdd(1, .SeqCst);"},
{"lineNum":"  789","line":"        assert(pending < std.math.maxInt(usize));"},
{"lineNum":"  790","line":""},
{"lineNum":"  791","line":"        // If the wait gets cancelled, remove the pending count we previously added."},
{"lineNum":"  792","line":"        // This is done outside the mutex lock to keep the critical section short in case of contention."},
{"lineNum":"  793","line":"        var cancelled = false;"},
{"lineNum":"  794","line":"        defer if (cancelled) {"},
{"lineNum":"  795","line":"            pending = bucket.pending.fetchSub(1, .Monotonic);"},
{"lineNum":"  796","line":"            assert(pending > 0);"},
{"lineNum":"  797","line":"        };"},
{"lineNum":"  798","line":""},
{"lineNum":"  799","line":"        var waiter: Waiter = undefined;"},
{"lineNum":"  800","line":"        {"},
{"lineNum":"  801","line":"            assert(std.c.pthread_mutex_lock(&bucket.mutex) == .SUCCESS);"},
{"lineNum":"  802","line":"            defer assert(std.c.pthread_mutex_unlock(&bucket.mutex) == .SUCCESS);"},
{"lineNum":"  803","line":""},
{"lineNum":"  804","line":"            cancelled = ptr.load(.Monotonic) != expect;"},
{"lineNum":"  805","line":"            if (cancelled) {"},
{"lineNum":"  806","line":"                return;"},
{"lineNum":"  807","line":"            }"},
{"lineNum":"  808","line":""},
{"lineNum":"  809","line":"            waiter.event.init();"},
{"lineNum":"  810","line":"            WaitQueue.insert(&bucket.treap, address, &waiter);"},
{"lineNum":"  811","line":"        }"},
{"lineNum":"  812","line":""},
{"lineNum":"  813","line":"        defer {"},
{"lineNum":"  814","line":"            assert(!waiter.is_queued);"},
{"lineNum":"  815","line":"            waiter.event.deinit();"},
{"lineNum":"  816","line":"        }"},
{"lineNum":"  817","line":""},
{"lineNum":"  818","line":"        waiter.event.wait(timeout) catch {"},
{"lineNum":"  819","line":"            // If we fail to cancel after a timeout, it means a wake() thread dequeued us and will wake us up."},
{"lineNum":"  820","line":"            // We must wait until the event is set as that\'s a signal that the wake() thread won\'t access the waiter memory anymore."},
{"lineNum":"  821","line":"            // If we return early without waiting, the waiter on the stack would be invalidated and the wake() thread risks a UAF."},
{"lineNum":"  822","line":"            defer if (!cancelled) waiter.event.wait(null) catch unreachable;"},
{"lineNum":"  823","line":""},
{"lineNum":"  824","line":"            assert(std.c.pthread_mutex_lock(&bucket.mutex) == .SUCCESS);"},
{"lineNum":"  825","line":"            defer assert(std.c.pthread_mutex_unlock(&bucket.mutex) == .SUCCESS);"},
{"lineNum":"  826","line":""},
{"lineNum":"  827","line":"            cancelled = WaitQueue.tryRemove(&bucket.treap, address, &waiter);"},
{"lineNum":"  828","line":"            if (cancelled) {"},
{"lineNum":"  829","line":"                return error.Timeout;"},
{"lineNum":"  830","line":"            }"},
{"lineNum":"  831","line":"        };"},
{"lineNum":"  832","line":"    }"},
{"lineNum":"  833","line":""},
{"lineNum":"  834","line":"    fn wake(ptr: *const Atomic(u32), max_waiters: u32) void {"},
{"lineNum":"  835","line":"        const address = Address.from(ptr);"},
{"lineNum":"  836","line":"        const bucket = Bucket.from(address);"},
{"lineNum":"  837","line":""},
{"lineNum":"  838","line":"        // Quick check if there\'s even anything to wake up."},
{"lineNum":"  839","line":"        // The change to the ptr\'s value must happen before we check for pending waiters."},
{"lineNum":"  840","line":"        // If not, the wake() thread could miss a sleeping waiter and have it deadlock:"},
{"lineNum":"  841","line":"        //"},
{"lineNum":"  842","line":"        // - T2: p = has pending waiters (reordered before the ptr update)"},
{"lineNum":"  843","line":"        // - T1: bump pending waiters"},
{"lineNum":"  844","line":"        // - T1: if ptr == expected: sleep()"},
{"lineNum":"  845","line":"        // - T2: update ptr != expected"},
{"lineNum":"  846","line":"        // - T2: p is false from earlier so doesn\'t wake (T1 missed ptr update and T2 missed T1 sleeping)"},
{"lineNum":"  847","line":"        //"},
{"lineNum":"  848","line":"        // What we really want here is a Release load, but that doesn\'t exist under the C11 memory model."},
{"lineNum":"  849","line":"        // We could instead do `bucket.pending.fetchAdd(0, Release) == 0` which achieves effectively the same thing,"},
{"lineNum":"  850","line":"        // but the RMW operation unconditionally marks the cache-line as modified for others causing unnecessary fetching/contention."},
{"lineNum":"  851","line":"        //"},
{"lineNum":"  852","line":"        // Instead we opt to do a full-fence + load instead which avoids taking ownership of the cache-line."},
{"lineNum":"  853","line":"        // fence(SeqCst) effectively converts the ptr update to SeqCst and the pending load to SeqCst: creating a Store-Load barrier."},
{"lineNum":"  854","line":"        //"},
{"lineNum":"  855","line":"        // The pending count increment in wait() must also now use SeqCst for the update + this pending load"},
{"lineNum":"  856","line":"        // to be in the same modification order as our load isn\'t using Release/Acquire to guarantee it."},
{"lineNum":"  857","line":"        bucket.pending.fence(.SeqCst);"},
{"lineNum":"  858","line":"        if (bucket.pending.load(.Monotonic) == 0) {"},
{"lineNum":"  859","line":"            return;"},
{"lineNum":"  860","line":"        }"},
{"lineNum":"  861","line":""},
{"lineNum":"  862","line":"        // Keep a list of all the waiters notified and wake then up outside the mutex critical section."},
{"lineNum":"  863","line":"        var notified = WaitList{};"},
{"lineNum":"  864","line":"        defer if (notified.len > 0) {"},
{"lineNum":"  865","line":"            const pending = bucket.pending.fetchSub(notified.len, .Monotonic);"},
{"lineNum":"  866","line":"            assert(pending >= notified.len);"},
{"lineNum":"  867","line":""},
{"lineNum":"  868","line":"            while (notified.pop()) |waiter| {"},
{"lineNum":"  869","line":"                assert(!waiter.is_queued);"},
{"lineNum":"  870","line":"                waiter.event.set();"},
{"lineNum":"  871","line":"            }"},
{"lineNum":"  872","line":"        };"},
{"lineNum":"  873","line":""},
{"lineNum":"  874","line":"        assert(std.c.pthread_mutex_lock(&bucket.mutex) == .SUCCESS);"},
{"lineNum":"  875","line":"        defer assert(std.c.pthread_mutex_unlock(&bucket.mutex) == .SUCCESS);"},
{"lineNum":"  876","line":""},
{"lineNum":"  877","line":"        // Another pending check again to avoid the WaitQueue lookup if not necessary."},
{"lineNum":"  878","line":"        if (bucket.pending.load(.Monotonic) > 0) {"},
{"lineNum":"  879","line":"            notified = WaitQueue.remove(&bucket.treap, address, max_waiters);"},
{"lineNum":"  880","line":"        }"},
{"lineNum":"  881","line":"    }"},
{"lineNum":"  882","line":"};"},
{"lineNum":"  883","line":""},
{"lineNum":"  884","line":"test \"Futex - smoke test\" {"},
{"lineNum":"  885","line":"    var value = Atomic(u32).init(0);"},
{"lineNum":"  886","line":""},
{"lineNum":"  887","line":"    // Try waits with invalid values."},
{"lineNum":"  888","line":"    Futex.wait(&value, 0xdeadbeef);"},
{"lineNum":"  889","line":"    Futex.timedWait(&value, 0xdeadbeef, 0) catch {};"},
{"lineNum":"  890","line":""},
{"lineNum":"  891","line":"    // Try timeout waits."},
{"lineNum":"  892","line":"    try testing.expectError(error.Timeout, Futex.timedWait(&value, 0, 0));"},
{"lineNum":"  893","line":"    try testing.expectError(error.Timeout, Futex.timedWait(&value, 0, std.time.ns_per_ms));"},
{"lineNum":"  894","line":""},
{"lineNum":"  895","line":"    // Try wakes"},
{"lineNum":"  896","line":"    Futex.wake(&value, 0);"},
{"lineNum":"  897","line":"    Futex.wake(&value, 1);"},
{"lineNum":"  898","line":"    Futex.wake(&value, std.math.maxInt(u32));"},
{"lineNum":"  899","line":"}"},
{"lineNum":"  900","line":""},
{"lineNum":"  901","line":"test \"Futex - signaling\" {"},
{"lineNum":"  902","line":"    // This test requires spawning threads"},
{"lineNum":"  903","line":"    if (builtin.single_threaded) {"},
{"lineNum":"  904","line":"        return error.SkipZigTest;"},
{"lineNum":"  905","line":"    }"},
{"lineNum":"  906","line":""},
{"lineNum":"  907","line":"    const num_threads = 4;"},
{"lineNum":"  908","line":"    const num_iterations = 4;"},
{"lineNum":"  909","line":""},
{"lineNum":"  910","line":"    const Paddle = struct {"},
{"lineNum":"  911","line":"        value: Atomic(u32) = Atomic(u32).init(0),"},
{"lineNum":"  912","line":"        current: u32 = 0,"},
{"lineNum":"  913","line":""},
{"lineNum":"  914","line":"        fn hit(self: *@This()) void {"},
{"lineNum":"  915","line":"            _ = self.value.fetchAdd(1, .Release);"},
{"lineNum":"  916","line":"            Futex.wake(&self.value, 1);"},
{"lineNum":"  917","line":"        }"},
{"lineNum":"  918","line":""},
{"lineNum":"  919","line":"        fn run(self: *@This(), hit_to: *@This()) !void {"},
{"lineNum":"  920","line":"            while (self.current < num_iterations) {"},
{"lineNum":"  921","line":"                // Wait for the value to change from hit()"},
{"lineNum":"  922","line":"                var new_value: u32 = undefined;"},
{"lineNum":"  923","line":"                while (true) {"},
{"lineNum":"  924","line":"                    new_value = self.value.load(.Acquire);"},
{"lineNum":"  925","line":"                    if (new_value != self.current) break;"},
{"lineNum":"  926","line":"                    Futex.wait(&self.value, self.current);"},
{"lineNum":"  927","line":"                }"},
{"lineNum":"  928","line":""},
{"lineNum":"  929","line":"                // change the internal \"current\" value"},
{"lineNum":"  930","line":"                try testing.expectEqual(new_value, self.current + 1);"},
{"lineNum":"  931","line":"                self.current = new_value;"},
{"lineNum":"  932","line":""},
{"lineNum":"  933","line":"                // hit the next paddle"},
{"lineNum":"  934","line":"                hit_to.hit();"},
{"lineNum":"  935","line":"            }"},
{"lineNum":"  936","line":"        }"},
{"lineNum":"  937","line":"    };"},
{"lineNum":"  938","line":""},
{"lineNum":"  939","line":"    var paddles = [_]Paddle{.{}} ** num_threads;"},
{"lineNum":"  940","line":"    var threads = [_]std.Thread{undefined} ** num_threads;"},
{"lineNum":"  941","line":""},
{"lineNum":"  942","line":"    // Create a circle of paddles which hit each other"},
{"lineNum":"  943","line":"    for (&threads, 0..) |*t, i| {"},
{"lineNum":"  944","line":"        const paddle = &paddles[i];"},
{"lineNum":"  945","line":"        const hit_to = &paddles[(i + 1) % paddles.len];"},
{"lineNum":"  946","line":"        t.* = try std.Thread.spawn(.{}, Paddle.run, .{ paddle, hit_to });"},
{"lineNum":"  947","line":"    }"},
{"lineNum":"  948","line":""},
{"lineNum":"  949","line":"    // Hit the first paddle and wait for them all to complete by hitting each other for num_iterations."},
{"lineNum":"  950","line":"    paddles[0].hit();"},
{"lineNum":"  951","line":"    for (threads) |t| t.join();"},
{"lineNum":"  952","line":"    for (paddles) |p| try testing.expectEqual(p.current, num_iterations);"},
{"lineNum":"  953","line":"}"},
{"lineNum":"  954","line":""},
{"lineNum":"  955","line":"test \"Futex - broadcasting\" {"},
{"lineNum":"  956","line":"    // This test requires spawning threads"},
{"lineNum":"  957","line":"    if (builtin.single_threaded) {"},
{"lineNum":"  958","line":"        return error.SkipZigTest;"},
{"lineNum":"  959","line":"    }"},
{"lineNum":"  960","line":""},
{"lineNum":"  961","line":"    const num_threads = 4;"},
{"lineNum":"  962","line":"    const num_iterations = 4;"},
{"lineNum":"  963","line":""},
{"lineNum":"  964","line":"    const Barrier = struct {"},
{"lineNum":"  965","line":"        count: Atomic(u32) = Atomic(u32).init(num_threads),"},
{"lineNum":"  966","line":"        futex: Atomic(u32) = Atomic(u32).init(0),"},
{"lineNum":"  967","line":""},
{"lineNum":"  968","line":"        fn wait(self: *@This()) !void {"},
{"lineNum":"  969","line":"            // Decrement the counter."},
{"lineNum":"  970","line":"            // Release ensures stuff before this barrier.wait() happens before the last one."},
{"lineNum":"  971","line":"            const count = self.count.fetchSub(1, .Release);"},
{"lineNum":"  972","line":"            try testing.expect(count <= num_threads);"},
{"lineNum":"  973","line":"            try testing.expect(count > 0);"},
{"lineNum":"  974","line":""},
{"lineNum":"  975","line":"            // First counter to reach zero wakes all other threads."},
{"lineNum":"  976","line":"            // Acquire for the last counter ensures stuff before previous barrier.wait()s happened before it."},
{"lineNum":"  977","line":"            // Release on futex update ensures stuff before all barrier.wait()\'s happens before they all return."},
{"lineNum":"  978","line":"            if (count - 1 == 0) {"},
{"lineNum":"  979","line":"                _ = self.count.load(.Acquire); // TODO: could be fence(Acquire) if not for TSAN"},
{"lineNum":"  980","line":"                self.futex.store(1, .Release);"},
{"lineNum":"  981","line":"                Futex.wake(&self.futex, num_threads - 1);"},
{"lineNum":"  982","line":"                return;"},
{"lineNum":"  983","line":"            }"},
{"lineNum":"  984","line":""},
{"lineNum":"  985","line":"            // Other threads wait until last counter wakes them up."},
{"lineNum":"  986","line":"            // Acquire on futex synchronizes with last barrier count to ensure stuff before all barrier.wait()\'s happen before us."},
{"lineNum":"  987","line":"            while (self.futex.load(.Acquire) == 0) {"},
{"lineNum":"  988","line":"                Futex.wait(&self.futex, 0);"},
{"lineNum":"  989","line":"            }"},
{"lineNum":"  990","line":"        }"},
{"lineNum":"  991","line":"    };"},
{"lineNum":"  992","line":""},
{"lineNum":"  993","line":"    const Broadcast = struct {"},
{"lineNum":"  994","line":"        barriers: [num_iterations]Barrier = [_]Barrier{.{}} ** num_iterations,"},
{"lineNum":"  995","line":"        threads: [num_threads]std.Thread = undefined,"},
{"lineNum":"  996","line":""},
{"lineNum":"  997","line":"        fn run(self: *@This()) !void {"},
{"lineNum":"  998","line":"            for (&self.barriers) |*barrier| {"},
{"lineNum":"  999","line":"                try barrier.wait();"},
{"lineNum":" 1000","line":"            }"},
{"lineNum":" 1001","line":"        }"},
{"lineNum":" 1002","line":"    };"},
{"lineNum":" 1003","line":""},
{"lineNum":" 1004","line":"    var broadcast = Broadcast{};"},
{"lineNum":" 1005","line":"    for (&broadcast.threads) |*t| t.* = try std.Thread.spawn(.{}, Broadcast.run, .{&broadcast});"},
{"lineNum":" 1006","line":"    for (broadcast.threads) |t| t.join();"},
{"lineNum":" 1007","line":"}"},
{"lineNum":" 1008","line":""},
{"lineNum":" 1009","line":"/// Deadline is used to wait efficiently for a pointer\'s value to change using Futex and a fixed timeout."},
{"lineNum":" 1010","line":"///"},
{"lineNum":" 1011","line":"/// Futex\'s timedWait() api uses a relative duration which suffers from over-waiting"},
{"lineNum":" 1012","line":"/// when used in a loop which is often required due to the possibility of spurious wakeups."},
{"lineNum":" 1013","line":"///"},
{"lineNum":" 1014","line":"/// Deadline instead converts the relative timeout to an absolute one so that multiple calls"},
{"lineNum":" 1015","line":"/// to Futex timedWait() can block for and report more accurate error.Timeouts."},
{"lineNum":" 1016","line":"pub const Deadline = struct {"},
{"lineNum":" 1017","line":"    timeout: ?u64,"},
{"lineNum":" 1018","line":"    started: std.time.Timer,"},
{"lineNum":" 1019","line":""},
{"lineNum":" 1020","line":"    /// Create the deadline to expire after the given amount of time in nanoseconds passes."},
{"lineNum":" 1021","line":"    /// Pass in `null` to have the deadline call `Futex.wait()` and never expire."},
{"lineNum":" 1022","line":"    pub fn init(expires_in_ns: ?u64) Deadline {"},
{"lineNum":" 1023","line":"        var deadline: Deadline = undefined;"},
{"lineNum":" 1024","line":"        deadline.timeout = expires_in_ns;"},
{"lineNum":" 1025","line":""},
{"lineNum":" 1026","line":"        // std.time.Timer is required to be supported for somewhat accurate reportings of error.Timeout."},
{"lineNum":" 1027","line":"        if (deadline.timeout != null) {"},
{"lineNum":" 1028","line":"            deadline.started = std.time.Timer.start() catch unreachable;"},
{"lineNum":" 1029","line":"        }"},
{"lineNum":" 1030","line":""},
{"lineNum":" 1031","line":"        return deadline;"},
{"lineNum":" 1032","line":"    }"},
{"lineNum":" 1033","line":""},
{"lineNum":" 1034","line":"    /// Wait until either:"},
{"lineNum":" 1035","line":"    /// - the `ptr`\'s value changes from `expect`."},
{"lineNum":" 1036","line":"    /// - `Futex.wake()` is called on the `ptr`."},
{"lineNum":" 1037","line":"    /// - A spurious wake occurs."},
{"lineNum":" 1038","line":"    /// - The deadline expires; In which case `error.Timeout` is returned."},
{"lineNum":" 1039","line":"    pub fn wait(self: *Deadline, ptr: *const Atomic(u32), expect: u32) error{Timeout}!void {"},
{"lineNum":" 1040","line":"        @setCold(true);"},
{"lineNum":" 1041","line":""},
{"lineNum":" 1042","line":"        // Check if we actually have a timeout to wait until."},
{"lineNum":" 1043","line":"        // If not just wait \"forever\"."},
{"lineNum":" 1044","line":"        const timeout_ns = self.timeout orelse {"},
{"lineNum":" 1045","line":"            return Futex.wait(ptr, expect);"},
{"lineNum":" 1046","line":"        };"},
{"lineNum":" 1047","line":""},
{"lineNum":" 1048","line":"        // Get how much time has passed since we started waiting"},
{"lineNum":" 1049","line":"        // then subtract that from the init() timeout to get how much longer to wait."},
{"lineNum":" 1050","line":"        // Use overflow to detect when we\'ve been waiting longer than the init() timeout."},
{"lineNum":" 1051","line":"        const elapsed_ns = self.started.read();"},
{"lineNum":" 1052","line":"        const until_timeout_ns = std.math.sub(u64, timeout_ns, elapsed_ns) catch 0;"},
{"lineNum":" 1053","line":"        return Futex.timedWait(ptr, expect, until_timeout_ns);"},
{"lineNum":" 1054","line":"    }"},
{"lineNum":" 1055","line":"};"},
{"lineNum":" 1056","line":""},
{"lineNum":" 1057","line":"test \"Futex - Deadline\" {"},
{"lineNum":" 1058","line":"    var deadline = Deadline.init(100 * std.time.ns_per_ms);"},
{"lineNum":" 1059","line":"    var futex_word = Atomic(u32).init(0);"},
{"lineNum":" 1060","line":""},
{"lineNum":" 1061","line":"    while (true) {"},
{"lineNum":" 1062","line":"        deadline.wait(&futex_word, 0) catch break;"},
{"lineNum":" 1063","line":"    }"},
{"lineNum":" 1064","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test", "date" : "2024-04-26 16:14:49", "instrumented" : 26, "covered" : 0,};
var merged_data = [];
