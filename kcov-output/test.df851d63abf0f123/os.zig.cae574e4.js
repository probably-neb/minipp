var data = {lines:[
{"lineNum":"    1","line":"//! This file contains thin wrappers around OS-specific APIs, with these"},
{"lineNum":"    2","line":"//! specific goals in mind:"},
{"lineNum":"    3","line":"//! * Convert \"errno\"-style error codes into Zig errors."},
{"lineNum":"    4","line":"//! * When null-terminated byte buffers are required, provide APIs which accept"},
{"lineNum":"    5","line":"//!   slices as well as APIs which accept null-terminated byte buffers. Same goes"},
{"lineNum":"    6","line":"//!   for UTF-16LE encoding."},
{"lineNum":"    7","line":"//! * Where operating systems share APIs, e.g. POSIX, these thin wrappers provide"},
{"lineNum":"    8","line":"//!   cross platform abstracting."},
{"lineNum":"    9","line":"//! * When there exists a corresponding libc function and linking libc, the libc"},
{"lineNum":"   10","line":"//!   implementation is used. Exceptions are made for known buggy areas of libc."},
{"lineNum":"   11","line":"//!   On Linux libc can be side-stepped by using `std.os.linux` directly."},
{"lineNum":"   12","line":"//! * For Windows, this file represents the API that libc would provide for"},
{"lineNum":"   13","line":"//!   Windows. For thin wrappers around Windows-specific APIs, see `std.os.windows`."},
{"lineNum":"   14","line":"//! Note: The Zig standard library does not support POSIX thread cancellation, and"},
{"lineNum":"   15","line":"//! in general EINTR is handled by trying again."},
{"lineNum":"   16","line":""},
{"lineNum":"   17","line":"const root = @import(\"root\");"},
{"lineNum":"   18","line":"const std = @import(\"std.zig\");"},
{"lineNum":"   19","line":"const builtin = @import(\"builtin\");"},
{"lineNum":"   20","line":"const assert = std.debug.assert;"},
{"lineNum":"   21","line":"const math = std.math;"},
{"lineNum":"   22","line":"const mem = std.mem;"},
{"lineNum":"   23","line":"const elf = std.elf;"},
{"lineNum":"   24","line":"const fs = std.fs;"},
{"lineNum":"   25","line":"const dl = @import(\"dynamic_library.zig\");"},
{"lineNum":"   26","line":"const MAX_PATH_BYTES = std.fs.MAX_PATH_BYTES;"},
{"lineNum":"   27","line":"const is_windows = builtin.os.tag == .windows;"},
{"lineNum":"   28","line":"const Allocator = std.mem.Allocator;"},
{"lineNum":"   29","line":"const Preopen = std.fs.wasi.Preopen;"},
{"lineNum":"   30","line":"const PreopenList = std.fs.wasi.PreopenList;"},
{"lineNum":"   31","line":""},
{"lineNum":"   32","line":"pub const darwin = std.c;"},
{"lineNum":"   33","line":"pub const dragonfly = std.c;"},
{"lineNum":"   34","line":"pub const freebsd = std.c;"},
{"lineNum":"   35","line":"pub const haiku = std.c;"},
{"lineNum":"   36","line":"pub const netbsd = std.c;"},
{"lineNum":"   37","line":"pub const openbsd = std.c;"},
{"lineNum":"   38","line":"pub const solaris = std.c;"},
{"lineNum":"   39","line":"pub const linux = @import(\"os/linux.zig\");"},
{"lineNum":"   40","line":"pub const plan9 = @import(\"os/plan9.zig\");"},
{"lineNum":"   41","line":"pub const uefi = @import(\"os/uefi.zig\");"},
{"lineNum":"   42","line":"pub const wasi = @import(\"os/wasi.zig\");"},
{"lineNum":"   43","line":"pub const windows = @import(\"os/windows.zig\");"},
{"lineNum":"   44","line":""},
{"lineNum":"   45","line":"comptime {"},
{"lineNum":"   46","line":"    assert(@import(\"std\") == std); // std lib tests require --zig-lib-dir"},
{"lineNum":"   47","line":"}"},
{"lineNum":"   48","line":""},
{"lineNum":"   49","line":"test {"},
{"lineNum":"   50","line":"    _ = darwin;"},
{"lineNum":"   51","line":"    _ = linux;"},
{"lineNum":"   52","line":"    if (builtin.os.tag == .uefi) {"},
{"lineNum":"   53","line":"        _ = uefi;"},
{"lineNum":"   54","line":"    }"},
{"lineNum":"   55","line":"    _ = wasi;"},
{"lineNum":"   56","line":"    _ = windows;"},
{"lineNum":"   57","line":""},
{"lineNum":"   58","line":"    _ = @import(\"os/test.zig\");"},
{"lineNum":"   59","line":"}"},
{"lineNum":"   60","line":""},
{"lineNum":"   61","line":"/// Applications can override the `system` API layer in their root source file."},
{"lineNum":"   62","line":"/// Otherwise, when linking libc, this is the C API."},
{"lineNum":"   63","line":"/// When not linking libc, it is the OS-specific system interface."},
{"lineNum":"   64","line":"pub const system = if (@hasDecl(root, \"os\") and root.os != @This())"},
{"lineNum":"   65","line":"    root.os.system"},
{"lineNum":"   66","line":"else if (builtin.link_libc or is_windows)"},
{"lineNum":"   67","line":"    std.c"},
{"lineNum":"   68","line":"else switch (builtin.os.tag) {"},
{"lineNum":"   69","line":"    .linux => linux,"},
{"lineNum":"   70","line":"    .plan9 => plan9,"},
{"lineNum":"   71","line":"    .wasi => wasi,"},
{"lineNum":"   72","line":"    .uefi => uefi,"},
{"lineNum":"   73","line":"    else => struct {},"},
{"lineNum":"   74","line":"};"},
{"lineNum":"   75","line":""},
{"lineNum":"   76","line":"pub const AF = system.AF;"},
{"lineNum":"   77","line":"pub const AF_SUN = system.AF_SUN;"},
{"lineNum":"   78","line":"pub const ARCH = system.ARCH;"},
{"lineNum":"   79","line":"pub const AT = system.AT;"},
{"lineNum":"   80","line":"pub const AT_SUN = system.AT_SUN;"},
{"lineNum":"   81","line":"pub const CLOCK = system.CLOCK;"},
{"lineNum":"   82","line":"pub const CPU_COUNT = system.CPU_COUNT;"},
{"lineNum":"   83","line":"pub const CTL = system.CTL;"},
{"lineNum":"   84","line":"pub const DT = system.DT;"},
{"lineNum":"   85","line":"pub const E = system.E;"},
{"lineNum":"   86","line":"pub const Elf_Symndx = system.Elf_Symndx;"},
{"lineNum":"   87","line":"pub const F = system.F;"},
{"lineNum":"   88","line":"pub const FD_CLOEXEC = system.FD_CLOEXEC;"},
{"lineNum":"   89","line":"pub const Flock = system.Flock;"},
{"lineNum":"   90","line":"pub const HOST_NAME_MAX = system.HOST_NAME_MAX;"},
{"lineNum":"   91","line":"pub const HW = switch (builtin.os.tag) {"},
{"lineNum":"   92","line":"    .openbsd => system.HW,"},
{"lineNum":"   93","line":"    else => .{},"},
{"lineNum":"   94","line":"};"},
{"lineNum":"   95","line":"pub const IFNAMESIZE = system.IFNAMESIZE;"},
{"lineNum":"   96","line":"pub const IOV_MAX = system.IOV_MAX;"},
{"lineNum":"   97","line":"pub const IPPROTO = system.IPPROTO;"},
{"lineNum":"   98","line":"pub const KERN = system.KERN;"},
{"lineNum":"   99","line":"pub const Kevent = system.Kevent;"},
{"lineNum":"  100","line":"pub const LOCK = system.LOCK;"},
{"lineNum":"  101","line":"pub const MADV = system.MADV;"},
{"lineNum":"  102","line":"pub const MAP = system.MAP;"},
{"lineNum":"  103","line":"pub const MSF = system.MSF;"},
{"lineNum":"  104","line":"pub const MAX_ADDR_LEN = system.MAX_ADDR_LEN;"},
{"lineNum":"  105","line":"pub const MFD = system.MFD;"},
{"lineNum":"  106","line":"pub const MMAP2_UNIT = system.MMAP2_UNIT;"},
{"lineNum":"  107","line":"pub const MSG = system.MSG;"},
{"lineNum":"  108","line":"pub const NAME_MAX = system.NAME_MAX;"},
{"lineNum":"  109","line":"pub const O = switch (builtin.os.tag) {"},
{"lineNum":"  110","line":"    // We want to expose the POSIX-like OFLAGS, so we use std.c.wasi.O instead"},
{"lineNum":"  111","line":"    // of std.os.wasi.O, which is for non-POSIX-like `wasi.path_open`, etc."},
{"lineNum":"  112","line":"    .wasi => std.c.O,"},
{"lineNum":"  113","line":"    else => system.O,"},
{"lineNum":"  114","line":"};"},
{"lineNum":"  115","line":"pub const PATH_MAX = system.PATH_MAX;"},
{"lineNum":"  116","line":"pub const POLL = system.POLL;"},
{"lineNum":"  117","line":"pub const POSIX_FADV = system.POSIX_FADV;"},
{"lineNum":"  118","line":"pub const PR = system.PR;"},
{"lineNum":"  119","line":"pub const PROT = system.PROT;"},
{"lineNum":"  120","line":"pub const REG = system.REG;"},
{"lineNum":"  121","line":"pub const RIGHT = system.RIGHT;"},
{"lineNum":"  122","line":"pub const RLIM = system.RLIM;"},
{"lineNum":"  123","line":"pub const RR = system.RR;"},
{"lineNum":"  124","line":"pub const S = system.S;"},
{"lineNum":"  125","line":"pub const SA = system.SA;"},
{"lineNum":"  126","line":"pub const SC = system.SC;"},
{"lineNum":"  127","line":"pub const _SC = system._SC;"},
{"lineNum":"  128","line":"pub const SEEK = system.SEEK;"},
{"lineNum":"  129","line":"pub const SHUT = system.SHUT;"},
{"lineNum":"  130","line":"pub const SIG = system.SIG;"},
{"lineNum":"  131","line":"pub const SIOCGIFINDEX = system.SIOCGIFINDEX;"},
{"lineNum":"  132","line":"pub const SO = system.SO;"},
{"lineNum":"  133","line":"pub const SOCK = system.SOCK;"},
{"lineNum":"  134","line":"pub const SOL = system.SOL;"},
{"lineNum":"  135","line":"pub const STDERR_FILENO = system.STDERR_FILENO;"},
{"lineNum":"  136","line":"pub const STDIN_FILENO = system.STDIN_FILENO;"},
{"lineNum":"  137","line":"pub const STDOUT_FILENO = system.STDOUT_FILENO;"},
{"lineNum":"  138","line":"pub const SYS = system.SYS;"},
{"lineNum":"  139","line":"pub const Sigaction = system.Sigaction;"},
{"lineNum":"  140","line":"pub const Stat = system.Stat;"},
{"lineNum":"  141","line":"pub const TCSA = system.TCSA;"},
{"lineNum":"  142","line":"pub const TCP = system.TCP;"},
{"lineNum":"  143","line":"pub const VDSO = system.VDSO;"},
{"lineNum":"  144","line":"pub const W = system.W;"},
{"lineNum":"  145","line":"pub const addrinfo = system.addrinfo;"},
{"lineNum":"  146","line":"pub const blkcnt_t = system.blkcnt_t;"},
{"lineNum":"  147","line":"pub const blksize_t = system.blksize_t;"},
{"lineNum":"  148","line":"pub const clock_t = system.clock_t;"},
{"lineNum":"  149","line":"pub const cpu_set_t = system.cpu_set_t;"},
{"lineNum":"  150","line":"pub const dev_t = system.dev_t;"},
{"lineNum":"  151","line":"pub const dl_phdr_info = system.dl_phdr_info;"},
{"lineNum":"  152","line":"pub const empty_sigset = system.empty_sigset;"},
{"lineNum":"  153","line":"pub const fd_t = system.fd_t;"},
{"lineNum":"  154","line":"pub const fdflags_t = system.fdflags_t;"},
{"lineNum":"  155","line":"pub const fdstat_t = system.fdstat_t;"},
{"lineNum":"  156","line":"pub const gid_t = system.gid_t;"},
{"lineNum":"  157","line":"pub const ifreq = system.ifreq;"},
{"lineNum":"  158","line":"pub const ino_t = system.ino_t;"},
{"lineNum":"  159","line":"pub const lookupflags_t = system.lookupflags_t;"},
{"lineNum":"  160","line":"pub const mcontext_t = system.mcontext_t;"},
{"lineNum":"  161","line":"pub const mode_t = system.mode_t;"},
{"lineNum":"  162","line":"pub const msghdr = system.msghdr;"},
{"lineNum":"  163","line":"pub const msghdr_const = system.msghdr_const;"},
{"lineNum":"  164","line":"pub const nfds_t = system.nfds_t;"},
{"lineNum":"  165","line":"pub const nlink_t = system.nlink_t;"},
{"lineNum":"  166","line":"pub const off_t = system.off_t;"},
{"lineNum":"  167","line":"pub const oflags_t = system.oflags_t;"},
{"lineNum":"  168","line":"pub const pid_t = system.pid_t;"},
{"lineNum":"  169","line":"pub const pollfd = system.pollfd;"},
{"lineNum":"  170","line":"pub const port_t = system.port_t;"},
{"lineNum":"  171","line":"pub const port_event = system.port_event;"},
{"lineNum":"  172","line":"pub const port_notify = system.port_notify;"},
{"lineNum":"  173","line":"pub const file_obj = system.file_obj;"},
{"lineNum":"  174","line":"pub const rights_t = system.rights_t;"},
{"lineNum":"  175","line":"pub const rlim_t = system.rlim_t;"},
{"lineNum":"  176","line":"pub const rlimit = system.rlimit;"},
{"lineNum":"  177","line":"pub const rlimit_resource = system.rlimit_resource;"},
{"lineNum":"  178","line":"pub const rusage = system.rusage;"},
{"lineNum":"  179","line":"pub const sa_family_t = system.sa_family_t;"},
{"lineNum":"  180","line":"pub const siginfo_t = system.siginfo_t;"},
{"lineNum":"  181","line":"pub const sigset_t = system.sigset_t;"},
{"lineNum":"  182","line":"pub const sockaddr = system.sockaddr;"},
{"lineNum":"  183","line":"pub const socklen_t = system.socklen_t;"},
{"lineNum":"  184","line":"pub const stack_t = system.stack_t;"},
{"lineNum":"  185","line":"pub const tcflag_t = system.tcflag_t;"},
{"lineNum":"  186","line":"pub const termios = system.termios;"},
{"lineNum":"  187","line":"pub const time_t = system.time_t;"},
{"lineNum":"  188","line":"pub const timespec = system.timespec;"},
{"lineNum":"  189","line":"pub const timestamp_t = system.timestamp_t;"},
{"lineNum":"  190","line":"pub const timeval = system.timeval;"},
{"lineNum":"  191","line":"pub const timezone = system.timezone;"},
{"lineNum":"  192","line":"pub const ucontext_t = system.ucontext_t;"},
{"lineNum":"  193","line":"pub const uid_t = system.uid_t;"},
{"lineNum":"  194","line":"pub const user_desc = system.user_desc;"},
{"lineNum":"  195","line":"pub const utsname = system.utsname;"},
{"lineNum":"  196","line":""},
{"lineNum":"  197","line":"pub const F_OK = system.F_OK;"},
{"lineNum":"  198","line":"pub const R_OK = system.R_OK;"},
{"lineNum":"  199","line":"pub const W_OK = system.W_OK;"},
{"lineNum":"  200","line":"pub const X_OK = system.X_OK;"},
{"lineNum":"  201","line":""},
{"lineNum":"  202","line":"pub const iovec = extern struct {"},
{"lineNum":"  203","line":"    iov_base: [*]u8,"},
{"lineNum":"  204","line":"    iov_len: usize,"},
{"lineNum":"  205","line":"};"},
{"lineNum":"  206","line":""},
{"lineNum":"  207","line":"pub const iovec_const = extern struct {"},
{"lineNum":"  208","line":"    iov_base: [*]const u8,"},
{"lineNum":"  209","line":"    iov_len: usize,"},
{"lineNum":"  210","line":"};"},
{"lineNum":"  211","line":""},
{"lineNum":"  212","line":"pub const LOG = struct {"},
{"lineNum":"  213","line":"    /// system is unusable"},
{"lineNum":"  214","line":"    pub const EMERG = 0;"},
{"lineNum":"  215","line":"    /// action must be taken immediately"},
{"lineNum":"  216","line":"    pub const ALERT = 1;"},
{"lineNum":"  217","line":"    /// critical conditions"},
{"lineNum":"  218","line":"    pub const CRIT = 2;"},
{"lineNum":"  219","line":"    /// error conditions"},
{"lineNum":"  220","line":"    pub const ERR = 3;"},
{"lineNum":"  221","line":"    /// warning conditions"},
{"lineNum":"  222","line":"    pub const WARNING = 4;"},
{"lineNum":"  223","line":"    /// normal but significant condition"},
{"lineNum":"  224","line":"    pub const NOTICE = 5;"},
{"lineNum":"  225","line":"    /// informational"},
{"lineNum":"  226","line":"    pub const INFO = 6;"},
{"lineNum":"  227","line":"    /// debug-level messages"},
{"lineNum":"  228","line":"    pub const DEBUG = 7;"},
{"lineNum":"  229","line":"};"},
{"lineNum":"  230","line":""},
{"lineNum":"  231","line":"/// An fd-relative file path"},
{"lineNum":"  232","line":"///"},
{"lineNum":"  233","line":"/// This is currently only used for WASI-specific functionality, but the concept"},
{"lineNum":"  234","line":"/// is the same as the dirfd/pathname pairs in the `*at(...)` POSIX functions."},
{"lineNum":"  235","line":"pub const RelativePathWasi = struct {"},
{"lineNum":"  236","line":"    /// Handle to directory"},
{"lineNum":"  237","line":"    dir_fd: fd_t,"},
{"lineNum":"  238","line":"    /// Path to resource within `dir_fd`."},
{"lineNum":"  239","line":"    relative_path: []const u8,"},
{"lineNum":"  240","line":"};"},
{"lineNum":"  241","line":""},
{"lineNum":"  242","line":"pub const socket_t = if (builtin.os.tag == .windows) windows.ws2_32.SOCKET else fd_t;"},
{"lineNum":"  243","line":""},
{"lineNum":"  244","line":"/// See also `getenv`. Populated by startup code before main()."},
{"lineNum":"  245","line":"/// TODO this is a footgun because the value will be undefined when using `zig build-lib`."},
{"lineNum":"  246","line":"/// https://github.com/ziglang/zig/issues/4524"},
{"lineNum":"  247","line":"pub var environ: [][*:0]u8 = undefined;"},
{"lineNum":"  248","line":""},
{"lineNum":"  249","line":"/// Populated by startup code before main()."},
{"lineNum":"  250","line":"/// Not available on WASI or Windows without libc. See `std.process.argsAlloc`"},
{"lineNum":"  251","line":"/// or `std.process.argsWithAllocator` for a cross-platform alternative."},
{"lineNum":"  252","line":"pub var argv: [][*:0]u8 = if (builtin.link_libc) undefined else switch (builtin.os.tag) {"},
{"lineNum":"  253","line":"    .windows => @compileError(\"argv isn\'t supported on Windows: use std.process.argsAlloc instead\"),"},
{"lineNum":"  254","line":"    .wasi => @compileError(\"argv isn\'t supported on WASI: use std.process.argsAlloc instead\"),"},
{"lineNum":"  255","line":"    else => undefined,"},
{"lineNum":"  256","line":"};"},
{"lineNum":"  257","line":""},
{"lineNum":"  258","line":"pub const have_sigpipe_support = @hasDecl(@This(), \"SIG\") and @hasDecl(SIG, \"PIPE\");"},
{"lineNum":"  259","line":""},
{"lineNum":"  260","line":"fn noopSigHandler(_: c_int) callconv(.C) void {}"},
{"lineNum":"  261","line":""},
{"lineNum":"  262","line":"/// On default executed by posix startup code before main(), if SIGPIPE is supported."},
{"lineNum":"  263","line":"pub fn maybeIgnoreSigpipe() void {","class":"lineCov","hits":"1","order":"157","possible_hits":"1",},
{"lineNum":"  264","line":"    if (have_sigpipe_support and !std.options.keep_sigpipe) {"},
{"lineNum":"  265","line":"        const act = Sigaction{"},
{"lineNum":"  266","line":"            // We set handler to a noop function instead of SIG.IGN so we don\'t leak our"},
{"lineNum":"  267","line":"            // signal disposition to a child process"},
{"lineNum":"  268","line":"            .handler = .{ .handler = noopSigHandler },"},
{"lineNum":"  269","line":"            .mask = empty_sigset,"},
{"lineNum":"  270","line":"            .flags = 0,"},
{"lineNum":"  271","line":"        };"},
{"lineNum":"  272","line":"        sigaction(SIG.PIPE, &act, null) catch |err|","class":"lineCov","hits":"2","order":"158","possible_hits":"2",},
{"lineNum":"  273","line":"            std.debug.panic(\"failed to install noop SIGPIPE handler with \'{s}\'\", .{@errorName(err)});","class":"linePartCov","hits":"1","order":"159","possible_hits":"2",},
{"lineNum":"  274","line":"    }"},
{"lineNum":"  275","line":"}"},
{"lineNum":"  276","line":""},
{"lineNum":"  277","line":"/// To obtain errno, call this function with the return value of the"},
{"lineNum":"  278","line":"/// system function call. For some systems this will obtain the value directly"},
{"lineNum":"  279","line":"/// from the return code; for others it will use a thread-local errno variable."},
{"lineNum":"  280","line":"/// Therefore, this function only returns a well-defined value when it is called"},
{"lineNum":"  281","line":"/// directly after the system function call which one wants to learn the errno"},
{"lineNum":"  282","line":"/// value of."},
{"lineNum":"  283","line":"pub const errno = system.getErrno;"},
{"lineNum":"  284","line":""},
{"lineNum":"  285","line":"/// Closes the file descriptor."},
{"lineNum":"  286","line":"/// This function is not capable of returning any indication of failure. An"},
{"lineNum":"  287","line":"/// application which wants to ensure writes have succeeded before closing"},
{"lineNum":"  288","line":"/// must call `fsync` before `close`."},
{"lineNum":"  289","line":"/// Note: The Zig standard library does not support POSIX thread cancellation."},
{"lineNum":"  290","line":"pub fn close(fd: fd_t) void {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  291","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":"  292","line":"        return windows.CloseHandle(fd);"},
{"lineNum":"  293","line":"    }"},
{"lineNum":"  294","line":"    if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":"  295","line":"        _ = wasi.fd_close(fd);"},
{"lineNum":"  296","line":"        return;"},
{"lineNum":"  297","line":"    }"},
{"lineNum":"  298","line":"    if (comptime builtin.target.isDarwin()) {"},
{"lineNum":"  299","line":"        // This avoids the EINTR problem."},
{"lineNum":"  300","line":"        switch (darwin.getErrno(darwin.@\"close$NOCANCEL\"(fd))) {"},
{"lineNum":"  301","line":"            .BADF => unreachable, // Always a race condition."},
{"lineNum":"  302","line":"            else => return,"},
{"lineNum":"  303","line":"        }"},
{"lineNum":"  304","line":"    }"},
{"lineNum":"  305","line":"    switch (errno(system.close(fd))) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  306","line":"        .BADF => unreachable, // Always a race condition.","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  307","line":"        .INTR => return, // This is still a success. See https://github.com/ziglang/zig/issues/2425","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  308","line":"        else => return,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  309","line":"    }"},
{"lineNum":"  310","line":"}"},
{"lineNum":"  311","line":""},
{"lineNum":"  312","line":"pub const FChmodError = error{"},
{"lineNum":"  313","line":"    AccessDenied,"},
{"lineNum":"  314","line":"    InputOutput,"},
{"lineNum":"  315","line":"    SymLinkLoop,"},
{"lineNum":"  316","line":"    FileNotFound,"},
{"lineNum":"  317","line":"    SystemResources,"},
{"lineNum":"  318","line":"    ReadOnlyFileSystem,"},
{"lineNum":"  319","line":"} || UnexpectedError;"},
{"lineNum":"  320","line":""},
{"lineNum":"  321","line":"/// Changes the mode of the file referred to by the file descriptor."},
{"lineNum":"  322","line":"/// The process must have the correct privileges in order to do this"},
{"lineNum":"  323","line":"/// successfully, or must have the effective user ID matching the owner"},
{"lineNum":"  324","line":"/// of the file."},
{"lineNum":"  325","line":"pub fn fchmod(fd: fd_t, mode: mode_t) FChmodError!void {"},
{"lineNum":"  326","line":"    if (!std.fs.has_executable_bit) @compileError(\"fchmod unsupported by target OS\");"},
{"lineNum":"  327","line":""},
{"lineNum":"  328","line":"    while (true) {"},
{"lineNum":"  329","line":"        const res = system.fchmod(fd, mode);"},
{"lineNum":"  330","line":""},
{"lineNum":"  331","line":"        switch (system.getErrno(res)) {"},
{"lineNum":"  332","line":"            .SUCCESS => return,"},
{"lineNum":"  333","line":"            .INTR => continue,"},
{"lineNum":"  334","line":"            .BADF => unreachable,"},
{"lineNum":"  335","line":"            .FAULT => unreachable,"},
{"lineNum":"  336","line":"            .INVAL => unreachable,"},
{"lineNum":"  337","line":"            .ACCES => return error.AccessDenied,"},
{"lineNum":"  338","line":"            .IO => return error.InputOutput,"},
{"lineNum":"  339","line":"            .LOOP => return error.SymLinkLoop,"},
{"lineNum":"  340","line":"            .NOENT => return error.FileNotFound,"},
{"lineNum":"  341","line":"            .NOMEM => return error.SystemResources,"},
{"lineNum":"  342","line":"            .NOTDIR => return error.FileNotFound,"},
{"lineNum":"  343","line":"            .PERM => return error.AccessDenied,"},
{"lineNum":"  344","line":"            .ROFS => return error.ReadOnlyFileSystem,"},
{"lineNum":"  345","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":"  346","line":"        }"},
{"lineNum":"  347","line":"    }"},
{"lineNum":"  348","line":"}"},
{"lineNum":"  349","line":""},
{"lineNum":"  350","line":"const FChmodAtError = FChmodError || error{"},
{"lineNum":"  351","line":"    NameTooLong,"},
{"lineNum":"  352","line":"};"},
{"lineNum":"  353","line":""},
{"lineNum":"  354","line":"pub fn fchmodat(dirfd: fd_t, path: []const u8, mode: mode_t, flags: u32) FChmodAtError!void {"},
{"lineNum":"  355","line":"    if (!std.fs.has_executable_bit) @compileError(\"fchmodat unsupported by target OS\");"},
{"lineNum":"  356","line":""},
{"lineNum":"  357","line":"    const path_c = try toPosixPath(path);"},
{"lineNum":"  358","line":""},
{"lineNum":"  359","line":"    while (true) {"},
{"lineNum":"  360","line":"        const res = system.fchmodat(dirfd, &path_c, mode, flags);"},
{"lineNum":"  361","line":""},
{"lineNum":"  362","line":"        switch (system.getErrno(res)) {"},
{"lineNum":"  363","line":"            .SUCCESS => return,"},
{"lineNum":"  364","line":"            .INTR => continue,"},
{"lineNum":"  365","line":"            .BADF => unreachable,"},
{"lineNum":"  366","line":"            .FAULT => unreachable,"},
{"lineNum":"  367","line":"            .INVAL => unreachable,"},
{"lineNum":"  368","line":"            .ACCES => return error.AccessDenied,"},
{"lineNum":"  369","line":"            .IO => return error.InputOutput,"},
{"lineNum":"  370","line":"            .LOOP => return error.SymLinkLoop,"},
{"lineNum":"  371","line":"            .NOENT => return error.FileNotFound,"},
{"lineNum":"  372","line":"            .NOMEM => return error.SystemResources,"},
{"lineNum":"  373","line":"            .NOTDIR => return error.FileNotFound,"},
{"lineNum":"  374","line":"            .PERM => return error.AccessDenied,"},
{"lineNum":"  375","line":"            .ROFS => return error.ReadOnlyFileSystem,"},
{"lineNum":"  376","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":"  377","line":"        }"},
{"lineNum":"  378","line":"    }"},
{"lineNum":"  379","line":"}"},
{"lineNum":"  380","line":""},
{"lineNum":"  381","line":"pub const FChownError = error{"},
{"lineNum":"  382","line":"    AccessDenied,"},
{"lineNum":"  383","line":"    InputOutput,"},
{"lineNum":"  384","line":"    SymLinkLoop,"},
{"lineNum":"  385","line":"    FileNotFound,"},
{"lineNum":"  386","line":"    SystemResources,"},
{"lineNum":"  387","line":"    ReadOnlyFileSystem,"},
{"lineNum":"  388","line":"} || UnexpectedError;"},
{"lineNum":"  389","line":""},
{"lineNum":"  390","line":"/// Changes the owner and group of the file referred to by the file descriptor."},
{"lineNum":"  391","line":"/// The process must have the correct privileges in order to do this"},
{"lineNum":"  392","line":"/// successfully. The group may be changed by the owner of the directory to"},
{"lineNum":"  393","line":"/// any group of which the owner is a member. If the owner or group is"},
{"lineNum":"  394","line":"/// specified as `null`, the ID is not changed."},
{"lineNum":"  395","line":"pub fn fchown(fd: fd_t, owner: ?uid_t, group: ?gid_t) FChownError!void {"},
{"lineNum":"  396","line":"    if (builtin.os.tag == .windows or builtin.os.tag == .wasi)"},
{"lineNum":"  397","line":"        @compileError(\"Unsupported OS\");"},
{"lineNum":"  398","line":""},
{"lineNum":"  399","line":"    while (true) {"},
{"lineNum":"  400","line":"        const res = system.fchown(fd, owner orelse @as(u32, 0) -% 1, group orelse @as(u32, 0) -% 1);"},
{"lineNum":"  401","line":""},
{"lineNum":"  402","line":"        switch (system.getErrno(res)) {"},
{"lineNum":"  403","line":"            .SUCCESS => return,"},
{"lineNum":"  404","line":"            .INTR => continue,"},
{"lineNum":"  405","line":"            .BADF => unreachable, // Can be reached if the fd refers to a non-iterable directory."},
{"lineNum":"  406","line":""},
{"lineNum":"  407","line":"            .FAULT => unreachable,"},
{"lineNum":"  408","line":"            .INVAL => unreachable,"},
{"lineNum":"  409","line":"            .ACCES => return error.AccessDenied,"},
{"lineNum":"  410","line":"            .IO => return error.InputOutput,"},
{"lineNum":"  411","line":"            .LOOP => return error.SymLinkLoop,"},
{"lineNum":"  412","line":"            .NOENT => return error.FileNotFound,"},
{"lineNum":"  413","line":"            .NOMEM => return error.SystemResources,"},
{"lineNum":"  414","line":"            .NOTDIR => return error.FileNotFound,"},
{"lineNum":"  415","line":"            .PERM => return error.AccessDenied,"},
{"lineNum":"  416","line":"            .ROFS => return error.ReadOnlyFileSystem,"},
{"lineNum":"  417","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":"  418","line":"        }"},
{"lineNum":"  419","line":"    }"},
{"lineNum":"  420","line":"}"},
{"lineNum":"  421","line":""},
{"lineNum":"  422","line":"pub const RebootError = error{"},
{"lineNum":"  423","line":"    PermissionDenied,"},
{"lineNum":"  424","line":"} || UnexpectedError;"},
{"lineNum":"  425","line":""},
{"lineNum":"  426","line":"pub const RebootCommand = switch (builtin.os.tag) {"},
{"lineNum":"  427","line":"    .linux => union(linux.LINUX_REBOOT.CMD) {"},
{"lineNum":"  428","line":"        RESTART: void,"},
{"lineNum":"  429","line":"        HALT: void,"},
{"lineNum":"  430","line":"        CAD_ON: void,"},
{"lineNum":"  431","line":"        CAD_OFF: void,"},
{"lineNum":"  432","line":"        POWER_OFF: void,"},
{"lineNum":"  433","line":"        RESTART2: [*:0]const u8,"},
{"lineNum":"  434","line":"        SW_SUSPEND: void,"},
{"lineNum":"  435","line":"        KEXEC: void,"},
{"lineNum":"  436","line":"    },"},
{"lineNum":"  437","line":"    else => @compileError(\"Unsupported OS\"),"},
{"lineNum":"  438","line":"};"},
{"lineNum":"  439","line":""},
{"lineNum":"  440","line":"pub fn reboot(cmd: RebootCommand) RebootError!void {"},
{"lineNum":"  441","line":"    switch (builtin.os.tag) {"},
{"lineNum":"  442","line":"        .linux => {"},
{"lineNum":"  443","line":"            switch (system.getErrno(linux.reboot("},
{"lineNum":"  444","line":"                .MAGIC1,"},
{"lineNum":"  445","line":"                .MAGIC2,"},
{"lineNum":"  446","line":"                @as(linux.LINUX_REBOOT.CMD, cmd),"},
{"lineNum":"  447","line":"                switch (cmd) {"},
{"lineNum":"  448","line":"                    .RESTART2 => |s| s,"},
{"lineNum":"  449","line":"                    else => null,"},
{"lineNum":"  450","line":"                },"},
{"lineNum":"  451","line":"            ))) {"},
{"lineNum":"  452","line":"                .SUCCESS => {},"},
{"lineNum":"  453","line":"                .PERM => return error.PermissionDenied,"},
{"lineNum":"  454","line":"                else => |err| return std.os.unexpectedErrno(err),"},
{"lineNum":"  455","line":"            }"},
{"lineNum":"  456","line":"            switch (cmd) {"},
{"lineNum":"  457","line":"                .CAD_OFF => {},"},
{"lineNum":"  458","line":"                .CAD_ON => {},"},
{"lineNum":"  459","line":"                .SW_SUSPEND => {},"},
{"lineNum":"  460","line":""},
{"lineNum":"  461","line":"                .HALT => unreachable,"},
{"lineNum":"  462","line":"                .KEXEC => unreachable,"},
{"lineNum":"  463","line":"                .POWER_OFF => unreachable,"},
{"lineNum":"  464","line":"                .RESTART => unreachable,"},
{"lineNum":"  465","line":"                .RESTART2 => unreachable,"},
{"lineNum":"  466","line":"            }"},
{"lineNum":"  467","line":"        },"},
{"lineNum":"  468","line":"        else => @compileError(\"Unsupported OS\"),"},
{"lineNum":"  469","line":"    }"},
{"lineNum":"  470","line":"}"},
{"lineNum":"  471","line":""},
{"lineNum":"  472","line":"pub const GetRandomError = OpenError;"},
{"lineNum":"  473","line":""},
{"lineNum":"  474","line":"/// Obtain a series of random bytes. These bytes can be used to seed user-space"},
{"lineNum":"  475","line":"/// random number generators or for cryptographic purposes."},
{"lineNum":"  476","line":"/// When linking against libc, this calls the"},
{"lineNum":"  477","line":"/// appropriate OS-specific library call. Otherwise it uses the zig standard"},
{"lineNum":"  478","line":"/// library implementation."},
{"lineNum":"  479","line":"pub fn getrandom(buffer: []u8) GetRandomError!void {"},
{"lineNum":"  480","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":"  481","line":"        return windows.RtlGenRandom(buffer);"},
{"lineNum":"  482","line":"    }"},
{"lineNum":"  483","line":"    if (builtin.os.tag == .linux or builtin.os.tag == .freebsd) {"},
{"lineNum":"  484","line":"        var buf = buffer;"},
{"lineNum":"  485","line":"        const use_c = builtin.os.tag != .linux or"},
{"lineNum":"  486","line":"            std.c.versionCheck(std.SemanticVersion{ .major = 2, .minor = 25, .patch = 0 }).ok;"},
{"lineNum":"  487","line":""},
{"lineNum":"  488","line":"        while (buf.len != 0) {"},
{"lineNum":"  489","line":"            const res = if (use_c) blk: {"},
{"lineNum":"  490","line":"                const rc = std.c.getrandom(buf.ptr, buf.len, 0);"},
{"lineNum":"  491","line":"                break :blk .{"},
{"lineNum":"  492","line":"                    .num_read = @as(usize, @bitCast(rc)),"},
{"lineNum":"  493","line":"                    .err = std.c.getErrno(rc),"},
{"lineNum":"  494","line":"                };"},
{"lineNum":"  495","line":"            } else blk: {"},
{"lineNum":"  496","line":"                const rc = linux.getrandom(buf.ptr, buf.len, 0);"},
{"lineNum":"  497","line":"                break :blk .{"},
{"lineNum":"  498","line":"                    .num_read = rc,"},
{"lineNum":"  499","line":"                    .err = linux.getErrno(rc),"},
{"lineNum":"  500","line":"                };"},
{"lineNum":"  501","line":"            };"},
{"lineNum":"  502","line":""},
{"lineNum":"  503","line":"            switch (res.err) {"},
{"lineNum":"  504","line":"                .SUCCESS => buf = buf[res.num_read..],"},
{"lineNum":"  505","line":"                .INVAL => unreachable,"},
{"lineNum":"  506","line":"                .FAULT => unreachable,"},
{"lineNum":"  507","line":"                .INTR => continue,"},
{"lineNum":"  508","line":"                .NOSYS => return getRandomBytesDevURandom(buf),"},
{"lineNum":"  509","line":"                else => return unexpectedErrno(res.err),"},
{"lineNum":"  510","line":"            }"},
{"lineNum":"  511","line":"        }"},
{"lineNum":"  512","line":"        return;"},
{"lineNum":"  513","line":"    }"},
{"lineNum":"  514","line":"    switch (builtin.os.tag) {"},
{"lineNum":"  515","line":"        .netbsd, .openbsd, .macos, .ios, .tvos, .watchos => {"},
{"lineNum":"  516","line":"            system.arc4random_buf(buffer.ptr, buffer.len);"},
{"lineNum":"  517","line":"            return;"},
{"lineNum":"  518","line":"        },"},
{"lineNum":"  519","line":"        .wasi => switch (wasi.random_get(buffer.ptr, buffer.len)) {"},
{"lineNum":"  520","line":"            .SUCCESS => return,"},
{"lineNum":"  521","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":"  522","line":"        },"},
{"lineNum":"  523","line":"        else => return getRandomBytesDevURandom(buffer),"},
{"lineNum":"  524","line":"    }"},
{"lineNum":"  525","line":"}"},
{"lineNum":"  526","line":""},
{"lineNum":"  527","line":"fn getRandomBytesDevURandom(buf: []u8) !void {"},
{"lineNum":"  528","line":"    const fd = try openZ(\"/dev/urandom\", O.RDONLY | O.CLOEXEC, 0);"},
{"lineNum":"  529","line":"    defer close(fd);"},
{"lineNum":"  530","line":""},
{"lineNum":"  531","line":"    const st = try fstat(fd);"},
{"lineNum":"  532","line":"    if (!S.ISCHR(st.mode)) {"},
{"lineNum":"  533","line":"        return error.NoDevice;"},
{"lineNum":"  534","line":"    }"},
{"lineNum":"  535","line":""},
{"lineNum":"  536","line":"    const file = std.fs.File{"},
{"lineNum":"  537","line":"        .handle = fd,"},
{"lineNum":"  538","line":"        .capable_io_mode = .blocking,"},
{"lineNum":"  539","line":"        .intended_io_mode = .blocking,"},
{"lineNum":"  540","line":"    };"},
{"lineNum":"  541","line":"    const stream = file.reader();"},
{"lineNum":"  542","line":"    stream.readNoEof(buf) catch return error.Unexpected;"},
{"lineNum":"  543","line":"}"},
{"lineNum":"  544","line":""},
{"lineNum":"  545","line":"/// Causes abnormal process termination."},
{"lineNum":"  546","line":"/// If linking against libc, this calls the abort() libc function. Otherwise"},
{"lineNum":"  547","line":"/// it raises SIGABRT followed by SIGKILL and finally lo"},
{"lineNum":"  548","line":"/// Invokes the current signal handler for SIGABRT, if any."},
{"lineNum":"  549","line":"pub fn abort() noreturn {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  550","line":"    @setCold(true);"},
{"lineNum":"  551","line":"    // MSVCRT abort() sometimes opens a popup window which is undesirable, so"},
{"lineNum":"  552","line":"    // even when linking libc on Windows we use our own abort implementation."},
{"lineNum":"  553","line":"    // See https://github.com/ziglang/zig/issues/2071 for more details."},
{"lineNum":"  554","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":"  555","line":"        if (builtin.mode == .Debug) {"},
{"lineNum":"  556","line":"            @breakpoint();"},
{"lineNum":"  557","line":"        }"},
{"lineNum":"  558","line":"        windows.kernel32.ExitProcess(3);"},
{"lineNum":"  559","line":"    }"},
{"lineNum":"  560","line":"    if (!builtin.link_libc and builtin.os.tag == .linux) {"},
{"lineNum":"  561","line":"        // The Linux man page says that the libc abort() function"},
{"lineNum":"  562","line":"        // \"first unblocks the SIGABRT signal\", but this is a footgun"},
{"lineNum":"  563","line":"        // for user-defined signal handlers that want to restore some state in"},
{"lineNum":"  564","line":"        // some program sections and crash in others."},
{"lineNum":"  565","line":"        // So, the user-installed SIGABRT handler is run, if present."},
{"lineNum":"  566","line":"        raise(SIG.ABRT) catch {};","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  567","line":""},
{"lineNum":"  568","line":"        // Disable all signal handlers."},
{"lineNum":"  569","line":"        sigprocmask(SIG.BLOCK, &linux.all_mask, null);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  570","line":""},
{"lineNum":"  571","line":"        // Only one thread may proceed to the rest of abort()."},
{"lineNum":"  572","line":"        if (!builtin.single_threaded) {"},
{"lineNum":"  573","line":"            const global = struct {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  574","line":"                var abort_entered: bool = false;"},
{"lineNum":"  575","line":"            };"},
{"lineNum":"  576","line":"            while (@cmpxchgWeak(bool, &global.abort_entered, false, true, .SeqCst, .SeqCst)) |_| {}","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  577","line":"        }"},
{"lineNum":"  578","line":""},
{"lineNum":"  579","line":"        // Install default handler so that the tkill below will terminate."},
{"lineNum":"  580","line":"        const sigact = Sigaction{"},
{"lineNum":"  581","line":"            .handler = .{ .handler = SIG.DFL },"},
{"lineNum":"  582","line":"            .mask = empty_sigset,"},
{"lineNum":"  583","line":"            .flags = 0,"},
{"lineNum":"  584","line":"        };"},
{"lineNum":"  585","line":"        sigaction(SIG.ABRT, &sigact, null) catch |err| switch (err) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  586","line":"            error.OperationNotSupported => unreachable,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  587","line":"        };"},
{"lineNum":"  588","line":""},
{"lineNum":"  589","line":"        _ = linux.tkill(linux.gettid(), SIG.ABRT);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  590","line":""},
{"lineNum":"  591","line":"        const sigabrtmask: linux.sigset_t = [_]u32{0} ** 31 ++ [_]u32{1 << (SIG.ABRT - 1)};"},
{"lineNum":"  592","line":"        sigprocmask(SIG.UNBLOCK, &sigabrtmask, null);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  593","line":""},
{"lineNum":"  594","line":"        // Beyond this point should be unreachable."},
{"lineNum":"  595","line":"        @as(*allowzero volatile u8, @ptrFromInt(0)).* = 0;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  596","line":"        raise(SIG.KILL) catch {};","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  597","line":"        exit(127); // Pid 1 might not be signalled in some containers.","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  598","line":"    }"},
{"lineNum":"  599","line":"    switch (builtin.os.tag) {"},
{"lineNum":"  600","line":"        .uefi, .wasi, .cuda, .amdhsa => @trap(),"},
{"lineNum":"  601","line":"        else => system.abort(),"},
{"lineNum":"  602","line":"    }"},
{"lineNum":"  603","line":"}"},
{"lineNum":"  604","line":""},
{"lineNum":"  605","line":"pub const RaiseError = UnexpectedError;"},
{"lineNum":"  606","line":""},
{"lineNum":"  607","line":"pub fn raise(sig: u8) RaiseError!void {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  608","line":"    if (builtin.link_libc) {"},
{"lineNum":"  609","line":"        switch (errno(system.raise(sig))) {"},
{"lineNum":"  610","line":"            .SUCCESS => return,"},
{"lineNum":"  611","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":"  612","line":"        }"},
{"lineNum":"  613","line":"    }"},
{"lineNum":"  614","line":""},
{"lineNum":"  615","line":"    if (builtin.os.tag == .linux) {"},
{"lineNum":"  616","line":"        var set: sigset_t = undefined;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  617","line":"        // block application signals"},
{"lineNum":"  618","line":"        sigprocmask(SIG.BLOCK, &linux.app_mask, &set);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  619","line":""},
{"lineNum":"  620","line":"        const tid = linux.gettid();","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  621","line":"        const rc = linux.tkill(tid, sig);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  622","line":""},
{"lineNum":"  623","line":"        // restore signal mask"},
{"lineNum":"  624","line":"        sigprocmask(SIG.SETMASK, &set, null);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  625","line":""},
{"lineNum":"  626","line":"        switch (errno(rc)) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  627","line":"            .SUCCESS => return,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  628","line":"            else => |err| return unexpectedErrno(err),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  629","line":"        }"},
{"lineNum":"  630","line":"    }"},
{"lineNum":"  631","line":""},
{"lineNum":"  632","line":"    @compileError(\"std.os.raise unimplemented for this target\");"},
{"lineNum":"  633","line":"}"},
{"lineNum":"  634","line":""},
{"lineNum":"  635","line":"pub const KillError = error{PermissionDenied} || UnexpectedError;"},
{"lineNum":"  636","line":""},
{"lineNum":"  637","line":"pub fn kill(pid: pid_t, sig: u8) KillError!void {"},
{"lineNum":"  638","line":"    switch (errno(system.kill(pid, sig))) {"},
{"lineNum":"  639","line":"        .SUCCESS => return,"},
{"lineNum":"  640","line":"        .INVAL => unreachable, // invalid signal"},
{"lineNum":"  641","line":"        .PERM => return error.PermissionDenied,"},
{"lineNum":"  642","line":"        .SRCH => unreachable, // always a race condition"},
{"lineNum":"  643","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":"  644","line":"    }"},
{"lineNum":"  645","line":"}"},
{"lineNum":"  646","line":""},
{"lineNum":"  647","line":"/// Exits the program cleanly with the specified status code."},
{"lineNum":"  648","line":"pub fn exit(status: u8) noreturn {","class":"lineCov","hits":"1","order":"3542","possible_hits":"1",},
{"lineNum":"  649","line":"    if (builtin.link_libc) {"},
{"lineNum":"  650","line":"        system.exit(status);"},
{"lineNum":"  651","line":"    }"},
{"lineNum":"  652","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":"  653","line":"        windows.kernel32.ExitProcess(status);"},
{"lineNum":"  654","line":"    }"},
{"lineNum":"  655","line":"    if (builtin.os.tag == .wasi) {"},
{"lineNum":"  656","line":"        wasi.proc_exit(status);"},
{"lineNum":"  657","line":"    }"},
{"lineNum":"  658","line":"    if (builtin.os.tag == .linux and !builtin.single_threaded) {"},
{"lineNum":"  659","line":"        linux.exit_group(status);","class":"lineCov","hits":"1","order":"3543","possible_hits":"1",},
{"lineNum":"  660","line":"    }"},
{"lineNum":"  661","line":"    if (builtin.os.tag == .uefi) {"},
{"lineNum":"  662","line":"        // exit() is only available if exitBootServices() has not been called yet."},
{"lineNum":"  663","line":"        // This call to exit should not fail, so we don\'t care about its return value."},
{"lineNum":"  664","line":"        if (uefi.system_table.boot_services) |bs| {"},
{"lineNum":"  665","line":"            _ = bs.exit(uefi.handle, @as(uefi.Status, @enumFromInt(status)), 0, null);"},
{"lineNum":"  666","line":"        }"},
{"lineNum":"  667","line":"        // If we can\'t exit, reboot the system instead."},
{"lineNum":"  668","line":"        uefi.system_table.runtime_services.resetSystem(uefi.tables.ResetType.ResetCold, @as(uefi.Status, @enumFromInt(status)), 0, null);"},
{"lineNum":"  669","line":"    }"},
{"lineNum":"  670","line":"    system.exit(status);"},
{"lineNum":"  671","line":"}"},
{"lineNum":"  672","line":""},
{"lineNum":"  673","line":"pub const ReadError = error{"},
{"lineNum":"  674","line":"    InputOutput,"},
{"lineNum":"  675","line":"    SystemResources,"},
{"lineNum":"  676","line":"    IsDir,"},
{"lineNum":"  677","line":"    OperationAborted,"},
{"lineNum":"  678","line":"    BrokenPipe,"},
{"lineNum":"  679","line":"    ConnectionResetByPeer,"},
{"lineNum":"  680","line":"    ConnectionTimedOut,"},
{"lineNum":"  681","line":"    NotOpenForReading,"},
{"lineNum":"  682","line":""},
{"lineNum":"  683","line":"    // Windows only"},
{"lineNum":"  684","line":"    NetNameDeleted,"},
{"lineNum":"  685","line":""},
{"lineNum":"  686","line":"    /// This error occurs when no global event loop is configured,"},
{"lineNum":"  687","line":"    /// and reading from the file descriptor would block."},
{"lineNum":"  688","line":"    WouldBlock,"},
{"lineNum":"  689","line":""},
{"lineNum":"  690","line":"    /// In WASI, this error occurs when the file descriptor does"},
{"lineNum":"  691","line":"    /// not hold the required rights to read from it."},
{"lineNum":"  692","line":"    AccessDenied,"},
{"lineNum":"  693","line":"} || UnexpectedError;"},
{"lineNum":"  694","line":""},
{"lineNum":"  695","line":"/// Returns the number of bytes that were read, which can be less than"},
{"lineNum":"  696","line":"/// buf.len. If 0 bytes were read, that means EOF."},
{"lineNum":"  697","line":"/// If `fd` is opened in non blocking mode, the function will return error.WouldBlock"},
{"lineNum":"  698","line":"/// when EAGAIN is received."},
{"lineNum":"  699","line":"///"},
{"lineNum":"  700","line":"/// Linux has a limit on how many bytes may be transferred in one `read` call, which is `0x7ffff000`"},
{"lineNum":"  701","line":"/// on both 64-bit and 32-bit systems. This is due to using a signed C int as the return value, as"},
{"lineNum":"  702","line":"/// well as stuffing the errno codes into the last `4096` values. This is noted on the `read` man page."},
{"lineNum":"  703","line":"/// The limit on Darwin is `0x7fffffff`, trying to read more than that returns EINVAL."},
{"lineNum":"  704","line":"/// The corresponding POSIX limit is `math.maxInt(isize)`."},
{"lineNum":"  705","line":"pub fn read(fd: fd_t, buf: []u8) ReadError!usize {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  706","line":"    if (buf.len == 0) return 0;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  707","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":"  708","line":"        return windows.ReadFile(fd, buf, null, std.io.default_mode);"},
{"lineNum":"  709","line":"    }"},
{"lineNum":"  710","line":"    if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":"  711","line":"        const iovs = [1]iovec{iovec{"},
{"lineNum":"  712","line":"            .iov_base = buf.ptr,"},
{"lineNum":"  713","line":"            .iov_len = buf.len,"},
{"lineNum":"  714","line":"        }};"},
{"lineNum":"  715","line":""},
{"lineNum":"  716","line":"        var nread: usize = undefined;"},
{"lineNum":"  717","line":"        switch (wasi.fd_read(fd, &iovs, iovs.len, &nread)) {"},
{"lineNum":"  718","line":"            .SUCCESS => return nread,"},
{"lineNum":"  719","line":"            .INTR => unreachable,"},
{"lineNum":"  720","line":"            .INVAL => unreachable,"},
{"lineNum":"  721","line":"            .FAULT => unreachable,"},
{"lineNum":"  722","line":"            .AGAIN => unreachable,"},
{"lineNum":"  723","line":"            .BADF => return error.NotOpenForReading, // Can be a race condition."},
{"lineNum":"  724","line":"            .IO => return error.InputOutput,"},
{"lineNum":"  725","line":"            .ISDIR => return error.IsDir,"},
{"lineNum":"  726","line":"            .NOBUFS => return error.SystemResources,"},
{"lineNum":"  727","line":"            .NOMEM => return error.SystemResources,"},
{"lineNum":"  728","line":"            .CONNRESET => return error.ConnectionResetByPeer,"},
{"lineNum":"  729","line":"            .TIMEDOUT => return error.ConnectionTimedOut,"},
{"lineNum":"  730","line":"            .NOTCAPABLE => return error.AccessDenied,"},
{"lineNum":"  731","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":"  732","line":"        }"},
{"lineNum":"  733","line":"    }"},
{"lineNum":"  734","line":""},
{"lineNum":"  735","line":"    // Prevents EINVAL."},
{"lineNum":"  736","line":"    const max_count = switch (builtin.os.tag) {"},
{"lineNum":"  737","line":"        .linux => 0x7ffff000,"},
{"lineNum":"  738","line":"        .macos, .ios, .watchos, .tvos => math.maxInt(i32),"},
{"lineNum":"  739","line":"        else => math.maxInt(isize),"},
{"lineNum":"  740","line":"    };"},
{"lineNum":"  741","line":"    const adjusted_len = @min(max_count, buf.len);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  742","line":""},
{"lineNum":"  743","line":"    while (true) {"},
{"lineNum":"  744","line":"        const rc = system.read(fd, buf.ptr, adjusted_len);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  745","line":"        switch (errno(rc)) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  746","line":"            .SUCCESS => return @as(usize, @intCast(rc)),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  747","line":"            .INTR => continue,"},
{"lineNum":"  748","line":"            .INVAL => unreachable,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  749","line":"            .FAULT => unreachable,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  750","line":"            .AGAIN => return error.WouldBlock,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  751","line":"            .BADF => return error.NotOpenForReading, // Can be a race condition.","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  752","line":"            .IO => return error.InputOutput,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  753","line":"            .ISDIR => return error.IsDir,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  754","line":"            .NOBUFS => return error.SystemResources,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  755","line":"            .NOMEM => return error.SystemResources,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  756","line":"            .CONNRESET => return error.ConnectionResetByPeer,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  757","line":"            .TIMEDOUT => return error.ConnectionTimedOut,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  758","line":"            else => |err| return unexpectedErrno(err),","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  759","line":"        }"},
{"lineNum":"  760","line":"    }"},
{"lineNum":"  761","line":"}"},
{"lineNum":"  762","line":""},
{"lineNum":"  763","line":"/// Number of bytes read is returned. Upon reading end-of-file, zero is returned."},
{"lineNum":"  764","line":"///"},
{"lineNum":"  765","line":"/// For POSIX systems, if `fd` is opened in non blocking mode, the function will"},
{"lineNum":"  766","line":"/// return error.WouldBlock when EAGAIN is received."},
{"lineNum":"  767","line":"/// On Windows, if the application has a global event loop enabled, I/O Completion Ports are"},
{"lineNum":"  768","line":"/// used to perform the I/O. `error.WouldBlock` is not possible on Windows."},
{"lineNum":"  769","line":"///"},
{"lineNum":"  770","line":"/// This operation is non-atomic on the following systems:"},
{"lineNum":"  771","line":"/// * Windows"},
{"lineNum":"  772","line":"/// On these systems, the read races with concurrent writes to the same file descriptor."},
{"lineNum":"  773","line":"///"},
{"lineNum":"  774","line":"/// This function assumes that all vectors, including zero-length vectors, have"},
{"lineNum":"  775","line":"/// a pointer within the address space of the application."},
{"lineNum":"  776","line":"pub fn readv(fd: fd_t, iov: []const iovec) ReadError!usize {"},
{"lineNum":"  777","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":"  778","line":"        // TODO improve this to use ReadFileScatter"},
{"lineNum":"  779","line":"        if (iov.len == 0) return @as(usize, 0);"},
{"lineNum":"  780","line":"        const first = iov[0];"},
{"lineNum":"  781","line":"        return read(fd, first.iov_base[0..first.iov_len]);"},
{"lineNum":"  782","line":"    }"},
{"lineNum":"  783","line":"    if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":"  784","line":"        var nread: usize = undefined;"},
{"lineNum":"  785","line":"        switch (wasi.fd_read(fd, iov.ptr, iov.len, &nread)) {"},
{"lineNum":"  786","line":"            .SUCCESS => return nread,"},
{"lineNum":"  787","line":"            .INTR => unreachable,"},
{"lineNum":"  788","line":"            .INVAL => unreachable,"},
{"lineNum":"  789","line":"            .FAULT => unreachable,"},
{"lineNum":"  790","line":"            .AGAIN => unreachable, // currently not support in WASI"},
{"lineNum":"  791","line":"            .BADF => return error.NotOpenForReading, // can be a race condition"},
{"lineNum":"  792","line":"            .IO => return error.InputOutput,"},
{"lineNum":"  793","line":"            .ISDIR => return error.IsDir,"},
{"lineNum":"  794","line":"            .NOBUFS => return error.SystemResources,"},
{"lineNum":"  795","line":"            .NOMEM => return error.SystemResources,"},
{"lineNum":"  796","line":"            .NOTCAPABLE => return error.AccessDenied,"},
{"lineNum":"  797","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":"  798","line":"        }"},
{"lineNum":"  799","line":"    }"},
{"lineNum":"  800","line":"    const iov_count = math.cast(u31, iov.len) orelse math.maxInt(u31);"},
{"lineNum":"  801","line":"    while (true) {"},
{"lineNum":"  802","line":"        // TODO handle the case when iov_len is too large and get rid of this @intCast"},
{"lineNum":"  803","line":"        const rc = system.readv(fd, iov.ptr, iov_count);"},
{"lineNum":"  804","line":"        switch (errno(rc)) {"},
{"lineNum":"  805","line":"            .SUCCESS => return @as(usize, @intCast(rc)),"},
{"lineNum":"  806","line":"            .INTR => continue,"},
{"lineNum":"  807","line":"            .INVAL => unreachable,"},
{"lineNum":"  808","line":"            .FAULT => unreachable,"},
{"lineNum":"  809","line":"            .AGAIN => return error.WouldBlock,"},
{"lineNum":"  810","line":"            .BADF => return error.NotOpenForReading, // can be a race condition"},
{"lineNum":"  811","line":"            .IO => return error.InputOutput,"},
{"lineNum":"  812","line":"            .ISDIR => return error.IsDir,"},
{"lineNum":"  813","line":"            .NOBUFS => return error.SystemResources,"},
{"lineNum":"  814","line":"            .NOMEM => return error.SystemResources,"},
{"lineNum":"  815","line":"            .CONNRESET => return error.ConnectionResetByPeer,"},
{"lineNum":"  816","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":"  817","line":"        }"},
{"lineNum":"  818","line":"    }"},
{"lineNum":"  819","line":"}"},
{"lineNum":"  820","line":""},
{"lineNum":"  821","line":"pub const PReadError = ReadError || error{Unseekable};"},
{"lineNum":"  822","line":""},
{"lineNum":"  823","line":"/// Number of bytes read is returned. Upon reading end-of-file, zero is returned."},
{"lineNum":"  824","line":"///"},
{"lineNum":"  825","line":"/// Retries when interrupted by a signal."},
{"lineNum":"  826","line":"///"},
{"lineNum":"  827","line":"/// For POSIX systems, if `fd` is opened in non blocking mode, the function will"},
{"lineNum":"  828","line":"/// return error.WouldBlock when EAGAIN is received."},
{"lineNum":"  829","line":"/// On Windows, if the application has a global event loop enabled, I/O Completion Ports are"},
{"lineNum":"  830","line":"/// used to perform the I/O. `error.WouldBlock` is not possible on Windows."},
{"lineNum":"  831","line":"///"},
{"lineNum":"  832","line":"/// Linux has a limit on how many bytes may be transferred in one `pread` call, which is `0x7ffff000`"},
{"lineNum":"  833","line":"/// on both 64-bit and 32-bit systems. This is due to using a signed C int as the return value, as"},
{"lineNum":"  834","line":"/// well as stuffing the errno codes into the last `4096` values. This is noted on the `read` man page."},
{"lineNum":"  835","line":"/// The limit on Darwin is `0x7fffffff`, trying to read more than that returns EINVAL."},
{"lineNum":"  836","line":"/// The corresponding POSIX limit is `math.maxInt(isize)`."},
{"lineNum":"  837","line":"pub fn pread(fd: fd_t, buf: []u8, offset: u64) PReadError!usize {"},
{"lineNum":"  838","line":"    if (buf.len == 0) return 0;"},
{"lineNum":"  839","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":"  840","line":"        return windows.ReadFile(fd, buf, offset, std.io.default_mode);"},
{"lineNum":"  841","line":"    }"},
{"lineNum":"  842","line":"    if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":"  843","line":"        const iovs = [1]iovec{iovec{"},
{"lineNum":"  844","line":"            .iov_base = buf.ptr,"},
{"lineNum":"  845","line":"            .iov_len = buf.len,"},
{"lineNum":"  846","line":"        }};"},
{"lineNum":"  847","line":""},
{"lineNum":"  848","line":"        var nread: usize = undefined;"},
{"lineNum":"  849","line":"        switch (wasi.fd_pread(fd, &iovs, iovs.len, offset, &nread)) {"},
{"lineNum":"  850","line":"            .SUCCESS => return nread,"},
{"lineNum":"  851","line":"            .INTR => unreachable,"},
{"lineNum":"  852","line":"            .INVAL => unreachable,"},
{"lineNum":"  853","line":"            .FAULT => unreachable,"},
{"lineNum":"  854","line":"            .AGAIN => unreachable,"},
{"lineNum":"  855","line":"            .BADF => return error.NotOpenForReading, // Can be a race condition."},
{"lineNum":"  856","line":"            .IO => return error.InputOutput,"},
{"lineNum":"  857","line":"            .ISDIR => return error.IsDir,"},
{"lineNum":"  858","line":"            .NOBUFS => return error.SystemResources,"},
{"lineNum":"  859","line":"            .NOMEM => return error.SystemResources,"},
{"lineNum":"  860","line":"            .CONNRESET => return error.ConnectionResetByPeer,"},
{"lineNum":"  861","line":"            .NXIO => return error.Unseekable,"},
{"lineNum":"  862","line":"            .SPIPE => return error.Unseekable,"},
{"lineNum":"  863","line":"            .OVERFLOW => return error.Unseekable,"},
{"lineNum":"  864","line":"            .NOTCAPABLE => return error.AccessDenied,"},
{"lineNum":"  865","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":"  866","line":"        }"},
{"lineNum":"  867","line":"    }"},
{"lineNum":"  868","line":""},
{"lineNum":"  869","line":"    // Prevent EINVAL."},
{"lineNum":"  870","line":"    const max_count = switch (builtin.os.tag) {"},
{"lineNum":"  871","line":"        .linux => 0x7ffff000,"},
{"lineNum":"  872","line":"        .macos, .ios, .watchos, .tvos => math.maxInt(i32),"},
{"lineNum":"  873","line":"        else => math.maxInt(isize),"},
{"lineNum":"  874","line":"    };"},
{"lineNum":"  875","line":"    const adjusted_len = @min(max_count, buf.len);"},
{"lineNum":"  876","line":""},
{"lineNum":"  877","line":"    const pread_sym = if (lfs64_abi) system.pread64 else system.pread;"},
{"lineNum":"  878","line":""},
{"lineNum":"  879","line":"    const ioffset = @as(i64, @bitCast(offset)); // the OS treats this as unsigned"},
{"lineNum":"  880","line":"    while (true) {"},
{"lineNum":"  881","line":"        const rc = pread_sym(fd, buf.ptr, adjusted_len, ioffset);"},
{"lineNum":"  882","line":"        switch (errno(rc)) {"},
{"lineNum":"  883","line":"            .SUCCESS => return @as(usize, @intCast(rc)),"},
{"lineNum":"  884","line":"            .INTR => continue,"},
{"lineNum":"  885","line":"            .INVAL => unreachable,"},
{"lineNum":"  886","line":"            .FAULT => unreachable,"},
{"lineNum":"  887","line":"            .AGAIN => return error.WouldBlock,"},
{"lineNum":"  888","line":"            .BADF => return error.NotOpenForReading, // Can be a race condition."},
{"lineNum":"  889","line":"            .IO => return error.InputOutput,"},
{"lineNum":"  890","line":"            .ISDIR => return error.IsDir,"},
{"lineNum":"  891","line":"            .NOBUFS => return error.SystemResources,"},
{"lineNum":"  892","line":"            .NOMEM => return error.SystemResources,"},
{"lineNum":"  893","line":"            .CONNRESET => return error.ConnectionResetByPeer,"},
{"lineNum":"  894","line":"            .NXIO => return error.Unseekable,"},
{"lineNum":"  895","line":"            .SPIPE => return error.Unseekable,"},
{"lineNum":"  896","line":"            .OVERFLOW => return error.Unseekable,"},
{"lineNum":"  897","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":"  898","line":"        }"},
{"lineNum":"  899","line":"    }"},
{"lineNum":"  900","line":"}"},
{"lineNum":"  901","line":""},
{"lineNum":"  902","line":"pub const TruncateError = error{"},
{"lineNum":"  903","line":"    FileTooBig,"},
{"lineNum":"  904","line":"    InputOutput,"},
{"lineNum":"  905","line":"    FileBusy,"},
{"lineNum":"  906","line":""},
{"lineNum":"  907","line":"    /// In WASI, this error occurs when the file descriptor does"},
{"lineNum":"  908","line":"    /// not hold the required rights to call `ftruncate` on it."},
{"lineNum":"  909","line":"    AccessDenied,"},
{"lineNum":"  910","line":"} || UnexpectedError;"},
{"lineNum":"  911","line":""},
{"lineNum":"  912","line":"pub fn ftruncate(fd: fd_t, length: u64) TruncateError!void {"},
{"lineNum":"  913","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":"  914","line":"        var io_status_block: windows.IO_STATUS_BLOCK = undefined;"},
{"lineNum":"  915","line":"        var eof_info = windows.FILE_END_OF_FILE_INFORMATION{"},
{"lineNum":"  916","line":"            .EndOfFile = @as(windows.LARGE_INTEGER, @bitCast(length)),"},
{"lineNum":"  917","line":"        };"},
{"lineNum":"  918","line":""},
{"lineNum":"  919","line":"        const rc = windows.ntdll.NtSetInformationFile("},
{"lineNum":"  920","line":"            fd,"},
{"lineNum":"  921","line":"            &io_status_block,"},
{"lineNum":"  922","line":"            &eof_info,"},
{"lineNum":"  923","line":"            @sizeOf(windows.FILE_END_OF_FILE_INFORMATION),"},
{"lineNum":"  924","line":"            .FileEndOfFileInformation,"},
{"lineNum":"  925","line":"        );"},
{"lineNum":"  926","line":""},
{"lineNum":"  927","line":"        switch (rc) {"},
{"lineNum":"  928","line":"            .SUCCESS => return,"},
{"lineNum":"  929","line":"            .INVALID_HANDLE => unreachable, // Handle not open for writing"},
{"lineNum":"  930","line":"            .ACCESS_DENIED => return error.AccessDenied,"},
{"lineNum":"  931","line":"            else => return windows.unexpectedStatus(rc),"},
{"lineNum":"  932","line":"        }"},
{"lineNum":"  933","line":"    }"},
{"lineNum":"  934","line":"    if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":"  935","line":"        switch (wasi.fd_filestat_set_size(fd, length)) {"},
{"lineNum":"  936","line":"            .SUCCESS => return,"},
{"lineNum":"  937","line":"            .INTR => unreachable,"},
{"lineNum":"  938","line":"            .FBIG => return error.FileTooBig,"},
{"lineNum":"  939","line":"            .IO => return error.InputOutput,"},
{"lineNum":"  940","line":"            .PERM => return error.AccessDenied,"},
{"lineNum":"  941","line":"            .TXTBSY => return error.FileBusy,"},
{"lineNum":"  942","line":"            .BADF => unreachable, // Handle not open for writing"},
{"lineNum":"  943","line":"            .INVAL => unreachable, // Handle not open for writing"},
{"lineNum":"  944","line":"            .NOTCAPABLE => return error.AccessDenied,"},
{"lineNum":"  945","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":"  946","line":"        }"},
{"lineNum":"  947","line":"    }"},
{"lineNum":"  948","line":""},
{"lineNum":"  949","line":"    while (true) {"},
{"lineNum":"  950","line":"        const ftruncate_sym = if (lfs64_abi) system.ftruncate64 else system.ftruncate;"},
{"lineNum":"  951","line":""},
{"lineNum":"  952","line":"        const ilen = @as(i64, @bitCast(length)); // the OS treats this as unsigned"},
{"lineNum":"  953","line":"        switch (errno(ftruncate_sym(fd, ilen))) {"},
{"lineNum":"  954","line":"            .SUCCESS => return,"},
{"lineNum":"  955","line":"            .INTR => continue,"},
{"lineNum":"  956","line":"            .FBIG => return error.FileTooBig,"},
{"lineNum":"  957","line":"            .IO => return error.InputOutput,"},
{"lineNum":"  958","line":"            .PERM => return error.AccessDenied,"},
{"lineNum":"  959","line":"            .TXTBSY => return error.FileBusy,"},
{"lineNum":"  960","line":"            .BADF => unreachable, // Handle not open for writing"},
{"lineNum":"  961","line":"            .INVAL => unreachable, // Handle not open for writing"},
{"lineNum":"  962","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":"  963","line":"        }"},
{"lineNum":"  964","line":"    }"},
{"lineNum":"  965","line":"}"},
{"lineNum":"  966","line":""},
{"lineNum":"  967","line":"/// Number of bytes read is returned. Upon reading end-of-file, zero is returned."},
{"lineNum":"  968","line":"///"},
{"lineNum":"  969","line":"/// Retries when interrupted by a signal."},
{"lineNum":"  970","line":"///"},
{"lineNum":"  971","line":"/// For POSIX systems, if `fd` is opened in non blocking mode, the function will"},
{"lineNum":"  972","line":"/// return error.WouldBlock when EAGAIN is received."},
{"lineNum":"  973","line":"/// On Windows, if the application has a global event loop enabled, I/O Completion Ports are"},
{"lineNum":"  974","line":"/// used to perform the I/O. `error.WouldBlock` is not possible on Windows."},
{"lineNum":"  975","line":"///"},
{"lineNum":"  976","line":"/// This operation is non-atomic on the following systems:"},
{"lineNum":"  977","line":"/// * Darwin"},
{"lineNum":"  978","line":"/// * Windows"},
{"lineNum":"  979","line":"/// On these systems, the read races with concurrent writes to the same file descriptor."},
{"lineNum":"  980","line":"pub fn preadv(fd: fd_t, iov: []const iovec, offset: u64) PReadError!usize {"},
{"lineNum":"  981","line":"    const have_pread_but_not_preadv = switch (builtin.os.tag) {"},
{"lineNum":"  982","line":"        .windows, .macos, .ios, .watchos, .tvos, .haiku => true,"},
{"lineNum":"  983","line":"        else => false,"},
{"lineNum":"  984","line":"    };"},
{"lineNum":"  985","line":"    if (have_pread_but_not_preadv) {"},
{"lineNum":"  986","line":"        // We could loop here; but proper usage of `preadv` must handle partial reads anyway."},
{"lineNum":"  987","line":"        // So we simply read into the first vector only."},
{"lineNum":"  988","line":"        if (iov.len == 0) return 0;"},
{"lineNum":"  989","line":"        const first = iov[0];"},
{"lineNum":"  990","line":"        return pread(fd, first.iov_base[0..first.iov_len], offset);"},
{"lineNum":"  991","line":"    }"},
{"lineNum":"  992","line":"    if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":"  993","line":"        var nread: usize = undefined;"},
{"lineNum":"  994","line":"        switch (wasi.fd_pread(fd, iov.ptr, iov.len, offset, &nread)) {"},
{"lineNum":"  995","line":"            .SUCCESS => return nread,"},
{"lineNum":"  996","line":"            .INTR => unreachable,"},
{"lineNum":"  997","line":"            .INVAL => unreachable,"},
{"lineNum":"  998","line":"            .FAULT => unreachable,"},
{"lineNum":"  999","line":"            .AGAIN => unreachable,"},
{"lineNum":" 1000","line":"            .BADF => return error.NotOpenForReading, // can be a race condition"},
{"lineNum":" 1001","line":"            .IO => return error.InputOutput,"},
{"lineNum":" 1002","line":"            .ISDIR => return error.IsDir,"},
{"lineNum":" 1003","line":"            .NOBUFS => return error.SystemResources,"},
{"lineNum":" 1004","line":"            .NOMEM => return error.SystemResources,"},
{"lineNum":" 1005","line":"            .NXIO => return error.Unseekable,"},
{"lineNum":" 1006","line":"            .SPIPE => return error.Unseekable,"},
{"lineNum":" 1007","line":"            .OVERFLOW => return error.Unseekable,"},
{"lineNum":" 1008","line":"            .NOTCAPABLE => return error.AccessDenied,"},
{"lineNum":" 1009","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 1010","line":"        }"},
{"lineNum":" 1011","line":"    }"},
{"lineNum":" 1012","line":""},
{"lineNum":" 1013","line":"    const iov_count = math.cast(u31, iov.len) orelse math.maxInt(u31);"},
{"lineNum":" 1014","line":""},
{"lineNum":" 1015","line":"    const preadv_sym = if (lfs64_abi) system.preadv64 else system.preadv;"},
{"lineNum":" 1016","line":""},
{"lineNum":" 1017","line":"    const ioffset = @as(i64, @bitCast(offset)); // the OS treats this as unsigned"},
{"lineNum":" 1018","line":"    while (true) {"},
{"lineNum":" 1019","line":"        const rc = preadv_sym(fd, iov.ptr, iov_count, ioffset);"},
{"lineNum":" 1020","line":"        switch (errno(rc)) {"},
{"lineNum":" 1021","line":"            .SUCCESS => return @as(usize, @bitCast(rc)),"},
{"lineNum":" 1022","line":"            .INTR => continue,"},
{"lineNum":" 1023","line":"            .INVAL => unreachable,"},
{"lineNum":" 1024","line":"            .FAULT => unreachable,"},
{"lineNum":" 1025","line":"            .AGAIN => return error.WouldBlock,"},
{"lineNum":" 1026","line":"            .BADF => return error.NotOpenForReading, // can be a race condition"},
{"lineNum":" 1027","line":"            .IO => return error.InputOutput,"},
{"lineNum":" 1028","line":"            .ISDIR => return error.IsDir,"},
{"lineNum":" 1029","line":"            .NOBUFS => return error.SystemResources,"},
{"lineNum":" 1030","line":"            .NOMEM => return error.SystemResources,"},
{"lineNum":" 1031","line":"            .NXIO => return error.Unseekable,"},
{"lineNum":" 1032","line":"            .SPIPE => return error.Unseekable,"},
{"lineNum":" 1033","line":"            .OVERFLOW => return error.Unseekable,"},
{"lineNum":" 1034","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 1035","line":"        }"},
{"lineNum":" 1036","line":"    }"},
{"lineNum":" 1037","line":"}"},
{"lineNum":" 1038","line":""},
{"lineNum":" 1039","line":"pub const WriteError = error{"},
{"lineNum":" 1040","line":"    DiskQuota,"},
{"lineNum":" 1041","line":"    FileTooBig,"},
{"lineNum":" 1042","line":"    InputOutput,"},
{"lineNum":" 1043","line":"    NoSpaceLeft,"},
{"lineNum":" 1044","line":"    DeviceBusy,"},
{"lineNum":" 1045","line":"    InvalidArgument,"},
{"lineNum":" 1046","line":""},
{"lineNum":" 1047","line":"    /// In WASI, this error may occur when the file descriptor does"},
{"lineNum":" 1048","line":"    /// not hold the required rights to write to it."},
{"lineNum":" 1049","line":"    AccessDenied,"},
{"lineNum":" 1050","line":"    BrokenPipe,"},
{"lineNum":" 1051","line":"    SystemResources,"},
{"lineNum":" 1052","line":"    OperationAborted,"},
{"lineNum":" 1053","line":"    NotOpenForWriting,"},
{"lineNum":" 1054","line":""},
{"lineNum":" 1055","line":"    /// The process cannot access the file because another process has locked"},
{"lineNum":" 1056","line":"    /// a portion of the file. Windows-only."},
{"lineNum":" 1057","line":"    LockViolation,"},
{"lineNum":" 1058","line":""},
{"lineNum":" 1059","line":"    /// This error occurs when no global event loop is configured,"},
{"lineNum":" 1060","line":"    /// and reading from the file descriptor would block."},
{"lineNum":" 1061","line":"    WouldBlock,"},
{"lineNum":" 1062","line":""},
{"lineNum":" 1063","line":"    /// Connection reset by peer."},
{"lineNum":" 1064","line":"    ConnectionResetByPeer,"},
{"lineNum":" 1065","line":"} || UnexpectedError;"},
{"lineNum":" 1066","line":""},
{"lineNum":" 1067","line":"/// Write to a file descriptor."},
{"lineNum":" 1068","line":"/// Retries when interrupted by a signal."},
{"lineNum":" 1069","line":"/// Returns the number of bytes written. If nonzero bytes were supplied, this will be nonzero."},
{"lineNum":" 1070","line":"///"},
{"lineNum":" 1071","line":"/// Note that a successful write() may transfer fewer than count bytes.  Such partial  writes  can"},
{"lineNum":" 1072","line":"/// occur  for  various reasons; for example, because there was insufficient space on the disk"},
{"lineNum":" 1073","line":"/// device to write all of the requested bytes, or because a blocked write() to a socket,  pipe,  or"},
{"lineNum":" 1074","line":"/// similar  was  interrupted by a signal handler after it had transferred some, but before it had"},
{"lineNum":" 1075","line":"/// transferred all of the requested bytes.  In the event of a partial write, the caller can  make"},
{"lineNum":" 1076","line":"/// another  write() call to transfer the remaining bytes.  The subsequent call will either"},
{"lineNum":" 1077","line":"/// transfer further bytes or may result in an error (e.g., if the disk is now full)."},
{"lineNum":" 1078","line":"///"},
{"lineNum":" 1079","line":"/// For POSIX systems, if `fd` is opened in non blocking mode, the function will"},
{"lineNum":" 1080","line":"/// return error.WouldBlock when EAGAIN is received."},
{"lineNum":" 1081","line":"/// On Windows, if the application has a global event loop enabled, I/O Completion Ports are"},
{"lineNum":" 1082","line":"/// used to perform the I/O. `error.WouldBlock` is not possible on Windows."},
{"lineNum":" 1083","line":"///"},
{"lineNum":" 1084","line":"/// Linux has a limit on how many bytes may be transferred in one `write` call, which is `0x7ffff000`"},
{"lineNum":" 1085","line":"/// on both 64-bit and 32-bit systems. This is due to using a signed C int as the return value, as"},
{"lineNum":" 1086","line":"/// well as stuffing the errno codes into the last `4096` values. This is noted on the `write` man page."},
{"lineNum":" 1087","line":"/// The limit on Darwin is `0x7fffffff`, trying to read more than that returns EINVAL."},
{"lineNum":" 1088","line":"/// The corresponding POSIX limit is `math.maxInt(isize)`."},
{"lineNum":" 1089","line":"pub fn write(fd: fd_t, bytes: []const u8) WriteError!usize {","class":"lineCov","hits":"1","order":"684","possible_hits":"1",},
{"lineNum":" 1090","line":"    if (bytes.len == 0) return 0;","class":"linePartCov","hits":"1","order":"685","possible_hits":"2",},
{"lineNum":" 1091","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 1092","line":"        return windows.WriteFile(fd, bytes, null, std.io.default_mode);"},
{"lineNum":" 1093","line":"    }"},
{"lineNum":" 1094","line":""},
{"lineNum":" 1095","line":"    if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 1096","line":"        const ciovs = [_]iovec_const{iovec_const{"},
{"lineNum":" 1097","line":"            .iov_base = bytes.ptr,"},
{"lineNum":" 1098","line":"            .iov_len = bytes.len,"},
{"lineNum":" 1099","line":"        }};"},
{"lineNum":" 1100","line":"        var nwritten: usize = undefined;"},
{"lineNum":" 1101","line":"        switch (wasi.fd_write(fd, &ciovs, ciovs.len, &nwritten)) {"},
{"lineNum":" 1102","line":"            .SUCCESS => return nwritten,"},
{"lineNum":" 1103","line":"            .INTR => unreachable,"},
{"lineNum":" 1104","line":"            .INVAL => unreachable,"},
{"lineNum":" 1105","line":"            .FAULT => unreachable,"},
{"lineNum":" 1106","line":"            .AGAIN => unreachable,"},
{"lineNum":" 1107","line":"            .BADF => return error.NotOpenForWriting, // can be a race condition."},
{"lineNum":" 1108","line":"            .DESTADDRREQ => unreachable, // `connect` was never called."},
{"lineNum":" 1109","line":"            .DQUOT => return error.DiskQuota,"},
{"lineNum":" 1110","line":"            .FBIG => return error.FileTooBig,"},
{"lineNum":" 1111","line":"            .IO => return error.InputOutput,"},
{"lineNum":" 1112","line":"            .NOSPC => return error.NoSpaceLeft,"},
{"lineNum":" 1113","line":"            .PERM => return error.AccessDenied,"},
{"lineNum":" 1114","line":"            .PIPE => return error.BrokenPipe,"},
{"lineNum":" 1115","line":"            .NOTCAPABLE => return error.AccessDenied,"},
{"lineNum":" 1116","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 1117","line":"        }"},
{"lineNum":" 1118","line":"    }"},
{"lineNum":" 1119","line":""},
{"lineNum":" 1120","line":"    const max_count = switch (builtin.os.tag) {"},
{"lineNum":" 1121","line":"        .linux => 0x7ffff000,"},
{"lineNum":" 1122","line":"        .macos, .ios, .watchos, .tvos => math.maxInt(i32),"},
{"lineNum":" 1123","line":"        else => math.maxInt(isize),"},
{"lineNum":" 1124","line":"    };"},
{"lineNum":" 1125","line":"    const adjusted_len = @min(max_count, bytes.len);","class":"lineCov","hits":"1","order":"686","possible_hits":"1",},
{"lineNum":" 1126","line":""},
{"lineNum":" 1127","line":"    while (true) {"},
{"lineNum":" 1128","line":"        const rc = system.write(fd, bytes.ptr, adjusted_len);","class":"lineCov","hits":"1","order":"687","possible_hits":"1",},
{"lineNum":" 1129","line":"        switch (errno(rc)) {","class":"lineCov","hits":"1","order":"690","possible_hits":"1",},
{"lineNum":" 1130","line":"            .SUCCESS => return @as(usize, @intCast(rc)),","class":"lineCov","hits":"1","order":"691","possible_hits":"1",},
{"lineNum":" 1131","line":"            .INTR => continue,"},
{"lineNum":" 1132","line":"            .INVAL => return error.InvalidArgument,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1133","line":"            .FAULT => unreachable,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1134","line":"            .AGAIN => return error.WouldBlock,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1135","line":"            .BADF => return error.NotOpenForWriting, // can be a race condition.","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1136","line":"            .DESTADDRREQ => unreachable, // `connect` was never called.","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1137","line":"            .DQUOT => return error.DiskQuota,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1138","line":"            .FBIG => return error.FileTooBig,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1139","line":"            .IO => return error.InputOutput,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1140","line":"            .NOSPC => return error.NoSpaceLeft,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1141","line":"            .PERM => return error.AccessDenied,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1142","line":"            .PIPE => return error.BrokenPipe,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1143","line":"            .CONNRESET => return error.ConnectionResetByPeer,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1144","line":"            .BUSY => return error.DeviceBusy,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1145","line":"            else => |err| return unexpectedErrno(err),","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1146","line":"        }"},
{"lineNum":" 1147","line":"    }"},
{"lineNum":" 1148","line":"}"},
{"lineNum":" 1149","line":""},
{"lineNum":" 1150","line":"/// Write multiple buffers to a file descriptor."},
{"lineNum":" 1151","line":"/// Retries when interrupted by a signal."},
{"lineNum":" 1152","line":"/// Returns the number of bytes written. If nonzero bytes were supplied, this will be nonzero."},
{"lineNum":" 1153","line":"///"},
{"lineNum":" 1154","line":"/// Note that a successful write() may transfer fewer bytes than supplied.  Such partial  writes  can"},
{"lineNum":" 1155","line":"/// occur  for  various reasons; for example, because there was insufficient space on the disk"},
{"lineNum":" 1156","line":"/// device to write all of the requested bytes, or because a blocked write() to a socket,  pipe,  or"},
{"lineNum":" 1157","line":"/// similar  was  interrupted by a signal handler after it had transferred some, but before it had"},
{"lineNum":" 1158","line":"/// transferred all of the requested bytes.  In the event of a partial write, the caller can  make"},
{"lineNum":" 1159","line":"/// another  write() call to transfer the remaining bytes.  The subsequent call will either"},
{"lineNum":" 1160","line":"/// transfer further bytes or may result in an error (e.g., if the disk is now full)."},
{"lineNum":" 1161","line":"///"},
{"lineNum":" 1162","line":"/// For POSIX systems, if `fd` is opened in non blocking mode, the function will"},
{"lineNum":" 1163","line":"/// return error.WouldBlock when EAGAIN is received."},
{"lineNum":" 1164","line":"/// On Windows, if the application has a global event loop enabled, I/O Completion Ports are"},
{"lineNum":" 1165","line":"/// used to perform the I/O. `error.WouldBlock` is not possible on Windows."},
{"lineNum":" 1166","line":"///"},
{"lineNum":" 1167","line":"/// If `iov.len` is larger than `IOV_MAX`, a partial write will occur."},
{"lineNum":" 1168","line":"///"},
{"lineNum":" 1169","line":"/// This function assumes that all vectors, including zero-length vectors, have"},
{"lineNum":" 1170","line":"/// a pointer within the address space of the application."},
{"lineNum":" 1171","line":"pub fn writev(fd: fd_t, iov: []const iovec_const) WriteError!usize {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1172","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 1173","line":"        // TODO improve this to use WriteFileScatter"},
{"lineNum":" 1174","line":"        if (iov.len == 0) return @as(usize, 0);"},
{"lineNum":" 1175","line":"        const first = iov[0];"},
{"lineNum":" 1176","line":"        return write(fd, first.iov_base[0..first.iov_len]);"},
{"lineNum":" 1177","line":"    }"},
{"lineNum":" 1178","line":"    if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 1179","line":"        var nwritten: usize = undefined;"},
{"lineNum":" 1180","line":"        switch (wasi.fd_write(fd, iov.ptr, iov.len, &nwritten)) {"},
{"lineNum":" 1181","line":"            .SUCCESS => return nwritten,"},
{"lineNum":" 1182","line":"            .INTR => unreachable,"},
{"lineNum":" 1183","line":"            .INVAL => unreachable,"},
{"lineNum":" 1184","line":"            .FAULT => unreachable,"},
{"lineNum":" 1185","line":"            .AGAIN => unreachable,"},
{"lineNum":" 1186","line":"            .BADF => return error.NotOpenForWriting, // can be a race condition."},
{"lineNum":" 1187","line":"            .DESTADDRREQ => unreachable, // `connect` was never called."},
{"lineNum":" 1188","line":"            .DQUOT => return error.DiskQuota,"},
{"lineNum":" 1189","line":"            .FBIG => return error.FileTooBig,"},
{"lineNum":" 1190","line":"            .IO => return error.InputOutput,"},
{"lineNum":" 1191","line":"            .NOSPC => return error.NoSpaceLeft,"},
{"lineNum":" 1192","line":"            .PERM => return error.AccessDenied,"},
{"lineNum":" 1193","line":"            .PIPE => return error.BrokenPipe,"},
{"lineNum":" 1194","line":"            .NOTCAPABLE => return error.AccessDenied,"},
{"lineNum":" 1195","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 1196","line":"        }"},
{"lineNum":" 1197","line":"    }"},
{"lineNum":" 1198","line":""},
{"lineNum":" 1199","line":"    const iov_count = if (iov.len > IOV_MAX) IOV_MAX else @as(u31, @intCast(iov.len));","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1200","line":"    while (true) {"},
{"lineNum":" 1201","line":"        const rc = system.writev(fd, iov.ptr, iov_count);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1202","line":"        switch (errno(rc)) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1203","line":"            .SUCCESS => return @as(usize, @intCast(rc)),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1204","line":"            .INTR => continue,"},
{"lineNum":" 1205","line":"            .INVAL => return error.InvalidArgument,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1206","line":"            .FAULT => unreachable,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1207","line":"            .AGAIN => return error.WouldBlock,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1208","line":"            .BADF => return error.NotOpenForWriting, // Can be a race condition.","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1209","line":"            .DESTADDRREQ => unreachable, // `connect` was never called.","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1210","line":"            .DQUOT => return error.DiskQuota,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1211","line":"            .FBIG => return error.FileTooBig,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1212","line":"            .IO => return error.InputOutput,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1213","line":"            .NOSPC => return error.NoSpaceLeft,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1214","line":"            .PERM => return error.AccessDenied,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1215","line":"            .PIPE => return error.BrokenPipe,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1216","line":"            .CONNRESET => return error.ConnectionResetByPeer,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1217","line":"            .BUSY => return error.DeviceBusy,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1218","line":"            else => |err| return unexpectedErrno(err),","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1219","line":"        }"},
{"lineNum":" 1220","line":"    }"},
{"lineNum":" 1221","line":"}"},
{"lineNum":" 1222","line":""},
{"lineNum":" 1223","line":"pub const PWriteError = WriteError || error{Unseekable};"},
{"lineNum":" 1224","line":""},
{"lineNum":" 1225","line":"/// Write to a file descriptor, with a position offset."},
{"lineNum":" 1226","line":"/// Retries when interrupted by a signal."},
{"lineNum":" 1227","line":"/// Returns the number of bytes written. If nonzero bytes were supplied, this will be nonzero."},
{"lineNum":" 1228","line":"///"},
{"lineNum":" 1229","line":"/// Note that a successful write() may transfer fewer bytes than supplied.  Such partial  writes  can"},
{"lineNum":" 1230","line":"/// occur  for  various reasons; for example, because there was insufficient space on the disk"},
{"lineNum":" 1231","line":"/// device to write all of the requested bytes, or because a blocked write() to a socket,  pipe,  or"},
{"lineNum":" 1232","line":"/// similar  was  interrupted by a signal handler after it had transferred some, but before it had"},
{"lineNum":" 1233","line":"/// transferred all of the requested bytes.  In the event of a partial write, the caller can  make"},
{"lineNum":" 1234","line":"/// another  write() call to transfer the remaining bytes.  The subsequent call will either"},
{"lineNum":" 1235","line":"/// transfer further bytes or may result in an error (e.g., if the disk is now full)."},
{"lineNum":" 1236","line":"///"},
{"lineNum":" 1237","line":"/// For POSIX systems, if `fd` is opened in non blocking mode, the function will"},
{"lineNum":" 1238","line":"/// return error.WouldBlock when EAGAIN is received."},
{"lineNum":" 1239","line":"/// On Windows, if the application has a global event loop enabled, I/O Completion Ports are"},
{"lineNum":" 1240","line":"/// used to perform the I/O. `error.WouldBlock` is not possible on Windows."},
{"lineNum":" 1241","line":"///"},
{"lineNum":" 1242","line":"/// Linux has a limit on how many bytes may be transferred in one `pwrite` call, which is `0x7ffff000`"},
{"lineNum":" 1243","line":"/// on both 64-bit and 32-bit systems. This is due to using a signed C int as the return value, as"},
{"lineNum":" 1244","line":"/// well as stuffing the errno codes into the last `4096` values. This is noted on the `write` man page."},
{"lineNum":" 1245","line":"/// The limit on Darwin is `0x7fffffff`, trying to write more than that returns EINVAL."},
{"lineNum":" 1246","line":"/// The corresponding POSIX limit is `math.maxInt(isize)`."},
{"lineNum":" 1247","line":"pub fn pwrite(fd: fd_t, bytes: []const u8, offset: u64) PWriteError!usize {"},
{"lineNum":" 1248","line":"    if (bytes.len == 0) return 0;"},
{"lineNum":" 1249","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 1250","line":"        return windows.WriteFile(fd, bytes, offset, std.io.default_mode);"},
{"lineNum":" 1251","line":"    }"},
{"lineNum":" 1252","line":"    if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 1253","line":"        const ciovs = [1]iovec_const{iovec_const{"},
{"lineNum":" 1254","line":"            .iov_base = bytes.ptr,"},
{"lineNum":" 1255","line":"            .iov_len = bytes.len,"},
{"lineNum":" 1256","line":"        }};"},
{"lineNum":" 1257","line":""},
{"lineNum":" 1258","line":"        var nwritten: usize = undefined;"},
{"lineNum":" 1259","line":"        switch (wasi.fd_pwrite(fd, &ciovs, ciovs.len, offset, &nwritten)) {"},
{"lineNum":" 1260","line":"            .SUCCESS => return nwritten,"},
{"lineNum":" 1261","line":"            .INTR => unreachable,"},
{"lineNum":" 1262","line":"            .INVAL => unreachable,"},
{"lineNum":" 1263","line":"            .FAULT => unreachable,"},
{"lineNum":" 1264","line":"            .AGAIN => unreachable,"},
{"lineNum":" 1265","line":"            .BADF => return error.NotOpenForWriting, // can be a race condition."},
{"lineNum":" 1266","line":"            .DESTADDRREQ => unreachable, // `connect` was never called."},
{"lineNum":" 1267","line":"            .DQUOT => return error.DiskQuota,"},
{"lineNum":" 1268","line":"            .FBIG => return error.FileTooBig,"},
{"lineNum":" 1269","line":"            .IO => return error.InputOutput,"},
{"lineNum":" 1270","line":"            .NOSPC => return error.NoSpaceLeft,"},
{"lineNum":" 1271","line":"            .PERM => return error.AccessDenied,"},
{"lineNum":" 1272","line":"            .PIPE => return error.BrokenPipe,"},
{"lineNum":" 1273","line":"            .NXIO => return error.Unseekable,"},
{"lineNum":" 1274","line":"            .SPIPE => return error.Unseekable,"},
{"lineNum":" 1275","line":"            .OVERFLOW => return error.Unseekable,"},
{"lineNum":" 1276","line":"            .NOTCAPABLE => return error.AccessDenied,"},
{"lineNum":" 1277","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 1278","line":"        }"},
{"lineNum":" 1279","line":"    }"},
{"lineNum":" 1280","line":""},
{"lineNum":" 1281","line":"    // Prevent EINVAL."},
{"lineNum":" 1282","line":"    const max_count = switch (builtin.os.tag) {"},
{"lineNum":" 1283","line":"        .linux => 0x7ffff000,"},
{"lineNum":" 1284","line":"        .macos, .ios, .watchos, .tvos => math.maxInt(i32),"},
{"lineNum":" 1285","line":"        else => math.maxInt(isize),"},
{"lineNum":" 1286","line":"    };"},
{"lineNum":" 1287","line":"    const adjusted_len = @min(max_count, bytes.len);"},
{"lineNum":" 1288","line":""},
{"lineNum":" 1289","line":"    const pwrite_sym = if (lfs64_abi) system.pwrite64 else system.pwrite;"},
{"lineNum":" 1290","line":""},
{"lineNum":" 1291","line":"    const ioffset = @as(i64, @bitCast(offset)); // the OS treats this as unsigned"},
{"lineNum":" 1292","line":"    while (true) {"},
{"lineNum":" 1293","line":"        const rc = pwrite_sym(fd, bytes.ptr, adjusted_len, ioffset);"},
{"lineNum":" 1294","line":"        switch (errno(rc)) {"},
{"lineNum":" 1295","line":"            .SUCCESS => return @as(usize, @intCast(rc)),"},
{"lineNum":" 1296","line":"            .INTR => continue,"},
{"lineNum":" 1297","line":"            .INVAL => return error.InvalidArgument,"},
{"lineNum":" 1298","line":"            .FAULT => unreachable,"},
{"lineNum":" 1299","line":"            .AGAIN => return error.WouldBlock,"},
{"lineNum":" 1300","line":"            .BADF => return error.NotOpenForWriting, // Can be a race condition."},
{"lineNum":" 1301","line":"            .DESTADDRREQ => unreachable, // `connect` was never called."},
{"lineNum":" 1302","line":"            .DQUOT => return error.DiskQuota,"},
{"lineNum":" 1303","line":"            .FBIG => return error.FileTooBig,"},
{"lineNum":" 1304","line":"            .IO => return error.InputOutput,"},
{"lineNum":" 1305","line":"            .NOSPC => return error.NoSpaceLeft,"},
{"lineNum":" 1306","line":"            .PERM => return error.AccessDenied,"},
{"lineNum":" 1307","line":"            .PIPE => return error.BrokenPipe,"},
{"lineNum":" 1308","line":"            .NXIO => return error.Unseekable,"},
{"lineNum":" 1309","line":"            .SPIPE => return error.Unseekable,"},
{"lineNum":" 1310","line":"            .OVERFLOW => return error.Unseekable,"},
{"lineNum":" 1311","line":"            .BUSY => return error.DeviceBusy,"},
{"lineNum":" 1312","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 1313","line":"        }"},
{"lineNum":" 1314","line":"    }"},
{"lineNum":" 1315","line":"}"},
{"lineNum":" 1316","line":""},
{"lineNum":" 1317","line":"/// Write multiple buffers to a file descriptor, with a position offset."},
{"lineNum":" 1318","line":"/// Retries when interrupted by a signal."},
{"lineNum":" 1319","line":"/// Returns the number of bytes written. If nonzero bytes were supplied, this will be nonzero."},
{"lineNum":" 1320","line":"///"},
{"lineNum":" 1321","line":"/// Note that a successful write() may transfer fewer than count bytes.  Such partial  writes  can"},
{"lineNum":" 1322","line":"/// occur  for  various reasons; for example, because there was insufficient space on the disk"},
{"lineNum":" 1323","line":"/// device to write all of the requested bytes, or because a blocked write() to a socket,  pipe,  or"},
{"lineNum":" 1324","line":"/// similar  was  interrupted by a signal handler after it had transferred some, but before it had"},
{"lineNum":" 1325","line":"/// transferred all of the requested bytes.  In the event of a partial write, the caller can  make"},
{"lineNum":" 1326","line":"/// another  write() call to transfer the remaining bytes.  The subsequent call will either"},
{"lineNum":" 1327","line":"/// transfer further bytes or may result in an error (e.g., if the disk is now full)."},
{"lineNum":" 1328","line":"///"},
{"lineNum":" 1329","line":"/// If `fd` is opened in non blocking mode, the function will"},
{"lineNum":" 1330","line":"/// return error.WouldBlock when EAGAIN is received."},
{"lineNum":" 1331","line":"///"},
{"lineNum":" 1332","line":"/// The following systems do not have this syscall, and will return partial writes if more than one"},
{"lineNum":" 1333","line":"/// vector is provided:"},
{"lineNum":" 1334","line":"/// * Darwin"},
{"lineNum":" 1335","line":"/// * Windows"},
{"lineNum":" 1336","line":"///"},
{"lineNum":" 1337","line":"/// If `iov.len` is larger than `IOV_MAX`, a partial write will occur."},
{"lineNum":" 1338","line":"pub fn pwritev(fd: fd_t, iov: []const iovec_const, offset: u64) PWriteError!usize {"},
{"lineNum":" 1339","line":"    const have_pwrite_but_not_pwritev = switch (builtin.os.tag) {"},
{"lineNum":" 1340","line":"        .windows, .macos, .ios, .watchos, .tvos, .haiku => true,"},
{"lineNum":" 1341","line":"        else => false,"},
{"lineNum":" 1342","line":"    };"},
{"lineNum":" 1343","line":""},
{"lineNum":" 1344","line":"    if (have_pwrite_but_not_pwritev) {"},
{"lineNum":" 1345","line":"        // We could loop here; but proper usage of `pwritev` must handle partial writes anyway."},
{"lineNum":" 1346","line":"        // So we simply write the first vector only."},
{"lineNum":" 1347","line":"        if (iov.len == 0) return @as(usize, 0);"},
{"lineNum":" 1348","line":"        const first = iov[0];"},
{"lineNum":" 1349","line":"        return pwrite(fd, first.iov_base[0..first.iov_len], offset);"},
{"lineNum":" 1350","line":"    }"},
{"lineNum":" 1351","line":"    if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 1352","line":"        var nwritten: usize = undefined;"},
{"lineNum":" 1353","line":"        switch (wasi.fd_pwrite(fd, iov.ptr, iov.len, offset, &nwritten)) {"},
{"lineNum":" 1354","line":"            .SUCCESS => return nwritten,"},
{"lineNum":" 1355","line":"            .INTR => unreachable,"},
{"lineNum":" 1356","line":"            .INVAL => unreachable,"},
{"lineNum":" 1357","line":"            .FAULT => unreachable,"},
{"lineNum":" 1358","line":"            .AGAIN => unreachable,"},
{"lineNum":" 1359","line":"            .BADF => return error.NotOpenForWriting, // Can be a race condition."},
{"lineNum":" 1360","line":"            .DESTADDRREQ => unreachable, // `connect` was never called."},
{"lineNum":" 1361","line":"            .DQUOT => return error.DiskQuota,"},
{"lineNum":" 1362","line":"            .FBIG => return error.FileTooBig,"},
{"lineNum":" 1363","line":"            .IO => return error.InputOutput,"},
{"lineNum":" 1364","line":"            .NOSPC => return error.NoSpaceLeft,"},
{"lineNum":" 1365","line":"            .PERM => return error.AccessDenied,"},
{"lineNum":" 1366","line":"            .PIPE => return error.BrokenPipe,"},
{"lineNum":" 1367","line":"            .NXIO => return error.Unseekable,"},
{"lineNum":" 1368","line":"            .SPIPE => return error.Unseekable,"},
{"lineNum":" 1369","line":"            .OVERFLOW => return error.Unseekable,"},
{"lineNum":" 1370","line":"            .NOTCAPABLE => return error.AccessDenied,"},
{"lineNum":" 1371","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 1372","line":"        }"},
{"lineNum":" 1373","line":"    }"},
{"lineNum":" 1374","line":""},
{"lineNum":" 1375","line":"    const pwritev_sym = if (lfs64_abi) system.pwritev64 else system.pwritev;"},
{"lineNum":" 1376","line":""},
{"lineNum":" 1377","line":"    const iov_count = if (iov.len > IOV_MAX) IOV_MAX else @as(u31, @intCast(iov.len));"},
{"lineNum":" 1378","line":"    const ioffset = @as(i64, @bitCast(offset)); // the OS treats this as unsigned"},
{"lineNum":" 1379","line":"    while (true) {"},
{"lineNum":" 1380","line":"        const rc = pwritev_sym(fd, iov.ptr, iov_count, ioffset);"},
{"lineNum":" 1381","line":"        switch (errno(rc)) {"},
{"lineNum":" 1382","line":"            .SUCCESS => return @as(usize, @intCast(rc)),"},
{"lineNum":" 1383","line":"            .INTR => continue,"},
{"lineNum":" 1384","line":"            .INVAL => return error.InvalidArgument,"},
{"lineNum":" 1385","line":"            .FAULT => unreachable,"},
{"lineNum":" 1386","line":"            .AGAIN => return error.WouldBlock,"},
{"lineNum":" 1387","line":"            .BADF => return error.NotOpenForWriting, // Can be a race condition."},
{"lineNum":" 1388","line":"            .DESTADDRREQ => unreachable, // `connect` was never called."},
{"lineNum":" 1389","line":"            .DQUOT => return error.DiskQuota,"},
{"lineNum":" 1390","line":"            .FBIG => return error.FileTooBig,"},
{"lineNum":" 1391","line":"            .IO => return error.InputOutput,"},
{"lineNum":" 1392","line":"            .NOSPC => return error.NoSpaceLeft,"},
{"lineNum":" 1393","line":"            .PERM => return error.AccessDenied,"},
{"lineNum":" 1394","line":"            .PIPE => return error.BrokenPipe,"},
{"lineNum":" 1395","line":"            .NXIO => return error.Unseekable,"},
{"lineNum":" 1396","line":"            .SPIPE => return error.Unseekable,"},
{"lineNum":" 1397","line":"            .OVERFLOW => return error.Unseekable,"},
{"lineNum":" 1398","line":"            .BUSY => return error.DeviceBusy,"},
{"lineNum":" 1399","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 1400","line":"        }"},
{"lineNum":" 1401","line":"    }"},
{"lineNum":" 1402","line":"}"},
{"lineNum":" 1403","line":""},
{"lineNum":" 1404","line":"pub const OpenError = error{"},
{"lineNum":" 1405","line":"    /// In WASI, this error may occur when the provided file handle is invalid."},
{"lineNum":" 1406","line":"    InvalidHandle,"},
{"lineNum":" 1407","line":""},
{"lineNum":" 1408","line":"    /// In WASI, this error may occur when the file descriptor does"},
{"lineNum":" 1409","line":"    /// not hold the required rights to open a new resource relative to it."},
{"lineNum":" 1410","line":"    AccessDenied,"},
{"lineNum":" 1411","line":"    SymLinkLoop,"},
{"lineNum":" 1412","line":"    ProcessFdQuotaExceeded,"},
{"lineNum":" 1413","line":"    SystemFdQuotaExceeded,"},
{"lineNum":" 1414","line":"    NoDevice,"},
{"lineNum":" 1415","line":"    FileNotFound,"},
{"lineNum":" 1416","line":""},
{"lineNum":" 1417","line":"    /// The path exceeded `MAX_PATH_BYTES` bytes."},
{"lineNum":" 1418","line":"    NameTooLong,"},
{"lineNum":" 1419","line":""},
{"lineNum":" 1420","line":"    /// Insufficient kernel memory was available, or"},
{"lineNum":" 1421","line":"    /// the named file is a FIFO and per-user hard limit on"},
{"lineNum":" 1422","line":"    /// memory allocation for pipes has been reached."},
{"lineNum":" 1423","line":"    SystemResources,"},
{"lineNum":" 1424","line":""},
{"lineNum":" 1425","line":"    /// The file is too large to be opened. This error is unreachable"},
{"lineNum":" 1426","line":"    /// for 64-bit targets, as well as when opening directories."},
{"lineNum":" 1427","line":"    FileTooBig,"},
{"lineNum":" 1428","line":""},
{"lineNum":" 1429","line":"    /// The path refers to directory but the `O.DIRECTORY` flag was not provided."},
{"lineNum":" 1430","line":"    IsDir,"},
{"lineNum":" 1431","line":""},
{"lineNum":" 1432","line":"    /// A new path cannot be created because the device has no room for the new file."},
{"lineNum":" 1433","line":"    /// This error is only reachable when the `O.CREAT` flag is provided."},
{"lineNum":" 1434","line":"    NoSpaceLeft,"},
{"lineNum":" 1435","line":""},
{"lineNum":" 1436","line":"    /// A component used as a directory in the path was not, in fact, a directory, or"},
{"lineNum":" 1437","line":"    /// `O.DIRECTORY` was specified and the path was not a directory."},
{"lineNum":" 1438","line":"    NotDir,"},
{"lineNum":" 1439","line":""},
{"lineNum":" 1440","line":"    /// The path already exists and the `O.CREAT` and `O.EXCL` flags were provided."},
{"lineNum":" 1441","line":"    PathAlreadyExists,"},
{"lineNum":" 1442","line":"    DeviceBusy,"},
{"lineNum":" 1443","line":""},
{"lineNum":" 1444","line":"    /// The underlying filesystem does not support file locks"},
{"lineNum":" 1445","line":"    FileLocksNotSupported,"},
{"lineNum":" 1446","line":""},
{"lineNum":" 1447","line":"    BadPathName,"},
{"lineNum":" 1448","line":"    InvalidUtf8,"},
{"lineNum":" 1449","line":""},
{"lineNum":" 1450","line":"    /// On Windows, `\\\\server` or `\\\\server\\share` was not found."},
{"lineNum":" 1451","line":"    NetworkNotFound,"},
{"lineNum":" 1452","line":""},
{"lineNum":" 1453","line":"    /// One of these three things:"},
{"lineNum":" 1454","line":"    /// * pathname  refers to an executable image which is currently being"},
{"lineNum":" 1455","line":"    ///   executed and write access was requested."},
{"lineNum":" 1456","line":"    /// * pathname refers to a file that is currently in  use  as  a  swap"},
{"lineNum":" 1457","line":"    ///   file, and the O_TRUNC flag was specified."},
{"lineNum":" 1458","line":"    /// * pathname  refers  to  a file that is currently being read by the"},
{"lineNum":" 1459","line":"    ///   kernel (e.g., for module/firmware loading), and write access was"},
{"lineNum":" 1460","line":"    ///   requested."},
{"lineNum":" 1461","line":"    FileBusy,"},
{"lineNum":" 1462","line":""},
{"lineNum":" 1463","line":"    WouldBlock,"},
{"lineNum":" 1464","line":"} || UnexpectedError;"},
{"lineNum":" 1465","line":""},
{"lineNum":" 1466","line":"/// Open and possibly create a file. Keeps trying if it gets interrupted."},
{"lineNum":" 1467","line":"/// See also `openZ`."},
{"lineNum":" 1468","line":"pub fn open(file_path: []const u8, flags: u32, perm: mode_t) OpenError!fd_t {"},
{"lineNum":" 1469","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 1470","line":"        const file_path_w = try windows.sliceToPrefixedFileW(file_path);"},
{"lineNum":" 1471","line":"        return openW(file_path_w.span(), flags, perm);"},
{"lineNum":" 1472","line":"    } else if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 1473","line":"        return openat(wasi.AT.FDCWD, file_path, flags, perm);"},
{"lineNum":" 1474","line":"    }"},
{"lineNum":" 1475","line":"    const file_path_c = try toPosixPath(file_path);"},
{"lineNum":" 1476","line":"    return openZ(&file_path_c, flags, perm);"},
{"lineNum":" 1477","line":"}"},
{"lineNum":" 1478","line":""},
{"lineNum":" 1479","line":"/// Open and possibly create a file. Keeps trying if it gets interrupted."},
{"lineNum":" 1480","line":"/// See also `open`."},
{"lineNum":" 1481","line":"pub fn openZ(file_path: [*:0]const u8, flags: u32, perm: mode_t) OpenError!fd_t {"},
{"lineNum":" 1482","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 1483","line":"        const file_path_w = try windows.cStrToPrefixedFileW(file_path);"},
{"lineNum":" 1484","line":"        return openW(file_path_w.span(), flags, perm);"},
{"lineNum":" 1485","line":"    } else if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 1486","line":"        return open(mem.sliceTo(file_path, 0), flags, perm);"},
{"lineNum":" 1487","line":"    }"},
{"lineNum":" 1488","line":""},
{"lineNum":" 1489","line":"    const open_sym = if (lfs64_abi) system.open64 else system.open;"},
{"lineNum":" 1490","line":""},
{"lineNum":" 1491","line":"    while (true) {"},
{"lineNum":" 1492","line":"        const rc = open_sym(file_path, flags, perm);"},
{"lineNum":" 1493","line":"        switch (errno(rc)) {"},
{"lineNum":" 1494","line":"            .SUCCESS => return @as(fd_t, @intCast(rc)),"},
{"lineNum":" 1495","line":"            .INTR => continue,"},
{"lineNum":" 1496","line":""},
{"lineNum":" 1497","line":"            .FAULT => unreachable,"},
{"lineNum":" 1498","line":"            .INVAL => unreachable,"},
{"lineNum":" 1499","line":"            .ACCES => return error.AccessDenied,"},
{"lineNum":" 1500","line":"            .FBIG => return error.FileTooBig,"},
{"lineNum":" 1501","line":"            .OVERFLOW => return error.FileTooBig,"},
{"lineNum":" 1502","line":"            .ISDIR => return error.IsDir,"},
{"lineNum":" 1503","line":"            .LOOP => return error.SymLinkLoop,"},
{"lineNum":" 1504","line":"            .MFILE => return error.ProcessFdQuotaExceeded,"},
{"lineNum":" 1505","line":"            .NAMETOOLONG => return error.NameTooLong,"},
{"lineNum":" 1506","line":"            .NFILE => return error.SystemFdQuotaExceeded,"},
{"lineNum":" 1507","line":"            .NODEV => return error.NoDevice,"},
{"lineNum":" 1508","line":"            .NOENT => return error.FileNotFound,"},
{"lineNum":" 1509","line":"            .NOMEM => return error.SystemResources,"},
{"lineNum":" 1510","line":"            .NOSPC => return error.NoSpaceLeft,"},
{"lineNum":" 1511","line":"            .NOTDIR => return error.NotDir,"},
{"lineNum":" 1512","line":"            .PERM => return error.AccessDenied,"},
{"lineNum":" 1513","line":"            .EXIST => return error.PathAlreadyExists,"},
{"lineNum":" 1514","line":"            .BUSY => return error.DeviceBusy,"},
{"lineNum":" 1515","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 1516","line":"        }"},
{"lineNum":" 1517","line":"    }"},
{"lineNum":" 1518","line":"}"},
{"lineNum":" 1519","line":""},
{"lineNum":" 1520","line":"fn openOptionsFromFlagsWindows(flags: u32) windows.OpenFileOptions {"},
{"lineNum":" 1521","line":"    const w = windows;"},
{"lineNum":" 1522","line":""},
{"lineNum":" 1523","line":"    var access_mask: w.ULONG = w.READ_CONTROL | w.FILE_WRITE_ATTRIBUTES | w.SYNCHRONIZE;"},
{"lineNum":" 1524","line":"    if (flags & O.RDWR != 0) {"},
{"lineNum":" 1525","line":"        access_mask |= w.GENERIC_READ | w.GENERIC_WRITE;"},
{"lineNum":" 1526","line":"    } else if (flags & O.WRONLY != 0) {"},
{"lineNum":" 1527","line":"        access_mask |= w.GENERIC_WRITE;"},
{"lineNum":" 1528","line":"    } else {"},
{"lineNum":" 1529","line":"        access_mask |= w.GENERIC_READ | w.GENERIC_WRITE;"},
{"lineNum":" 1530","line":"    }"},
{"lineNum":" 1531","line":""},
{"lineNum":" 1532","line":"    const filter: windows.OpenFileOptions.Filter = if (flags & O.DIRECTORY != 0) .dir_only else .file_only;"},
{"lineNum":" 1533","line":"    const follow_symlinks: bool = flags & O.NOFOLLOW == 0;"},
{"lineNum":" 1534","line":""},
{"lineNum":" 1535","line":"    const creation: w.ULONG = blk: {"},
{"lineNum":" 1536","line":"        if (flags & O.CREAT != 0) {"},
{"lineNum":" 1537","line":"            if (flags & O.EXCL != 0) {"},
{"lineNum":" 1538","line":"                break :blk w.FILE_CREATE;"},
{"lineNum":" 1539","line":"            }"},
{"lineNum":" 1540","line":"        }"},
{"lineNum":" 1541","line":"        break :blk w.FILE_OPEN;"},
{"lineNum":" 1542","line":"    };"},
{"lineNum":" 1543","line":""},
{"lineNum":" 1544","line":"    return .{"},
{"lineNum":" 1545","line":"        .access_mask = access_mask,"},
{"lineNum":" 1546","line":"        .io_mode = .blocking,"},
{"lineNum":" 1547","line":"        .creation = creation,"},
{"lineNum":" 1548","line":"        .filter = filter,"},
{"lineNum":" 1549","line":"        .follow_symlinks = follow_symlinks,"},
{"lineNum":" 1550","line":"    };"},
{"lineNum":" 1551","line":"}"},
{"lineNum":" 1552","line":""},
{"lineNum":" 1553","line":"/// Windows-only. The path parameter is"},
{"lineNum":" 1554","line":"/// [WTF-16](https://simonsapin.github.io/wtf-8/#potentially-ill-formed-utf-16) encoded."},
{"lineNum":" 1555","line":"/// Translates the POSIX open API call to a Windows API call."},
{"lineNum":" 1556","line":"/// TODO currently, this function does not handle all flag combinations"},
{"lineNum":" 1557","line":"/// or makes use of perm argument."},
{"lineNum":" 1558","line":"pub fn openW(file_path_w: []const u16, flags: u32, perm: mode_t) OpenError!fd_t {"},
{"lineNum":" 1559","line":"    _ = perm;"},
{"lineNum":" 1560","line":"    var options = openOptionsFromFlagsWindows(flags);"},
{"lineNum":" 1561","line":"    options.dir = std.fs.cwd().fd;"},
{"lineNum":" 1562","line":"    return windows.OpenFile(file_path_w, options) catch |err| switch (err) {"},
{"lineNum":" 1563","line":"        error.WouldBlock => unreachable,"},
{"lineNum":" 1564","line":"        error.PipeBusy => unreachable,"},
{"lineNum":" 1565","line":"        else => |e| return e,"},
{"lineNum":" 1566","line":"    };"},
{"lineNum":" 1567","line":"}"},
{"lineNum":" 1568","line":""},
{"lineNum":" 1569","line":"/// Open and possibly create a file. Keeps trying if it gets interrupted."},
{"lineNum":" 1570","line":"/// `file_path` is relative to the open directory handle `dir_fd`."},
{"lineNum":" 1571","line":"/// See also `openatZ`."},
{"lineNum":" 1572","line":"pub fn openat(dir_fd: fd_t, file_path: []const u8, flags: u32, mode: mode_t) OpenError!fd_t {"},
{"lineNum":" 1573","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 1574","line":"        const file_path_w = try windows.sliceToPrefixedFileW(file_path);"},
{"lineNum":" 1575","line":"        return openatW(dir_fd, file_path_w.span(), flags, mode);"},
{"lineNum":" 1576","line":"    } else if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 1577","line":"        // `mode` is ignored on WASI, which does not support unix-style file permissions"},
{"lineNum":" 1578","line":"        const opts = try openOptionsFromFlagsWasi(dir_fd, flags);"},
{"lineNum":" 1579","line":"        const fd = try openatWasi("},
{"lineNum":" 1580","line":"            dir_fd,"},
{"lineNum":" 1581","line":"            file_path,"},
{"lineNum":" 1582","line":"            opts.lookup_flags,"},
{"lineNum":" 1583","line":"            opts.oflags,"},
{"lineNum":" 1584","line":"            opts.fs_flags,"},
{"lineNum":" 1585","line":"            opts.fs_rights_base,"},
{"lineNum":" 1586","line":"            opts.fs_rights_inheriting,"},
{"lineNum":" 1587","line":"        );"},
{"lineNum":" 1588","line":"        errdefer close(fd);"},
{"lineNum":" 1589","line":""},
{"lineNum":" 1590","line":"        if (flags & O.WRONLY != 0) {"},
{"lineNum":" 1591","line":"            const info = try fstat(fd);"},
{"lineNum":" 1592","line":"            if (info.filetype == .DIRECTORY)"},
{"lineNum":" 1593","line":"                return error.IsDir;"},
{"lineNum":" 1594","line":"        }"},
{"lineNum":" 1595","line":""},
{"lineNum":" 1596","line":"        return fd;"},
{"lineNum":" 1597","line":"    }"},
{"lineNum":" 1598","line":"    const file_path_c = try toPosixPath(file_path);"},
{"lineNum":" 1599","line":"    return openatZ(dir_fd, &file_path_c, flags, mode);"},
{"lineNum":" 1600","line":"}"},
{"lineNum":" 1601","line":""},
{"lineNum":" 1602","line":"/// A struct to contain all lookup/rights flags accepted by `wasi.path_open`"},
{"lineNum":" 1603","line":"const WasiOpenOptions = struct {"},
{"lineNum":" 1604","line":"    oflags: wasi.oflags_t,"},
{"lineNum":" 1605","line":"    lookup_flags: wasi.lookupflags_t,"},
{"lineNum":" 1606","line":"    fs_rights_base: wasi.rights_t,"},
{"lineNum":" 1607","line":"    fs_rights_inheriting: wasi.rights_t,"},
{"lineNum":" 1608","line":"    fs_flags: wasi.fdflags_t,"},
{"lineNum":" 1609","line":"};"},
{"lineNum":" 1610","line":""},
{"lineNum":" 1611","line":"/// Compute rights + flags corresponding to the provided POSIX access mode."},
{"lineNum":" 1612","line":"fn openOptionsFromFlagsWasi(fd: fd_t, oflag: u32) OpenError!WasiOpenOptions {"},
{"lineNum":" 1613","line":"    const w = std.os.wasi;"},
{"lineNum":" 1614","line":""},
{"lineNum":" 1615","line":"    // First, discover the rights that we can derive from `fd`"},
{"lineNum":" 1616","line":"    var fsb_cur: wasi.fdstat_t = undefined;"},
{"lineNum":" 1617","line":"    _ = switch (w.fd_fdstat_get(fd, &fsb_cur)) {"},
{"lineNum":" 1618","line":"        .SUCCESS => .{},"},
{"lineNum":" 1619","line":"        .BADF => return error.InvalidHandle,"},
{"lineNum":" 1620","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 1621","line":"    };"},
{"lineNum":" 1622","line":""},
{"lineNum":" 1623","line":"    // Next, calculate the read/write rights to request, depending on the"},
{"lineNum":" 1624","line":"    // provided POSIX access mode"},
{"lineNum":" 1625","line":"    var rights: w.rights_t = 0;"},
{"lineNum":" 1626","line":"    if (oflag & O.RDONLY != 0) {"},
{"lineNum":" 1627","line":"        rights |= w.RIGHT.FD_READ | w.RIGHT.FD_READDIR;"},
{"lineNum":" 1628","line":"    }"},
{"lineNum":" 1629","line":"    if (oflag & O.WRONLY != 0) {"},
{"lineNum":" 1630","line":"        rights |= w.RIGHT.FD_DATASYNC | w.RIGHT.FD_WRITE |"},
{"lineNum":" 1631","line":"            w.RIGHT.FD_ALLOCATE | w.RIGHT.FD_FILESTAT_SET_SIZE;"},
{"lineNum":" 1632","line":"    }"},
{"lineNum":" 1633","line":""},
{"lineNum":" 1634","line":"    // Request all other rights unconditionally"},
{"lineNum":" 1635","line":"    rights |= ~(w.RIGHT.FD_DATASYNC | w.RIGHT.FD_READ |"},
{"lineNum":" 1636","line":"        w.RIGHT.FD_WRITE | w.RIGHT.FD_ALLOCATE |"},
{"lineNum":" 1637","line":"        w.RIGHT.FD_READDIR | w.RIGHT.FD_FILESTAT_SET_SIZE);"},
{"lineNum":" 1638","line":""},
{"lineNum":" 1639","line":"    // But only take rights that we can actually inherit"},
{"lineNum":" 1640","line":"    rights &= fsb_cur.fs_rights_inheriting;"},
{"lineNum":" 1641","line":""},
{"lineNum":" 1642","line":"    return WasiOpenOptions{"},
{"lineNum":" 1643","line":"        .oflags = @as(w.oflags_t, @truncate((oflag >> 12))) & 0xfff,"},
{"lineNum":" 1644","line":"        .lookup_flags = if (oflag & O.NOFOLLOW == 0) w.LOOKUP_SYMLINK_FOLLOW else 0,"},
{"lineNum":" 1645","line":"        .fs_rights_base = rights,"},
{"lineNum":" 1646","line":"        .fs_rights_inheriting = fsb_cur.fs_rights_inheriting,"},
{"lineNum":" 1647","line":"        .fs_flags = @as(w.fdflags_t, @truncate(oflag & 0xfff)),"},
{"lineNum":" 1648","line":"    };"},
{"lineNum":" 1649","line":"}"},
{"lineNum":" 1650","line":""},
{"lineNum":" 1651","line":"/// Open and possibly create a file in WASI."},
{"lineNum":" 1652","line":"pub fn openatWasi("},
{"lineNum":" 1653","line":"    dir_fd: fd_t,"},
{"lineNum":" 1654","line":"    file_path: []const u8,"},
{"lineNum":" 1655","line":"    lookup_flags: lookupflags_t,"},
{"lineNum":" 1656","line":"    oflags: oflags_t,"},
{"lineNum":" 1657","line":"    fdflags: fdflags_t,"},
{"lineNum":" 1658","line":"    base: rights_t,"},
{"lineNum":" 1659","line":"    inheriting: rights_t,"},
{"lineNum":" 1660","line":") OpenError!fd_t {"},
{"lineNum":" 1661","line":"    while (true) {"},
{"lineNum":" 1662","line":"        var fd: fd_t = undefined;"},
{"lineNum":" 1663","line":"        switch (wasi.path_open(dir_fd, lookup_flags, file_path.ptr, file_path.len, oflags, base, inheriting, fdflags, &fd)) {"},
{"lineNum":" 1664","line":"            .SUCCESS => return fd,"},
{"lineNum":" 1665","line":"            .INTR => continue,"},
{"lineNum":" 1666","line":""},
{"lineNum":" 1667","line":"            .FAULT => unreachable,"},
{"lineNum":" 1668","line":"            .INVAL => unreachable,"},
{"lineNum":" 1669","line":"            .ACCES => return error.AccessDenied,"},
{"lineNum":" 1670","line":"            .FBIG => return error.FileTooBig,"},
{"lineNum":" 1671","line":"            .OVERFLOW => return error.FileTooBig,"},
{"lineNum":" 1672","line":"            .ISDIR => return error.IsDir,"},
{"lineNum":" 1673","line":"            .LOOP => return error.SymLinkLoop,"},
{"lineNum":" 1674","line":"            .MFILE => return error.ProcessFdQuotaExceeded,"},
{"lineNum":" 1675","line":"            .NAMETOOLONG => return error.NameTooLong,"},
{"lineNum":" 1676","line":"            .NFILE => return error.SystemFdQuotaExceeded,"},
{"lineNum":" 1677","line":"            .NODEV => return error.NoDevice,"},
{"lineNum":" 1678","line":"            .NOENT => return error.FileNotFound,"},
{"lineNum":" 1679","line":"            .NOMEM => return error.SystemResources,"},
{"lineNum":" 1680","line":"            .NOSPC => return error.NoSpaceLeft,"},
{"lineNum":" 1681","line":"            .NOTDIR => return error.NotDir,"},
{"lineNum":" 1682","line":"            .PERM => return error.AccessDenied,"},
{"lineNum":" 1683","line":"            .EXIST => return error.PathAlreadyExists,"},
{"lineNum":" 1684","line":"            .BUSY => return error.DeviceBusy,"},
{"lineNum":" 1685","line":"            .NOTCAPABLE => return error.AccessDenied,"},
{"lineNum":" 1686","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 1687","line":"        }"},
{"lineNum":" 1688","line":"    }"},
{"lineNum":" 1689","line":"}"},
{"lineNum":" 1690","line":""},
{"lineNum":" 1691","line":"/// Open and possibly create a file. Keeps trying if it gets interrupted."},
{"lineNum":" 1692","line":"/// `file_path` is relative to the open directory handle `dir_fd`."},
{"lineNum":" 1693","line":"/// See also `openat`."},
{"lineNum":" 1694","line":"pub fn openatZ(dir_fd: fd_t, file_path: [*:0]const u8, flags: u32, mode: mode_t) OpenError!fd_t {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1695","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 1696","line":"        const file_path_w = try windows.cStrToPrefixedFileW(file_path);"},
{"lineNum":" 1697","line":"        return openatW(dir_fd, file_path_w.span(), flags, mode);"},
{"lineNum":" 1698","line":"    } else if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 1699","line":"        return openat(dir_fd, mem.sliceTo(file_path, 0), flags, mode);"},
{"lineNum":" 1700","line":"    }"},
{"lineNum":" 1701","line":""},
{"lineNum":" 1702","line":"    const openat_sym = if (lfs64_abi) system.openat64 else system.openat;"},
{"lineNum":" 1703","line":""},
{"lineNum":" 1704","line":"    while (true) {"},
{"lineNum":" 1705","line":"        const rc = openat_sym(dir_fd, file_path, flags, mode);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1706","line":"        switch (errno(rc)) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1707","line":"            .SUCCESS => return @as(fd_t, @intCast(rc)),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1708","line":"            .INTR => continue,"},
{"lineNum":" 1709","line":""},
{"lineNum":" 1710","line":"            .FAULT => unreachable,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1711","line":"            .INVAL => unreachable,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1712","line":"            .BADF => unreachable,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1713","line":"            .ACCES => return error.AccessDenied,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1714","line":"            .FBIG => return error.FileTooBig,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1715","line":"            .OVERFLOW => return error.FileTooBig,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1716","line":"            .ISDIR => return error.IsDir,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1717","line":"            .LOOP => return error.SymLinkLoop,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1718","line":"            .MFILE => return error.ProcessFdQuotaExceeded,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1719","line":"            .NAMETOOLONG => return error.NameTooLong,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1720","line":"            .NFILE => return error.SystemFdQuotaExceeded,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1721","line":"            .NODEV => return error.NoDevice,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1722","line":"            .NOENT => return error.FileNotFound,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1723","line":"            .NOMEM => return error.SystemResources,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1724","line":"            .NOSPC => return error.NoSpaceLeft,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1725","line":"            .NOTDIR => return error.NotDir,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1726","line":"            .PERM => return error.AccessDenied,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1727","line":"            .EXIST => return error.PathAlreadyExists,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1728","line":"            .BUSY => return error.DeviceBusy,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1729","line":"            .OPNOTSUPP => return error.FileLocksNotSupported,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1730","line":"            .AGAIN => return error.WouldBlock,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1731","line":"            .TXTBSY => return error.FileBusy,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1732","line":"            else => |err| return unexpectedErrno(err),","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 1733","line":"        }"},
{"lineNum":" 1734","line":"    }"},
{"lineNum":" 1735","line":"}"},
{"lineNum":" 1736","line":""},
{"lineNum":" 1737","line":"/// Windows-only. Similar to `openat` but with pathname argument null-terminated"},
{"lineNum":" 1738","line":"/// WTF16 encoded."},
{"lineNum":" 1739","line":"/// TODO currently, this function does not handle all flag combinations"},
{"lineNum":" 1740","line":"/// or makes use of perm argument."},
{"lineNum":" 1741","line":"pub fn openatW(dir_fd: fd_t, file_path_w: []const u16, flags: u32, mode: mode_t) OpenError!fd_t {"},
{"lineNum":" 1742","line":"    _ = mode;"},
{"lineNum":" 1743","line":"    var options = openOptionsFromFlagsWindows(flags);"},
{"lineNum":" 1744","line":"    options.dir = dir_fd;"},
{"lineNum":" 1745","line":"    return windows.OpenFile(file_path_w, options) catch |err| switch (err) {"},
{"lineNum":" 1746","line":"        error.WouldBlock => unreachable,"},
{"lineNum":" 1747","line":"        error.PipeBusy => unreachable,"},
{"lineNum":" 1748","line":"        else => |e| return e,"},
{"lineNum":" 1749","line":"    };"},
{"lineNum":" 1750","line":"}"},
{"lineNum":" 1751","line":""},
{"lineNum":" 1752","line":"pub fn dup(old_fd: fd_t) !fd_t {"},
{"lineNum":" 1753","line":"    const rc = system.dup(old_fd);"},
{"lineNum":" 1754","line":"    return switch (errno(rc)) {"},
{"lineNum":" 1755","line":"        .SUCCESS => return @as(fd_t, @intCast(rc)),"},
{"lineNum":" 1756","line":"        .MFILE => error.ProcessFdQuotaExceeded,"},
{"lineNum":" 1757","line":"        .BADF => unreachable, // invalid file descriptor"},
{"lineNum":" 1758","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 1759","line":"    };"},
{"lineNum":" 1760","line":"}"},
{"lineNum":" 1761","line":""},
{"lineNum":" 1762","line":"pub fn dup2(old_fd: fd_t, new_fd: fd_t) !void {"},
{"lineNum":" 1763","line":"    while (true) {"},
{"lineNum":" 1764","line":"        switch (errno(system.dup2(old_fd, new_fd))) {"},
{"lineNum":" 1765","line":"            .SUCCESS => return,"},
{"lineNum":" 1766","line":"            .BUSY, .INTR => continue,"},
{"lineNum":" 1767","line":"            .MFILE => return error.ProcessFdQuotaExceeded,"},
{"lineNum":" 1768","line":"            .INVAL => unreachable, // invalid parameters passed to dup2"},
{"lineNum":" 1769","line":"            .BADF => unreachable, // invalid file descriptor"},
{"lineNum":" 1770","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 1771","line":"        }"},
{"lineNum":" 1772","line":"    }"},
{"lineNum":" 1773","line":"}"},
{"lineNum":" 1774","line":""},
{"lineNum":" 1775","line":"pub const ExecveError = error{"},
{"lineNum":" 1776","line":"    SystemResources,"},
{"lineNum":" 1777","line":"    AccessDenied,"},
{"lineNum":" 1778","line":"    InvalidExe,"},
{"lineNum":" 1779","line":"    FileSystem,"},
{"lineNum":" 1780","line":"    IsDir,"},
{"lineNum":" 1781","line":"    FileNotFound,"},
{"lineNum":" 1782","line":"    NotDir,"},
{"lineNum":" 1783","line":"    FileBusy,"},
{"lineNum":" 1784","line":"    ProcessFdQuotaExceeded,"},
{"lineNum":" 1785","line":"    SystemFdQuotaExceeded,"},
{"lineNum":" 1786","line":"    NameTooLong,"},
{"lineNum":" 1787","line":"} || UnexpectedError;"},
{"lineNum":" 1788","line":""},
{"lineNum":" 1789","line":"/// This function ignores PATH environment variable. See `execvpeZ` for that."},
{"lineNum":" 1790","line":"pub fn execveZ("},
{"lineNum":" 1791","line":"    path: [*:0]const u8,"},
{"lineNum":" 1792","line":"    child_argv: [*:null]const ?[*:0]const u8,"},
{"lineNum":" 1793","line":"    envp: [*:null]const ?[*:0]const u8,"},
{"lineNum":" 1794","line":") ExecveError {"},
{"lineNum":" 1795","line":"    switch (errno(system.execve(path, child_argv, envp))) {"},
{"lineNum":" 1796","line":"        .SUCCESS => unreachable,"},
{"lineNum":" 1797","line":"        .FAULT => unreachable,"},
{"lineNum":" 1798","line":"        .@\"2BIG\" => return error.SystemResources,"},
{"lineNum":" 1799","line":"        .MFILE => return error.ProcessFdQuotaExceeded,"},
{"lineNum":" 1800","line":"        .NAMETOOLONG => return error.NameTooLong,"},
{"lineNum":" 1801","line":"        .NFILE => return error.SystemFdQuotaExceeded,"},
{"lineNum":" 1802","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 1803","line":"        .ACCES => return error.AccessDenied,"},
{"lineNum":" 1804","line":"        .PERM => return error.AccessDenied,"},
{"lineNum":" 1805","line":"        .INVAL => return error.InvalidExe,"},
{"lineNum":" 1806","line":"        .NOEXEC => return error.InvalidExe,"},
{"lineNum":" 1807","line":"        .IO => return error.FileSystem,"},
{"lineNum":" 1808","line":"        .LOOP => return error.FileSystem,"},
{"lineNum":" 1809","line":"        .ISDIR => return error.IsDir,"},
{"lineNum":" 1810","line":"        .NOENT => return error.FileNotFound,"},
{"lineNum":" 1811","line":"        .NOTDIR => return error.NotDir,"},
{"lineNum":" 1812","line":"        .TXTBSY => return error.FileBusy,"},
{"lineNum":" 1813","line":"        else => |err| switch (builtin.os.tag) {"},
{"lineNum":" 1814","line":"            .macos, .ios, .tvos, .watchos => switch (err) {"},
{"lineNum":" 1815","line":"                .BADEXEC => return error.InvalidExe,"},
{"lineNum":" 1816","line":"                .BADARCH => return error.InvalidExe,"},
{"lineNum":" 1817","line":"                else => return unexpectedErrno(err),"},
{"lineNum":" 1818","line":"            },"},
{"lineNum":" 1819","line":"            .linux, .solaris => switch (err) {"},
{"lineNum":" 1820","line":"                .LIBBAD => return error.InvalidExe,"},
{"lineNum":" 1821","line":"                else => return unexpectedErrno(err),"},
{"lineNum":" 1822","line":"            },"},
{"lineNum":" 1823","line":"            else => return unexpectedErrno(err),"},
{"lineNum":" 1824","line":"        },"},
{"lineNum":" 1825","line":"    }"},
{"lineNum":" 1826","line":"}"},
{"lineNum":" 1827","line":""},
{"lineNum":" 1828","line":"pub const Arg0Expand = enum {"},
{"lineNum":" 1829","line":"    expand,"},
{"lineNum":" 1830","line":"    no_expand,"},
{"lineNum":" 1831","line":"};"},
{"lineNum":" 1832","line":""},
{"lineNum":" 1833","line":"/// Like `execvpeZ` except if `arg0_expand` is `.expand`, then `argv` is mutable,"},
{"lineNum":" 1834","line":"/// and `argv[0]` is expanded to be the same absolute path that is passed to the execve syscall."},
{"lineNum":" 1835","line":"/// If this function returns with an error, `argv[0]` will be restored to the value it was when it was passed in."},
{"lineNum":" 1836","line":"pub fn execvpeZ_expandArg0("},
{"lineNum":" 1837","line":"    comptime arg0_expand: Arg0Expand,"},
{"lineNum":" 1838","line":"    file: [*:0]const u8,"},
{"lineNum":" 1839","line":"    child_argv: switch (arg0_expand) {"},
{"lineNum":" 1840","line":"        .expand => [*:null]?[*:0]const u8,"},
{"lineNum":" 1841","line":"        .no_expand => [*:null]const ?[*:0]const u8,"},
{"lineNum":" 1842","line":"    },"},
{"lineNum":" 1843","line":"    envp: [*:null]const ?[*:0]const u8,"},
{"lineNum":" 1844","line":") ExecveError {"},
{"lineNum":" 1845","line":"    const file_slice = mem.sliceTo(file, 0);"},
{"lineNum":" 1846","line":"    if (mem.indexOfScalar(u8, file_slice, \'/\') != null) return execveZ(file, child_argv, envp);"},
{"lineNum":" 1847","line":""},
{"lineNum":" 1848","line":"    const PATH = getenvZ(\"PATH\") orelse \"/usr/local/bin:/bin/:/usr/bin\";"},
{"lineNum":" 1849","line":"    // Use of MAX_PATH_BYTES here is valid as the path_buf will be passed"},
{"lineNum":" 1850","line":"    // directly to the operating system in execveZ."},
{"lineNum":" 1851","line":"    var path_buf: [MAX_PATH_BYTES]u8 = undefined;"},
{"lineNum":" 1852","line":"    var it = mem.tokenizeScalar(u8, PATH, \':\');"},
{"lineNum":" 1853","line":"    var seen_eacces = false;"},
{"lineNum":" 1854","line":"    var err: ExecveError = error.FileNotFound;"},
{"lineNum":" 1855","line":""},
{"lineNum":" 1856","line":"    // In case of expanding arg0 we must put it back if we return with an error."},
{"lineNum":" 1857","line":"    const prev_arg0 = child_argv[0];"},
{"lineNum":" 1858","line":"    defer switch (arg0_expand) {"},
{"lineNum":" 1859","line":"        .expand => child_argv[0] = prev_arg0,"},
{"lineNum":" 1860","line":"        .no_expand => {},"},
{"lineNum":" 1861","line":"    };"},
{"lineNum":" 1862","line":""},
{"lineNum":" 1863","line":"    while (it.next()) |search_path| {"},
{"lineNum":" 1864","line":"        const path_len = search_path.len + file_slice.len + 1;"},
{"lineNum":" 1865","line":"        if (path_buf.len < path_len + 1) return error.NameTooLong;"},
{"lineNum":" 1866","line":"        @memcpy(path_buf[0..search_path.len], search_path);"},
{"lineNum":" 1867","line":"        path_buf[search_path.len] = \'/\';"},
{"lineNum":" 1868","line":"        @memcpy(path_buf[search_path.len + 1 ..][0..file_slice.len], file_slice);"},
{"lineNum":" 1869","line":"        path_buf[path_len] = 0;"},
{"lineNum":" 1870","line":"        const full_path = path_buf[0..path_len :0].ptr;"},
{"lineNum":" 1871","line":"        switch (arg0_expand) {"},
{"lineNum":" 1872","line":"            .expand => child_argv[0] = full_path,"},
{"lineNum":" 1873","line":"            .no_expand => {},"},
{"lineNum":" 1874","line":"        }"},
{"lineNum":" 1875","line":"        err = execveZ(full_path, child_argv, envp);"},
{"lineNum":" 1876","line":"        switch (err) {"},
{"lineNum":" 1877","line":"            error.AccessDenied => seen_eacces = true,"},
{"lineNum":" 1878","line":"            error.FileNotFound, error.NotDir => {},"},
{"lineNum":" 1879","line":"            else => |e| return e,"},
{"lineNum":" 1880","line":"        }"},
{"lineNum":" 1881","line":"    }"},
{"lineNum":" 1882","line":"    if (seen_eacces) return error.AccessDenied;"},
{"lineNum":" 1883","line":"    return err;"},
{"lineNum":" 1884","line":"}"},
{"lineNum":" 1885","line":""},
{"lineNum":" 1886","line":"/// This function also uses the PATH environment variable to get the full path to the executable."},
{"lineNum":" 1887","line":"/// If `file` is an absolute path, this is the same as `execveZ`."},
{"lineNum":" 1888","line":"pub fn execvpeZ("},
{"lineNum":" 1889","line":"    file: [*:0]const u8,"},
{"lineNum":" 1890","line":"    argv_ptr: [*:null]const ?[*:0]const u8,"},
{"lineNum":" 1891","line":"    envp: [*:null]const ?[*:0]const u8,"},
{"lineNum":" 1892","line":") ExecveError {"},
{"lineNum":" 1893","line":"    return execvpeZ_expandArg0(.no_expand, file, argv_ptr, envp);"},
{"lineNum":" 1894","line":"}"},
{"lineNum":" 1895","line":""},
{"lineNum":" 1896","line":"/// Get an environment variable."},
{"lineNum":" 1897","line":"/// See also `getenvZ`."},
{"lineNum":" 1898","line":"pub fn getenv(key: []const u8) ?[:0]const u8 {","class":"lineCov","hits":"1","order":"377","possible_hits":"1",},
{"lineNum":" 1899","line":"    if (builtin.link_libc) {"},
{"lineNum":" 1900","line":"        var ptr = std.c.environ;"},
{"lineNum":" 1901","line":"        while (ptr[0]) |line| : (ptr += 1) {"},
{"lineNum":" 1902","line":"            var line_i: usize = 0;"},
{"lineNum":" 1903","line":"            while (line[line_i] != 0 and line[line_i] != \'=\') : (line_i += 1) {}"},
{"lineNum":" 1904","line":"            const this_key = line[0..line_i];"},
{"lineNum":" 1905","line":""},
{"lineNum":" 1906","line":"            if (!mem.eql(u8, this_key, key)) continue;"},
{"lineNum":" 1907","line":""},
{"lineNum":" 1908","line":"            return mem.sliceTo(line + line_i + 1, 0);"},
{"lineNum":" 1909","line":"        }"},
{"lineNum":" 1910","line":"        return null;"},
{"lineNum":" 1911","line":"    }"},
{"lineNum":" 1912","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 1913","line":"        @compileError(\"std.os.getenv is unavailable for Windows because environment string is in WTF-16 format. See std.process.getEnvVarOwned for cross-platform API or std.os.getenvW for Windows-specific API.\");"},
{"lineNum":" 1914","line":"    }"},
{"lineNum":" 1915","line":"    // The simplified start logic doesn\'t populate environ."},
{"lineNum":" 1916","line":"    if (std.start.simplified_logic) return null;","class":"lineCov","hits":"1","order":"378","possible_hits":"1",},
{"lineNum":" 1917","line":"    // TODO see https://github.com/ziglang/zig/issues/4524"},
{"lineNum":" 1918","line":"    for (environ) |ptr| {","class":"lineCov","hits":"3","order":"379","possible_hits":"3",},
{"lineNum":" 1919","line":"        var line_i: usize = 0;","class":"lineCov","hits":"1","order":"380","possible_hits":"1",},
{"lineNum":" 1920","line":"        while (ptr[line_i] != 0 and ptr[line_i] != \'=\') : (line_i += 1) {}","class":"lineCov","hits":"1","order":"381","possible_hits":"1",},
{"lineNum":" 1921","line":"        const this_key = ptr[0..line_i];","class":"lineCov","hits":"3","order":"382","possible_hits":"3",},
{"lineNum":" 1922","line":"        if (!mem.eql(u8, key, this_key)) continue;","class":"lineCov","hits":"2","order":"383","possible_hits":"2",},
{"lineNum":" 1923","line":""},
{"lineNum":" 1924","line":"        return mem.sliceTo(ptr + line_i + 1, 0);","class":"linePartCov","hits":"2","order":"386","possible_hits":"3",},
{"lineNum":" 1925","line":"    }"},
{"lineNum":" 1926","line":"    return null;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 1927","line":"}"},
{"lineNum":" 1928","line":""},
{"lineNum":" 1929","line":"/// Get an environment variable with a null-terminated name."},
{"lineNum":" 1930","line":"/// See also `getenv`."},
{"lineNum":" 1931","line":"pub fn getenvZ(key: [*:0]const u8) ?[:0]const u8 {","class":"lineCov","hits":"1","order":"375","possible_hits":"1",},
{"lineNum":" 1932","line":"    if (builtin.link_libc) {"},
{"lineNum":" 1933","line":"        const value = system.getenv(key) orelse return null;"},
{"lineNum":" 1934","line":"        return mem.sliceTo(value, 0);"},
{"lineNum":" 1935","line":"    }"},
{"lineNum":" 1936","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 1937","line":"        @compileError(\"std.os.getenvZ is unavailable for Windows because environment string is in WTF-16 format. See std.process.getEnvVarOwned for cross-platform API or std.os.getenvW for Windows-specific API.\");"},
{"lineNum":" 1938","line":"    }"},
{"lineNum":" 1939","line":"    return getenv(mem.sliceTo(key, 0));","class":"lineCov","hits":"1","order":"376","possible_hits":"1",},
{"lineNum":" 1940","line":"}"},
{"lineNum":" 1941","line":""},
{"lineNum":" 1942","line":"/// Windows-only. Get an environment variable with a null-terminated, WTF-16 encoded name."},
{"lineNum":" 1943","line":"/// See also `getenv`."},
{"lineNum":" 1944","line":"/// This function performs a Unicode-aware case-insensitive lookup using RtlEqualUnicodeString."},
{"lineNum":" 1945","line":"pub fn getenvW(key: [*:0]const u16) ?[:0]const u16 {"},
{"lineNum":" 1946","line":"    if (builtin.os.tag != .windows) {"},
{"lineNum":" 1947","line":"        @compileError(\"std.os.getenvW is a Windows-only API\");"},
{"lineNum":" 1948","line":"    }"},
{"lineNum":" 1949","line":"    const key_slice = mem.sliceTo(key, 0);"},
{"lineNum":" 1950","line":"    const ptr = windows.peb().ProcessParameters.Environment;"},
{"lineNum":" 1951","line":"    var i: usize = 0;"},
{"lineNum":" 1952","line":"    while (ptr[i] != 0) {"},
{"lineNum":" 1953","line":"        const key_start = i;"},
{"lineNum":" 1954","line":""},
{"lineNum":" 1955","line":"        // There are some special environment variables that start with =,"},
{"lineNum":" 1956","line":"        // so we need a special case to not treat = as a key/value separator"},
{"lineNum":" 1957","line":"        // if it\'s the first character."},
{"lineNum":" 1958","line":"        // https://devblogs.microsoft.com/oldnewthing/20100506-00/?p=14133"},
{"lineNum":" 1959","line":"        if (ptr[key_start] == \'=\') i += 1;"},
{"lineNum":" 1960","line":""},
{"lineNum":" 1961","line":"        while (ptr[i] != 0 and ptr[i] != \'=\') : (i += 1) {}"},
{"lineNum":" 1962","line":"        const this_key = ptr[key_start..i];"},
{"lineNum":" 1963","line":""},
{"lineNum":" 1964","line":"        if (ptr[i] == \'=\') i += 1;"},
{"lineNum":" 1965","line":""},
{"lineNum":" 1966","line":"        const value_start = i;"},
{"lineNum":" 1967","line":"        while (ptr[i] != 0) : (i += 1) {}"},
{"lineNum":" 1968","line":"        const this_value = ptr[value_start..i :0];"},
{"lineNum":" 1969","line":""},
{"lineNum":" 1970","line":"        if (windows.eqlIgnoreCaseWTF16(key_slice, this_key)) {"},
{"lineNum":" 1971","line":"            return this_value;"},
{"lineNum":" 1972","line":"        }"},
{"lineNum":" 1973","line":""},
{"lineNum":" 1974","line":"        i += 1; // skip over null byte"},
{"lineNum":" 1975","line":"    }"},
{"lineNum":" 1976","line":"    return null;"},
{"lineNum":" 1977","line":"}"},
{"lineNum":" 1978","line":""},
{"lineNum":" 1979","line":"pub const GetCwdError = error{"},
{"lineNum":" 1980","line":"    NameTooLong,"},
{"lineNum":" 1981","line":"    CurrentWorkingDirectoryUnlinked,"},
{"lineNum":" 1982","line":"} || UnexpectedError;"},
{"lineNum":" 1983","line":""},
{"lineNum":" 1984","line":"/// The result is a slice of out_buffer, indexed from 0."},
{"lineNum":" 1985","line":"pub fn getcwd(out_buffer: []u8) GetCwdError![]u8 {"},
{"lineNum":" 1986","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 1987","line":"        return windows.GetCurrentDirectory(out_buffer);"},
{"lineNum":" 1988","line":"    } else if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 1989","line":"        const path = \".\";"},
{"lineNum":" 1990","line":"        if (out_buffer.len < path.len) return error.NameTooLong;"},
{"lineNum":" 1991","line":"        const result = out_buffer[0..path.len];"},
{"lineNum":" 1992","line":"        @memcpy(result, path);"},
{"lineNum":" 1993","line":"        return result;"},
{"lineNum":" 1994","line":"    }"},
{"lineNum":" 1995","line":""},
{"lineNum":" 1996","line":"    const err = if (builtin.link_libc) blk: {"},
{"lineNum":" 1997","line":"        const c_err = if (std.c.getcwd(out_buffer.ptr, out_buffer.len)) |_| 0 else std.c._errno().*;"},
{"lineNum":" 1998","line":"        break :blk @as(E, @enumFromInt(c_err));"},
{"lineNum":" 1999","line":"    } else blk: {"},
{"lineNum":" 2000","line":"        break :blk errno(system.getcwd(out_buffer.ptr, out_buffer.len));"},
{"lineNum":" 2001","line":"    };"},
{"lineNum":" 2002","line":"    switch (err) {"},
{"lineNum":" 2003","line":"        .SUCCESS => return mem.sliceTo(out_buffer, 0),"},
{"lineNum":" 2004","line":"        .FAULT => unreachable,"},
{"lineNum":" 2005","line":"        .INVAL => unreachable,"},
{"lineNum":" 2006","line":"        .NOENT => return error.CurrentWorkingDirectoryUnlinked,"},
{"lineNum":" 2007","line":"        .RANGE => return error.NameTooLong,"},
{"lineNum":" 2008","line":"        else => return unexpectedErrno(err),"},
{"lineNum":" 2009","line":"    }"},
{"lineNum":" 2010","line":"}"},
{"lineNum":" 2011","line":""},
{"lineNum":" 2012","line":"pub const SymLinkError = error{"},
{"lineNum":" 2013","line":"    /// In WASI, this error may occur when the file descriptor does"},
{"lineNum":" 2014","line":"    /// not hold the required rights to create a new symbolic link relative to it."},
{"lineNum":" 2015","line":"    AccessDenied,"},
{"lineNum":" 2016","line":"    DiskQuota,"},
{"lineNum":" 2017","line":"    PathAlreadyExists,"},
{"lineNum":" 2018","line":"    FileSystem,"},
{"lineNum":" 2019","line":"    SymLinkLoop,"},
{"lineNum":" 2020","line":"    FileNotFound,"},
{"lineNum":" 2021","line":"    SystemResources,"},
{"lineNum":" 2022","line":"    NoSpaceLeft,"},
{"lineNum":" 2023","line":"    ReadOnlyFileSystem,"},
{"lineNum":" 2024","line":"    NotDir,"},
{"lineNum":" 2025","line":"    NameTooLong,"},
{"lineNum":" 2026","line":"    InvalidUtf8,"},
{"lineNum":" 2027","line":"    BadPathName,"},
{"lineNum":" 2028","line":"} || UnexpectedError;"},
{"lineNum":" 2029","line":""},
{"lineNum":" 2030","line":"/// Creates a symbolic link named `sym_link_path` which contains the string `target_path`."},
{"lineNum":" 2031","line":"/// A symbolic link (also known as a soft link) may point to an existing file or to a nonexistent"},
{"lineNum":" 2032","line":"/// one; the latter case is known as a dangling link."},
{"lineNum":" 2033","line":"/// If `sym_link_path` exists, it will not be overwritten."},
{"lineNum":" 2034","line":"/// See also `symlinkZ."},
{"lineNum":" 2035","line":"pub fn symlink(target_path: []const u8, sym_link_path: []const u8) SymLinkError!void {"},
{"lineNum":" 2036","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 2037","line":"        @compileError(\"symlink is not supported on Windows; use std.os.windows.CreateSymbolicLink instead\");"},
{"lineNum":" 2038","line":"    } else if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 2039","line":"        return symlinkat(target_path, wasi.AT.FDCWD, sym_link_path);"},
{"lineNum":" 2040","line":"    }"},
{"lineNum":" 2041","line":"    const target_path_c = try toPosixPath(target_path);"},
{"lineNum":" 2042","line":"    const sym_link_path_c = try toPosixPath(sym_link_path);"},
{"lineNum":" 2043","line":"    return symlinkZ(&target_path_c, &sym_link_path_c);"},
{"lineNum":" 2044","line":"}"},
{"lineNum":" 2045","line":""},
{"lineNum":" 2046","line":"/// This is the same as `symlink` except the parameters are null-terminated pointers."},
{"lineNum":" 2047","line":"/// See also `symlink`."},
{"lineNum":" 2048","line":"pub fn symlinkZ(target_path: [*:0]const u8, sym_link_path: [*:0]const u8) SymLinkError!void {"},
{"lineNum":" 2049","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 2050","line":"        @compileError(\"symlink is not supported on Windows; use std.os.windows.CreateSymbolicLink instead\");"},
{"lineNum":" 2051","line":"    } else if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 2052","line":"        return symlinkatZ(target_path, fs.cwd().fd, sym_link_path);"},
{"lineNum":" 2053","line":"    }"},
{"lineNum":" 2054","line":"    switch (errno(system.symlink(target_path, sym_link_path))) {"},
{"lineNum":" 2055","line":"        .SUCCESS => return,"},
{"lineNum":" 2056","line":"        .FAULT => unreachable,"},
{"lineNum":" 2057","line":"        .INVAL => unreachable,"},
{"lineNum":" 2058","line":"        .ACCES => return error.AccessDenied,"},
{"lineNum":" 2059","line":"        .PERM => return error.AccessDenied,"},
{"lineNum":" 2060","line":"        .DQUOT => return error.DiskQuota,"},
{"lineNum":" 2061","line":"        .EXIST => return error.PathAlreadyExists,"},
{"lineNum":" 2062","line":"        .IO => return error.FileSystem,"},
{"lineNum":" 2063","line":"        .LOOP => return error.SymLinkLoop,"},
{"lineNum":" 2064","line":"        .NAMETOOLONG => return error.NameTooLong,"},
{"lineNum":" 2065","line":"        .NOENT => return error.FileNotFound,"},
{"lineNum":" 2066","line":"        .NOTDIR => return error.NotDir,"},
{"lineNum":" 2067","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 2068","line":"        .NOSPC => return error.NoSpaceLeft,"},
{"lineNum":" 2069","line":"        .ROFS => return error.ReadOnlyFileSystem,"},
{"lineNum":" 2070","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 2071","line":"    }"},
{"lineNum":" 2072","line":"}"},
{"lineNum":" 2073","line":""},
{"lineNum":" 2074","line":"/// Similar to `symlink`, however, creates a symbolic link named `sym_link_path` which contains the string"},
{"lineNum":" 2075","line":"/// `target_path` **relative** to `newdirfd` directory handle."},
{"lineNum":" 2076","line":"/// A symbolic link (also known as a soft link) may point to an existing file or to a nonexistent"},
{"lineNum":" 2077","line":"/// one; the latter case is known as a dangling link."},
{"lineNum":" 2078","line":"/// If `sym_link_path` exists, it will not be overwritten."},
{"lineNum":" 2079","line":"/// See also `symlinkatWasi`, `symlinkatZ` and `symlinkatW`."},
{"lineNum":" 2080","line":"pub fn symlinkat(target_path: []const u8, newdirfd: fd_t, sym_link_path: []const u8) SymLinkError!void {"},
{"lineNum":" 2081","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 2082","line":"        @compileError(\"symlinkat is not supported on Windows; use std.os.windows.CreateSymbolicLink instead\");"},
{"lineNum":" 2083","line":"    } else if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 2084","line":"        return symlinkatWasi(target_path, newdirfd, sym_link_path);"},
{"lineNum":" 2085","line":"    }"},
{"lineNum":" 2086","line":"    const target_path_c = try toPosixPath(target_path);"},
{"lineNum":" 2087","line":"    const sym_link_path_c = try toPosixPath(sym_link_path);"},
{"lineNum":" 2088","line":"    return symlinkatZ(&target_path_c, newdirfd, &sym_link_path_c);"},
{"lineNum":" 2089","line":"}"},
{"lineNum":" 2090","line":""},
{"lineNum":" 2091","line":"/// WASI-only. The same as `symlinkat` but targeting WASI."},
{"lineNum":" 2092","line":"/// See also `symlinkat`."},
{"lineNum":" 2093","line":"pub fn symlinkatWasi(target_path: []const u8, newdirfd: fd_t, sym_link_path: []const u8) SymLinkError!void {"},
{"lineNum":" 2094","line":"    switch (wasi.path_symlink(target_path.ptr, target_path.len, newdirfd, sym_link_path.ptr, sym_link_path.len)) {"},
{"lineNum":" 2095","line":"        .SUCCESS => {},"},
{"lineNum":" 2096","line":"        .FAULT => unreachable,"},
{"lineNum":" 2097","line":"        .INVAL => unreachable,"},
{"lineNum":" 2098","line":"        .BADF => unreachable,"},
{"lineNum":" 2099","line":"        .ACCES => return error.AccessDenied,"},
{"lineNum":" 2100","line":"        .PERM => return error.AccessDenied,"},
{"lineNum":" 2101","line":"        .DQUOT => return error.DiskQuota,"},
{"lineNum":" 2102","line":"        .EXIST => return error.PathAlreadyExists,"},
{"lineNum":" 2103","line":"        .IO => return error.FileSystem,"},
{"lineNum":" 2104","line":"        .LOOP => return error.SymLinkLoop,"},
{"lineNum":" 2105","line":"        .NAMETOOLONG => return error.NameTooLong,"},
{"lineNum":" 2106","line":"        .NOENT => return error.FileNotFound,"},
{"lineNum":" 2107","line":"        .NOTDIR => return error.NotDir,"},
{"lineNum":" 2108","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 2109","line":"        .NOSPC => return error.NoSpaceLeft,"},
{"lineNum":" 2110","line":"        .ROFS => return error.ReadOnlyFileSystem,"},
{"lineNum":" 2111","line":"        .NOTCAPABLE => return error.AccessDenied,"},
{"lineNum":" 2112","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 2113","line":"    }"},
{"lineNum":" 2114","line":"}"},
{"lineNum":" 2115","line":""},
{"lineNum":" 2116","line":"/// The same as `symlinkat` except the parameters are null-terminated pointers."},
{"lineNum":" 2117","line":"/// See also `symlinkat`."},
{"lineNum":" 2118","line":"pub fn symlinkatZ(target_path: [*:0]const u8, newdirfd: fd_t, sym_link_path: [*:0]const u8) SymLinkError!void {"},
{"lineNum":" 2119","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 2120","line":"        @compileError(\"symlinkat is not supported on Windows; use std.os.windows.CreateSymbolicLink instead\");"},
{"lineNum":" 2121","line":"    } else if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 2122","line":"        return symlinkat(mem.sliceTo(target_path, 0), newdirfd, mem.sliceTo(sym_link_path, 0));"},
{"lineNum":" 2123","line":"    }"},
{"lineNum":" 2124","line":"    switch (errno(system.symlinkat(target_path, newdirfd, sym_link_path))) {"},
{"lineNum":" 2125","line":"        .SUCCESS => return,"},
{"lineNum":" 2126","line":"        .FAULT => unreachable,"},
{"lineNum":" 2127","line":"        .INVAL => unreachable,"},
{"lineNum":" 2128","line":"        .ACCES => return error.AccessDenied,"},
{"lineNum":" 2129","line":"        .PERM => return error.AccessDenied,"},
{"lineNum":" 2130","line":"        .DQUOT => return error.DiskQuota,"},
{"lineNum":" 2131","line":"        .EXIST => return error.PathAlreadyExists,"},
{"lineNum":" 2132","line":"        .IO => return error.FileSystem,"},
{"lineNum":" 2133","line":"        .LOOP => return error.SymLinkLoop,"},
{"lineNum":" 2134","line":"        .NAMETOOLONG => return error.NameTooLong,"},
{"lineNum":" 2135","line":"        .NOENT => return error.FileNotFound,"},
{"lineNum":" 2136","line":"        .NOTDIR => return error.NotDir,"},
{"lineNum":" 2137","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 2138","line":"        .NOSPC => return error.NoSpaceLeft,"},
{"lineNum":" 2139","line":"        .ROFS => return error.ReadOnlyFileSystem,"},
{"lineNum":" 2140","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 2141","line":"    }"},
{"lineNum":" 2142","line":"}"},
{"lineNum":" 2143","line":""},
{"lineNum":" 2144","line":"pub const LinkError = UnexpectedError || error{"},
{"lineNum":" 2145","line":"    AccessDenied,"},
{"lineNum":" 2146","line":"    DiskQuota,"},
{"lineNum":" 2147","line":"    PathAlreadyExists,"},
{"lineNum":" 2148","line":"    FileSystem,"},
{"lineNum":" 2149","line":"    SymLinkLoop,"},
{"lineNum":" 2150","line":"    LinkQuotaExceeded,"},
{"lineNum":" 2151","line":"    NameTooLong,"},
{"lineNum":" 2152","line":"    FileNotFound,"},
{"lineNum":" 2153","line":"    SystemResources,"},
{"lineNum":" 2154","line":"    NoSpaceLeft,"},
{"lineNum":" 2155","line":"    ReadOnlyFileSystem,"},
{"lineNum":" 2156","line":"    NotSameFileSystem,"},
{"lineNum":" 2157","line":"};"},
{"lineNum":" 2158","line":""},
{"lineNum":" 2159","line":"pub fn linkZ(oldpath: [*:0]const u8, newpath: [*:0]const u8, flags: i32) LinkError!void {"},
{"lineNum":" 2160","line":"    if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 2161","line":"        return link(mem.sliceTo(oldpath, 0), mem.sliceTo(newpath, 0), flags);"},
{"lineNum":" 2162","line":"    }"},
{"lineNum":" 2163","line":"    switch (errno(system.link(oldpath, newpath, flags))) {"},
{"lineNum":" 2164","line":"        .SUCCESS => return,"},
{"lineNum":" 2165","line":"        .ACCES => return error.AccessDenied,"},
{"lineNum":" 2166","line":"        .DQUOT => return error.DiskQuota,"},
{"lineNum":" 2167","line":"        .EXIST => return error.PathAlreadyExists,"},
{"lineNum":" 2168","line":"        .FAULT => unreachable,"},
{"lineNum":" 2169","line":"        .IO => return error.FileSystem,"},
{"lineNum":" 2170","line":"        .LOOP => return error.SymLinkLoop,"},
{"lineNum":" 2171","line":"        .MLINK => return error.LinkQuotaExceeded,"},
{"lineNum":" 2172","line":"        .NAMETOOLONG => return error.NameTooLong,"},
{"lineNum":" 2173","line":"        .NOENT => return error.FileNotFound,"},
{"lineNum":" 2174","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 2175","line":"        .NOSPC => return error.NoSpaceLeft,"},
{"lineNum":" 2176","line":"        .PERM => return error.AccessDenied,"},
{"lineNum":" 2177","line":"        .ROFS => return error.ReadOnlyFileSystem,"},
{"lineNum":" 2178","line":"        .XDEV => return error.NotSameFileSystem,"},
{"lineNum":" 2179","line":"        .INVAL => unreachable,"},
{"lineNum":" 2180","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 2181","line":"    }"},
{"lineNum":" 2182","line":"}"},
{"lineNum":" 2183","line":""},
{"lineNum":" 2184","line":"pub fn link(oldpath: []const u8, newpath: []const u8, flags: i32) LinkError!void {"},
{"lineNum":" 2185","line":"    if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 2186","line":"        return linkat(wasi.AT.FDCWD, oldpath, wasi.AT.FDCWD, newpath, flags) catch |err| switch (err) {"},
{"lineNum":" 2187","line":"            error.NotDir => unreachable, // link() does not support directories"},
{"lineNum":" 2188","line":"            else => |e| return e,"},
{"lineNum":" 2189","line":"        };"},
{"lineNum":" 2190","line":"    }"},
{"lineNum":" 2191","line":"    const old = try toPosixPath(oldpath);"},
{"lineNum":" 2192","line":"    const new = try toPosixPath(newpath);"},
{"lineNum":" 2193","line":"    return try linkZ(&old, &new, flags);"},
{"lineNum":" 2194","line":"}"},
{"lineNum":" 2195","line":""},
{"lineNum":" 2196","line":"pub const LinkatError = LinkError || error{NotDir};"},
{"lineNum":" 2197","line":""},
{"lineNum":" 2198","line":"pub fn linkatZ("},
{"lineNum":" 2199","line":"    olddir: fd_t,"},
{"lineNum":" 2200","line":"    oldpath: [*:0]const u8,"},
{"lineNum":" 2201","line":"    newdir: fd_t,"},
{"lineNum":" 2202","line":"    newpath: [*:0]const u8,"},
{"lineNum":" 2203","line":"    flags: i32,"},
{"lineNum":" 2204","line":") LinkatError!void {"},
{"lineNum":" 2205","line":"    if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 2206","line":"        return linkat(olddir, mem.sliceTo(oldpath, 0), newdir, mem.sliceTo(newpath, 0), flags);"},
{"lineNum":" 2207","line":"    }"},
{"lineNum":" 2208","line":"    switch (errno(system.linkat(olddir, oldpath, newdir, newpath, flags))) {"},
{"lineNum":" 2209","line":"        .SUCCESS => return,"},
{"lineNum":" 2210","line":"        .ACCES => return error.AccessDenied,"},
{"lineNum":" 2211","line":"        .DQUOT => return error.DiskQuota,"},
{"lineNum":" 2212","line":"        .EXIST => return error.PathAlreadyExists,"},
{"lineNum":" 2213","line":"        .FAULT => unreachable,"},
{"lineNum":" 2214","line":"        .IO => return error.FileSystem,"},
{"lineNum":" 2215","line":"        .LOOP => return error.SymLinkLoop,"},
{"lineNum":" 2216","line":"        .MLINK => return error.LinkQuotaExceeded,"},
{"lineNum":" 2217","line":"        .NAMETOOLONG => return error.NameTooLong,"},
{"lineNum":" 2218","line":"        .NOENT => return error.FileNotFound,"},
{"lineNum":" 2219","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 2220","line":"        .NOSPC => return error.NoSpaceLeft,"},
{"lineNum":" 2221","line":"        .NOTDIR => return error.NotDir,"},
{"lineNum":" 2222","line":"        .PERM => return error.AccessDenied,"},
{"lineNum":" 2223","line":"        .ROFS => return error.ReadOnlyFileSystem,"},
{"lineNum":" 2224","line":"        .XDEV => return error.NotSameFileSystem,"},
{"lineNum":" 2225","line":"        .INVAL => unreachable,"},
{"lineNum":" 2226","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 2227","line":"    }"},
{"lineNum":" 2228","line":"}"},
{"lineNum":" 2229","line":""},
{"lineNum":" 2230","line":"pub fn linkat("},
{"lineNum":" 2231","line":"    olddir: fd_t,"},
{"lineNum":" 2232","line":"    oldpath: []const u8,"},
{"lineNum":" 2233","line":"    newdir: fd_t,"},
{"lineNum":" 2234","line":"    newpath: []const u8,"},
{"lineNum":" 2235","line":"    flags: i32,"},
{"lineNum":" 2236","line":") LinkatError!void {"},
{"lineNum":" 2237","line":"    if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 2238","line":"        const old: RelativePathWasi = .{ .dir_fd = olddir, .relative_path = oldpath };"},
{"lineNum":" 2239","line":"        const new: RelativePathWasi = .{ .dir_fd = newdir, .relative_path = newpath };"},
{"lineNum":" 2240","line":"        return linkatWasi(old, new, flags);"},
{"lineNum":" 2241","line":"    }"},
{"lineNum":" 2242","line":"    const old = try toPosixPath(oldpath);"},
{"lineNum":" 2243","line":"    const new = try toPosixPath(newpath);"},
{"lineNum":" 2244","line":"    return try linkatZ(olddir, &old, newdir, &new, flags);"},
{"lineNum":" 2245","line":"}"},
{"lineNum":" 2246","line":""},
{"lineNum":" 2247","line":"/// WASI-only. The same as `linkat` but targeting WASI."},
{"lineNum":" 2248","line":"/// See also `linkat`."},
{"lineNum":" 2249","line":"pub fn linkatWasi(old: RelativePathWasi, new: RelativePathWasi, flags: i32) LinkatError!void {"},
{"lineNum":" 2250","line":"    var old_flags: wasi.lookupflags_t = 0;"},
{"lineNum":" 2251","line":"    // TODO: Why is this not defined in wasi-libc?"},
{"lineNum":" 2252","line":"    if (flags & linux.AT.SYMLINK_FOLLOW != 0) old_flags |= wasi.LOOKUP_SYMLINK_FOLLOW;"},
{"lineNum":" 2253","line":""},
{"lineNum":" 2254","line":"    switch (wasi.path_link(old.dir_fd, old_flags, old.relative_path.ptr, old.relative_path.len, new.dir_fd, new.relative_path.ptr, new.relative_path.len)) {"},
{"lineNum":" 2255","line":"        .SUCCESS => return,"},
{"lineNum":" 2256","line":"        .ACCES => return error.AccessDenied,"},
{"lineNum":" 2257","line":"        .DQUOT => return error.DiskQuota,"},
{"lineNum":" 2258","line":"        .EXIST => return error.PathAlreadyExists,"},
{"lineNum":" 2259","line":"        .FAULT => unreachable,"},
{"lineNum":" 2260","line":"        .IO => return error.FileSystem,"},
{"lineNum":" 2261","line":"        .LOOP => return error.SymLinkLoop,"},
{"lineNum":" 2262","line":"        .MLINK => return error.LinkQuotaExceeded,"},
{"lineNum":" 2263","line":"        .NAMETOOLONG => return error.NameTooLong,"},
{"lineNum":" 2264","line":"        .NOENT => return error.FileNotFound,"},
{"lineNum":" 2265","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 2266","line":"        .NOSPC => return error.NoSpaceLeft,"},
{"lineNum":" 2267","line":"        .NOTDIR => return error.NotDir,"},
{"lineNum":" 2268","line":"        .PERM => return error.AccessDenied,"},
{"lineNum":" 2269","line":"        .ROFS => return error.ReadOnlyFileSystem,"},
{"lineNum":" 2270","line":"        .XDEV => return error.NotSameFileSystem,"},
{"lineNum":" 2271","line":"        .INVAL => unreachable,"},
{"lineNum":" 2272","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 2273","line":"    }"},
{"lineNum":" 2274","line":"}"},
{"lineNum":" 2275","line":""},
{"lineNum":" 2276","line":"pub const UnlinkError = error{"},
{"lineNum":" 2277","line":"    FileNotFound,"},
{"lineNum":" 2278","line":""},
{"lineNum":" 2279","line":"    /// In WASI, this error may occur when the file descriptor does"},
{"lineNum":" 2280","line":"    /// not hold the required rights to unlink a resource by path relative to it."},
{"lineNum":" 2281","line":"    AccessDenied,"},
{"lineNum":" 2282","line":"    FileBusy,"},
{"lineNum":" 2283","line":"    FileSystem,"},
{"lineNum":" 2284","line":"    IsDir,"},
{"lineNum":" 2285","line":"    SymLinkLoop,"},
{"lineNum":" 2286","line":"    NameTooLong,"},
{"lineNum":" 2287","line":"    NotDir,"},
{"lineNum":" 2288","line":"    SystemResources,"},
{"lineNum":" 2289","line":"    ReadOnlyFileSystem,"},
{"lineNum":" 2290","line":""},
{"lineNum":" 2291","line":"    /// On Windows, file paths must be valid Unicode."},
{"lineNum":" 2292","line":"    InvalidUtf8,"},
{"lineNum":" 2293","line":""},
{"lineNum":" 2294","line":"    /// On Windows, file paths cannot contain these characters:"},
{"lineNum":" 2295","line":"    /// \'/\', \'*\', \'?\', \'\"\', \'<\', \'>\', \'|\'"},
{"lineNum":" 2296","line":"    BadPathName,"},
{"lineNum":" 2297","line":""},
{"lineNum":" 2298","line":"    /// On Windows, `\\\\server` or `\\\\server\\share` was not found."},
{"lineNum":" 2299","line":"    NetworkNotFound,"},
{"lineNum":" 2300","line":"} || UnexpectedError;"},
{"lineNum":" 2301","line":""},
{"lineNum":" 2302","line":"/// Delete a name and possibly the file it refers to."},
{"lineNum":" 2303","line":"/// See also `unlinkZ`."},
{"lineNum":" 2304","line":"pub fn unlink(file_path: []const u8) UnlinkError!void {"},
{"lineNum":" 2305","line":"    if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 2306","line":"        return unlinkat(wasi.AT.FDCWD, file_path, 0) catch |err| switch (err) {"},
{"lineNum":" 2307","line":"            error.DirNotEmpty => unreachable, // only occurs when targeting directories"},
{"lineNum":" 2308","line":"            else => |e| return e,"},
{"lineNum":" 2309","line":"        };"},
{"lineNum":" 2310","line":"    } else if (builtin.os.tag == .windows) {"},
{"lineNum":" 2311","line":"        const file_path_w = try windows.sliceToPrefixedFileW(file_path);"},
{"lineNum":" 2312","line":"        return unlinkW(file_path_w.span());"},
{"lineNum":" 2313","line":"    } else {"},
{"lineNum":" 2314","line":"        const file_path_c = try toPosixPath(file_path);"},
{"lineNum":" 2315","line":"        return unlinkZ(&file_path_c);"},
{"lineNum":" 2316","line":"    }"},
{"lineNum":" 2317","line":"}"},
{"lineNum":" 2318","line":""},
{"lineNum":" 2319","line":"/// Same as `unlink` except the parameter is a null terminated UTF8-encoded string."},
{"lineNum":" 2320","line":"pub fn unlinkZ(file_path: [*:0]const u8) UnlinkError!void {"},
{"lineNum":" 2321","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 2322","line":"        const file_path_w = try windows.cStrToPrefixedFileW(file_path);"},
{"lineNum":" 2323","line":"        return unlinkW(file_path_w.span());"},
{"lineNum":" 2324","line":"    } else if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 2325","line":"        return unlink(mem.sliceTo(file_path, 0));"},
{"lineNum":" 2326","line":"    }"},
{"lineNum":" 2327","line":"    switch (errno(system.unlink(file_path))) {"},
{"lineNum":" 2328","line":"        .SUCCESS => return,"},
{"lineNum":" 2329","line":"        .ACCES => return error.AccessDenied,"},
{"lineNum":" 2330","line":"        .PERM => return error.AccessDenied,"},
{"lineNum":" 2331","line":"        .BUSY => return error.FileBusy,"},
{"lineNum":" 2332","line":"        .FAULT => unreachable,"},
{"lineNum":" 2333","line":"        .INVAL => unreachable,"},
{"lineNum":" 2334","line":"        .IO => return error.FileSystem,"},
{"lineNum":" 2335","line":"        .ISDIR => return error.IsDir,"},
{"lineNum":" 2336","line":"        .LOOP => return error.SymLinkLoop,"},
{"lineNum":" 2337","line":"        .NAMETOOLONG => return error.NameTooLong,"},
{"lineNum":" 2338","line":"        .NOENT => return error.FileNotFound,"},
{"lineNum":" 2339","line":"        .NOTDIR => return error.NotDir,"},
{"lineNum":" 2340","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 2341","line":"        .ROFS => return error.ReadOnlyFileSystem,"},
{"lineNum":" 2342","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 2343","line":"    }"},
{"lineNum":" 2344","line":"}"},
{"lineNum":" 2345","line":""},
{"lineNum":" 2346","line":"/// Windows-only. Same as `unlink` except the parameter is null-terminated, WTF16 encoded."},
{"lineNum":" 2347","line":"pub fn unlinkW(file_path_w: []const u16) UnlinkError!void {"},
{"lineNum":" 2348","line":"    return windows.DeleteFile(file_path_w, .{ .dir = std.fs.cwd().fd });"},
{"lineNum":" 2349","line":"}"},
{"lineNum":" 2350","line":""},
{"lineNum":" 2351","line":"pub const UnlinkatError = UnlinkError || error{"},
{"lineNum":" 2352","line":"    /// When passing `AT.REMOVEDIR`, this error occurs when the named directory is not empty."},
{"lineNum":" 2353","line":"    DirNotEmpty,"},
{"lineNum":" 2354","line":"};"},
{"lineNum":" 2355","line":""},
{"lineNum":" 2356","line":"/// Delete a file name and possibly the file it refers to, based on an open directory handle."},
{"lineNum":" 2357","line":"/// Asserts that the path parameter has no null bytes."},
{"lineNum":" 2358","line":"pub fn unlinkat(dirfd: fd_t, file_path: []const u8, flags: u32) UnlinkatError!void {"},
{"lineNum":" 2359","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 2360","line":"        const file_path_w = try windows.sliceToPrefixedFileW(file_path);"},
{"lineNum":" 2361","line":"        return unlinkatW(dirfd, file_path_w.span(), flags);"},
{"lineNum":" 2362","line":"    } else if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 2363","line":"        return unlinkatWasi(dirfd, file_path, flags);"},
{"lineNum":" 2364","line":"    } else {"},
{"lineNum":" 2365","line":"        const file_path_c = try toPosixPath(file_path);"},
{"lineNum":" 2366","line":"        return unlinkatZ(dirfd, &file_path_c, flags);"},
{"lineNum":" 2367","line":"    }"},
{"lineNum":" 2368","line":"}"},
{"lineNum":" 2369","line":""},
{"lineNum":" 2370","line":"/// WASI-only. Same as `unlinkat` but targeting WASI."},
{"lineNum":" 2371","line":"/// See also `unlinkat`."},
{"lineNum":" 2372","line":"pub fn unlinkatWasi(dirfd: fd_t, file_path: []const u8, flags: u32) UnlinkatError!void {"},
{"lineNum":" 2373","line":"    const remove_dir = (flags & AT.REMOVEDIR) != 0;"},
{"lineNum":" 2374","line":"    const res = if (remove_dir)"},
{"lineNum":" 2375","line":"        wasi.path_remove_directory(dirfd, file_path.ptr, file_path.len)"},
{"lineNum":" 2376","line":"    else"},
{"lineNum":" 2377","line":"        wasi.path_unlink_file(dirfd, file_path.ptr, file_path.len);"},
{"lineNum":" 2378","line":"    switch (res) {"},
{"lineNum":" 2379","line":"        .SUCCESS => return,"},
{"lineNum":" 2380","line":"        .ACCES => return error.AccessDenied,"},
{"lineNum":" 2381","line":"        .PERM => return error.AccessDenied,"},
{"lineNum":" 2382","line":"        .BUSY => return error.FileBusy,"},
{"lineNum":" 2383","line":"        .FAULT => unreachable,"},
{"lineNum":" 2384","line":"        .IO => return error.FileSystem,"},
{"lineNum":" 2385","line":"        .ISDIR => return error.IsDir,"},
{"lineNum":" 2386","line":"        .LOOP => return error.SymLinkLoop,"},
{"lineNum":" 2387","line":"        .NAMETOOLONG => return error.NameTooLong,"},
{"lineNum":" 2388","line":"        .NOENT => return error.FileNotFound,"},
{"lineNum":" 2389","line":"        .NOTDIR => return error.NotDir,"},
{"lineNum":" 2390","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 2391","line":"        .ROFS => return error.ReadOnlyFileSystem,"},
{"lineNum":" 2392","line":"        .NOTEMPTY => return error.DirNotEmpty,"},
{"lineNum":" 2393","line":"        .NOTCAPABLE => return error.AccessDenied,"},
{"lineNum":" 2394","line":""},
{"lineNum":" 2395","line":"        .INVAL => unreachable, // invalid flags, or pathname has . as last component"},
{"lineNum":" 2396","line":"        .BADF => unreachable, // always a race condition"},
{"lineNum":" 2397","line":""},
{"lineNum":" 2398","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 2399","line":"    }"},
{"lineNum":" 2400","line":"}"},
{"lineNum":" 2401","line":""},
{"lineNum":" 2402","line":"/// Same as `unlinkat` but `file_path` is a null-terminated string."},
{"lineNum":" 2403","line":"pub fn unlinkatZ(dirfd: fd_t, file_path_c: [*:0]const u8, flags: u32) UnlinkatError!void {"},
{"lineNum":" 2404","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 2405","line":"        const file_path_w = try windows.cStrToPrefixedFileW(file_path_c);"},
{"lineNum":" 2406","line":"        return unlinkatW(dirfd, file_path_w.span(), flags);"},
{"lineNum":" 2407","line":"    } else if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 2408","line":"        return unlinkat(dirfd, mem.sliceTo(file_path_c, 0), flags);"},
{"lineNum":" 2409","line":"    }"},
{"lineNum":" 2410","line":"    switch (errno(system.unlinkat(dirfd, file_path_c, flags))) {"},
{"lineNum":" 2411","line":"        .SUCCESS => return,"},
{"lineNum":" 2412","line":"        .ACCES => return error.AccessDenied,"},
{"lineNum":" 2413","line":"        .PERM => return error.AccessDenied,"},
{"lineNum":" 2414","line":"        .BUSY => return error.FileBusy,"},
{"lineNum":" 2415","line":"        .FAULT => unreachable,"},
{"lineNum":" 2416","line":"        .IO => return error.FileSystem,"},
{"lineNum":" 2417","line":"        .ISDIR => return error.IsDir,"},
{"lineNum":" 2418","line":"        .LOOP => return error.SymLinkLoop,"},
{"lineNum":" 2419","line":"        .NAMETOOLONG => return error.NameTooLong,"},
{"lineNum":" 2420","line":"        .NOENT => return error.FileNotFound,"},
{"lineNum":" 2421","line":"        .NOTDIR => return error.NotDir,"},
{"lineNum":" 2422","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 2423","line":"        .ROFS => return error.ReadOnlyFileSystem,"},
{"lineNum":" 2424","line":"        .EXIST => return error.DirNotEmpty,"},
{"lineNum":" 2425","line":"        .NOTEMPTY => return error.DirNotEmpty,"},
{"lineNum":" 2426","line":""},
{"lineNum":" 2427","line":"        .INVAL => unreachable, // invalid flags, or pathname has . as last component"},
{"lineNum":" 2428","line":"        .BADF => unreachable, // always a race condition"},
{"lineNum":" 2429","line":""},
{"lineNum":" 2430","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 2431","line":"    }"},
{"lineNum":" 2432","line":"}"},
{"lineNum":" 2433","line":""},
{"lineNum":" 2434","line":"/// Same as `unlinkat` but `sub_path_w` is UTF16LE, NT prefixed. Windows only."},
{"lineNum":" 2435","line":"pub fn unlinkatW(dirfd: fd_t, sub_path_w: []const u16, flags: u32) UnlinkatError!void {"},
{"lineNum":" 2436","line":"    const remove_dir = (flags & AT.REMOVEDIR) != 0;"},
{"lineNum":" 2437","line":"    return windows.DeleteFile(sub_path_w, .{ .dir = dirfd, .remove_dir = remove_dir });"},
{"lineNum":" 2438","line":"}"},
{"lineNum":" 2439","line":""},
{"lineNum":" 2440","line":"pub const RenameError = error{"},
{"lineNum":" 2441","line":"    /// In WASI, this error may occur when the file descriptor does"},
{"lineNum":" 2442","line":"    /// not hold the required rights to rename a resource by path relative to it."},
{"lineNum":" 2443","line":"    ///"},
{"lineNum":" 2444","line":"    /// On Windows, this error may be returned instead of PathAlreadyExists when"},
{"lineNum":" 2445","line":"    /// renaming a directory over an existing directory."},
{"lineNum":" 2446","line":"    AccessDenied,"},
{"lineNum":" 2447","line":"    FileBusy,"},
{"lineNum":" 2448","line":"    DiskQuota,"},
{"lineNum":" 2449","line":"    IsDir,"},
{"lineNum":" 2450","line":"    SymLinkLoop,"},
{"lineNum":" 2451","line":"    LinkQuotaExceeded,"},
{"lineNum":" 2452","line":"    NameTooLong,"},
{"lineNum":" 2453","line":"    FileNotFound,"},
{"lineNum":" 2454","line":"    NotDir,"},
{"lineNum":" 2455","line":"    SystemResources,"},
{"lineNum":" 2456","line":"    NoSpaceLeft,"},
{"lineNum":" 2457","line":"    PathAlreadyExists,"},
{"lineNum":" 2458","line":"    ReadOnlyFileSystem,"},
{"lineNum":" 2459","line":"    RenameAcrossMountPoints,"},
{"lineNum":" 2460","line":"    InvalidUtf8,"},
{"lineNum":" 2461","line":"    BadPathName,"},
{"lineNum":" 2462","line":"    NoDevice,"},
{"lineNum":" 2463","line":"    SharingViolation,"},
{"lineNum":" 2464","line":"    PipeBusy,"},
{"lineNum":" 2465","line":"    /// On Windows, `\\\\server` or `\\\\server\\share` was not found."},
{"lineNum":" 2466","line":"    NetworkNotFound,"},
{"lineNum":" 2467","line":"} || UnexpectedError;"},
{"lineNum":" 2468","line":""},
{"lineNum":" 2469","line":"/// Change the name or location of a file."},
{"lineNum":" 2470","line":"pub fn rename(old_path: []const u8, new_path: []const u8) RenameError!void {"},
{"lineNum":" 2471","line":"    if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 2472","line":"        return renameat(wasi.AT.FDCWD, old_path, wasi.AT.FDCWD, new_path);"},
{"lineNum":" 2473","line":"    } else if (builtin.os.tag == .windows) {"},
{"lineNum":" 2474","line":"        const old_path_w = try windows.sliceToPrefixedFileW(old_path);"},
{"lineNum":" 2475","line":"        const new_path_w = try windows.sliceToPrefixedFileW(new_path);"},
{"lineNum":" 2476","line":"        return renameW(old_path_w.span().ptr, new_path_w.span().ptr);"},
{"lineNum":" 2477","line":"    } else {"},
{"lineNum":" 2478","line":"        const old_path_c = try toPosixPath(old_path);"},
{"lineNum":" 2479","line":"        const new_path_c = try toPosixPath(new_path);"},
{"lineNum":" 2480","line":"        return renameZ(&old_path_c, &new_path_c);"},
{"lineNum":" 2481","line":"    }"},
{"lineNum":" 2482","line":"}"},
{"lineNum":" 2483","line":""},
{"lineNum":" 2484","line":"/// Same as `rename` except the parameters are null-terminated byte arrays."},
{"lineNum":" 2485","line":"pub fn renameZ(old_path: [*:0]const u8, new_path: [*:0]const u8) RenameError!void {"},
{"lineNum":" 2486","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 2487","line":"        const old_path_w = try windows.cStrToPrefixedFileW(old_path);"},
{"lineNum":" 2488","line":"        const new_path_w = try windows.cStrToPrefixedFileW(new_path);"},
{"lineNum":" 2489","line":"        return renameW(old_path_w.span().ptr, new_path_w.span().ptr);"},
{"lineNum":" 2490","line":"    } else if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 2491","line":"        return rename(mem.sliceTo(old_path, 0), mem.sliceTo(new_path, 0));"},
{"lineNum":" 2492","line":"    }"},
{"lineNum":" 2493","line":"    switch (errno(system.rename(old_path, new_path))) {"},
{"lineNum":" 2494","line":"        .SUCCESS => return,"},
{"lineNum":" 2495","line":"        .ACCES => return error.AccessDenied,"},
{"lineNum":" 2496","line":"        .PERM => return error.AccessDenied,"},
{"lineNum":" 2497","line":"        .BUSY => return error.FileBusy,"},
{"lineNum":" 2498","line":"        .DQUOT => return error.DiskQuota,"},
{"lineNum":" 2499","line":"        .FAULT => unreachable,"},
{"lineNum":" 2500","line":"        .INVAL => unreachable,"},
{"lineNum":" 2501","line":"        .ISDIR => return error.IsDir,"},
{"lineNum":" 2502","line":"        .LOOP => return error.SymLinkLoop,"},
{"lineNum":" 2503","line":"        .MLINK => return error.LinkQuotaExceeded,"},
{"lineNum":" 2504","line":"        .NAMETOOLONG => return error.NameTooLong,"},
{"lineNum":" 2505","line":"        .NOENT => return error.FileNotFound,"},
{"lineNum":" 2506","line":"        .NOTDIR => return error.NotDir,"},
{"lineNum":" 2507","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 2508","line":"        .NOSPC => return error.NoSpaceLeft,"},
{"lineNum":" 2509","line":"        .EXIST => return error.PathAlreadyExists,"},
{"lineNum":" 2510","line":"        .NOTEMPTY => return error.PathAlreadyExists,"},
{"lineNum":" 2511","line":"        .ROFS => return error.ReadOnlyFileSystem,"},
{"lineNum":" 2512","line":"        .XDEV => return error.RenameAcrossMountPoints,"},
{"lineNum":" 2513","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 2514","line":"    }"},
{"lineNum":" 2515","line":"}"},
{"lineNum":" 2516","line":""},
{"lineNum":" 2517","line":"/// Same as `rename` except the parameters are null-terminated UTF16LE encoded byte arrays."},
{"lineNum":" 2518","line":"/// Assumes target is Windows."},
{"lineNum":" 2519","line":"pub fn renameW(old_path: [*:0]const u16, new_path: [*:0]const u16) RenameError!void {"},
{"lineNum":" 2520","line":"    const flags = windows.MOVEFILE_REPLACE_EXISTING | windows.MOVEFILE_WRITE_THROUGH;"},
{"lineNum":" 2521","line":"    return windows.MoveFileExW(old_path, new_path, flags);"},
{"lineNum":" 2522","line":"}"},
{"lineNum":" 2523","line":""},
{"lineNum":" 2524","line":"/// Change the name or location of a file based on an open directory handle."},
{"lineNum":" 2525","line":"pub fn renameat("},
{"lineNum":" 2526","line":"    old_dir_fd: fd_t,"},
{"lineNum":" 2527","line":"    old_path: []const u8,"},
{"lineNum":" 2528","line":"    new_dir_fd: fd_t,"},
{"lineNum":" 2529","line":"    new_path: []const u8,"},
{"lineNum":" 2530","line":") RenameError!void {"},
{"lineNum":" 2531","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 2532","line":"        const old_path_w = try windows.sliceToPrefixedFileW(old_path);"},
{"lineNum":" 2533","line":"        const new_path_w = try windows.sliceToPrefixedFileW(new_path);"},
{"lineNum":" 2534","line":"        return renameatW(old_dir_fd, old_path_w.span(), new_dir_fd, new_path_w.span(), windows.TRUE);"},
{"lineNum":" 2535","line":"    } else if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 2536","line":"        const old: RelativePathWasi = .{ .dir_fd = old_dir_fd, .relative_path = old_path };"},
{"lineNum":" 2537","line":"        const new: RelativePathWasi = .{ .dir_fd = new_dir_fd, .relative_path = new_path };"},
{"lineNum":" 2538","line":"        return renameatWasi(old, new);"},
{"lineNum":" 2539","line":"    } else {"},
{"lineNum":" 2540","line":"        const old_path_c = try toPosixPath(old_path);"},
{"lineNum":" 2541","line":"        const new_path_c = try toPosixPath(new_path);"},
{"lineNum":" 2542","line":"        return renameatZ(old_dir_fd, &old_path_c, new_dir_fd, &new_path_c);"},
{"lineNum":" 2543","line":"    }"},
{"lineNum":" 2544","line":"}"},
{"lineNum":" 2545","line":""},
{"lineNum":" 2546","line":"/// WASI-only. Same as `renameat` expect targeting WASI."},
{"lineNum":" 2547","line":"/// See also `renameat`."},
{"lineNum":" 2548","line":"pub fn renameatWasi(old: RelativePathWasi, new: RelativePathWasi) RenameError!void {"},
{"lineNum":" 2549","line":"    switch (wasi.path_rename(old.dir_fd, old.relative_path.ptr, old.relative_path.len, new.dir_fd, new.relative_path.ptr, new.relative_path.len)) {"},
{"lineNum":" 2550","line":"        .SUCCESS => return,"},
{"lineNum":" 2551","line":"        .ACCES => return error.AccessDenied,"},
{"lineNum":" 2552","line":"        .PERM => return error.AccessDenied,"},
{"lineNum":" 2553","line":"        .BUSY => return error.FileBusy,"},
{"lineNum":" 2554","line":"        .DQUOT => return error.DiskQuota,"},
{"lineNum":" 2555","line":"        .FAULT => unreachable,"},
{"lineNum":" 2556","line":"        .INVAL => unreachable,"},
{"lineNum":" 2557","line":"        .ISDIR => return error.IsDir,"},
{"lineNum":" 2558","line":"        .LOOP => return error.SymLinkLoop,"},
{"lineNum":" 2559","line":"        .MLINK => return error.LinkQuotaExceeded,"},
{"lineNum":" 2560","line":"        .NAMETOOLONG => return error.NameTooLong,"},
{"lineNum":" 2561","line":"        .NOENT => return error.FileNotFound,"},
{"lineNum":" 2562","line":"        .NOTDIR => return error.NotDir,"},
{"lineNum":" 2563","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 2564","line":"        .NOSPC => return error.NoSpaceLeft,"},
{"lineNum":" 2565","line":"        .EXIST => return error.PathAlreadyExists,"},
{"lineNum":" 2566","line":"        .NOTEMPTY => return error.PathAlreadyExists,"},
{"lineNum":" 2567","line":"        .ROFS => return error.ReadOnlyFileSystem,"},
{"lineNum":" 2568","line":"        .XDEV => return error.RenameAcrossMountPoints,"},
{"lineNum":" 2569","line":"        .NOTCAPABLE => return error.AccessDenied,"},
{"lineNum":" 2570","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 2571","line":"    }"},
{"lineNum":" 2572","line":"}"},
{"lineNum":" 2573","line":""},
{"lineNum":" 2574","line":"/// Same as `renameat` except the parameters are null-terminated byte arrays."},
{"lineNum":" 2575","line":"pub fn renameatZ("},
{"lineNum":" 2576","line":"    old_dir_fd: fd_t,"},
{"lineNum":" 2577","line":"    old_path: [*:0]const u8,"},
{"lineNum":" 2578","line":"    new_dir_fd: fd_t,"},
{"lineNum":" 2579","line":"    new_path: [*:0]const u8,"},
{"lineNum":" 2580","line":") RenameError!void {"},
{"lineNum":" 2581","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 2582","line":"        const old_path_w = try windows.cStrToPrefixedFileW(old_path);"},
{"lineNum":" 2583","line":"        const new_path_w = try windows.cStrToPrefixedFileW(new_path);"},
{"lineNum":" 2584","line":"        return renameatW(old_dir_fd, old_path_w.span(), new_dir_fd, new_path_w.span(), windows.TRUE);"},
{"lineNum":" 2585","line":"    } else if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 2586","line":"        return renameat(old_dir_fd, mem.sliceTo(old_path, 0), new_dir_fd, mem.sliceTo(new_path, 0));"},
{"lineNum":" 2587","line":"    }"},
{"lineNum":" 2588","line":""},
{"lineNum":" 2589","line":"    switch (errno(system.renameat(old_dir_fd, old_path, new_dir_fd, new_path))) {"},
{"lineNum":" 2590","line":"        .SUCCESS => return,"},
{"lineNum":" 2591","line":"        .ACCES => return error.AccessDenied,"},
{"lineNum":" 2592","line":"        .PERM => return error.AccessDenied,"},
{"lineNum":" 2593","line":"        .BUSY => return error.FileBusy,"},
{"lineNum":" 2594","line":"        .DQUOT => return error.DiskQuota,"},
{"lineNum":" 2595","line":"        .FAULT => unreachable,"},
{"lineNum":" 2596","line":"        .INVAL => unreachable,"},
{"lineNum":" 2597","line":"        .ISDIR => return error.IsDir,"},
{"lineNum":" 2598","line":"        .LOOP => return error.SymLinkLoop,"},
{"lineNum":" 2599","line":"        .MLINK => return error.LinkQuotaExceeded,"},
{"lineNum":" 2600","line":"        .NAMETOOLONG => return error.NameTooLong,"},
{"lineNum":" 2601","line":"        .NOENT => return error.FileNotFound,"},
{"lineNum":" 2602","line":"        .NOTDIR => return error.NotDir,"},
{"lineNum":" 2603","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 2604","line":"        .NOSPC => return error.NoSpaceLeft,"},
{"lineNum":" 2605","line":"        .EXIST => return error.PathAlreadyExists,"},
{"lineNum":" 2606","line":"        .NOTEMPTY => return error.PathAlreadyExists,"},
{"lineNum":" 2607","line":"        .ROFS => return error.ReadOnlyFileSystem,"},
{"lineNum":" 2608","line":"        .XDEV => return error.RenameAcrossMountPoints,"},
{"lineNum":" 2609","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 2610","line":"    }"},
{"lineNum":" 2611","line":"}"},
{"lineNum":" 2612","line":""},
{"lineNum":" 2613","line":"/// Same as `renameat` but Windows-only and the path parameters are"},
{"lineNum":" 2614","line":"/// [WTF-16](https://simonsapin.github.io/wtf-8/#potentially-ill-formed-utf-16) encoded."},
{"lineNum":" 2615","line":"pub fn renameatW("},
{"lineNum":" 2616","line":"    old_dir_fd: fd_t,"},
{"lineNum":" 2617","line":"    old_path_w: []const u16,"},
{"lineNum":" 2618","line":"    new_dir_fd: fd_t,"},
{"lineNum":" 2619","line":"    new_path_w: []const u16,"},
{"lineNum":" 2620","line":"    ReplaceIfExists: windows.BOOLEAN,"},
{"lineNum":" 2621","line":") RenameError!void {"},
{"lineNum":" 2622","line":"    const src_fd = windows.OpenFile(old_path_w, .{"},
{"lineNum":" 2623","line":"        .dir = old_dir_fd,"},
{"lineNum":" 2624","line":"        .access_mask = windows.SYNCHRONIZE | windows.GENERIC_WRITE | windows.DELETE,"},
{"lineNum":" 2625","line":"        .creation = windows.FILE_OPEN,"},
{"lineNum":" 2626","line":"        .io_mode = .blocking,"},
{"lineNum":" 2627","line":"        .filter = .any, // This function is supposed to rename both files and directories."},
{"lineNum":" 2628","line":"        .follow_symlinks = false,"},
{"lineNum":" 2629","line":"    }) catch |err| switch (err) {"},
{"lineNum":" 2630","line":"        error.WouldBlock => unreachable, // Not possible without `.share_access_nonblocking = true`."},
{"lineNum":" 2631","line":"        else => |e| return e,"},
{"lineNum":" 2632","line":"    };"},
{"lineNum":" 2633","line":"    defer windows.CloseHandle(src_fd);"},
{"lineNum":" 2634","line":""},
{"lineNum":" 2635","line":"    const struct_buf_len = @sizeOf(windows.FILE_RENAME_INFORMATION) + (MAX_PATH_BYTES - 1);"},
{"lineNum":" 2636","line":"    var rename_info_buf: [struct_buf_len]u8 align(@alignOf(windows.FILE_RENAME_INFORMATION)) = undefined;"},
{"lineNum":" 2637","line":"    const struct_len = @sizeOf(windows.FILE_RENAME_INFORMATION) - 1 + new_path_w.len * 2;"},
{"lineNum":" 2638","line":"    if (struct_len > struct_buf_len) return error.NameTooLong;"},
{"lineNum":" 2639","line":""},
{"lineNum":" 2640","line":"    const rename_info = @as(*windows.FILE_RENAME_INFORMATION, @ptrCast(&rename_info_buf));"},
{"lineNum":" 2641","line":""},
{"lineNum":" 2642","line":"    rename_info.* = .{"},
{"lineNum":" 2643","line":"        .ReplaceIfExists = ReplaceIfExists,"},
{"lineNum":" 2644","line":"        .RootDirectory = if (std.fs.path.isAbsoluteWindowsWTF16(new_path_w)) null else new_dir_fd,"},
{"lineNum":" 2645","line":"        .FileNameLength = @as(u32, @intCast(new_path_w.len * 2)), // already checked error.NameTooLong"},
{"lineNum":" 2646","line":"        .FileName = undefined,"},
{"lineNum":" 2647","line":"    };"},
{"lineNum":" 2648","line":"    @memcpy(@as([*]u16, &rename_info.FileName)[0..new_path_w.len], new_path_w);"},
{"lineNum":" 2649","line":""},
{"lineNum":" 2650","line":"    var io_status_block: windows.IO_STATUS_BLOCK = undefined;"},
{"lineNum":" 2651","line":""},
{"lineNum":" 2652","line":"    const rc = windows.ntdll.NtSetInformationFile("},
{"lineNum":" 2653","line":"        src_fd,"},
{"lineNum":" 2654","line":"        &io_status_block,"},
{"lineNum":" 2655","line":"        rename_info,"},
{"lineNum":" 2656","line":"        @as(u32, @intCast(struct_len)), // already checked for error.NameTooLong"},
{"lineNum":" 2657","line":"        .FileRenameInformation,"},
{"lineNum":" 2658","line":"    );"},
{"lineNum":" 2659","line":""},
{"lineNum":" 2660","line":"    switch (rc) {"},
{"lineNum":" 2661","line":"        .SUCCESS => return,"},
{"lineNum":" 2662","line":"        .INVALID_HANDLE => unreachable,"},
{"lineNum":" 2663","line":"        .INVALID_PARAMETER => unreachable,"},
{"lineNum":" 2664","line":"        .OBJECT_PATH_SYNTAX_BAD => unreachable,"},
{"lineNum":" 2665","line":"        .ACCESS_DENIED => return error.AccessDenied,"},
{"lineNum":" 2666","line":"        .OBJECT_NAME_NOT_FOUND => return error.FileNotFound,"},
{"lineNum":" 2667","line":"        .OBJECT_PATH_NOT_FOUND => return error.FileNotFound,"},
{"lineNum":" 2668","line":"        .NOT_SAME_DEVICE => return error.RenameAcrossMountPoints,"},
{"lineNum":" 2669","line":"        .OBJECT_NAME_COLLISION => return error.PathAlreadyExists,"},
{"lineNum":" 2670","line":"        else => return windows.unexpectedStatus(rc),"},
{"lineNum":" 2671","line":"    }"},
{"lineNum":" 2672","line":"}"},
{"lineNum":" 2673","line":""},
{"lineNum":" 2674","line":"pub fn mkdirat(dir_fd: fd_t, sub_dir_path: []const u8, mode: u32) MakeDirError!void {"},
{"lineNum":" 2675","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 2676","line":"        const sub_dir_path_w = try windows.sliceToPrefixedFileW(sub_dir_path);"},
{"lineNum":" 2677","line":"        return mkdiratW(dir_fd, sub_dir_path_w.span(), mode);"},
{"lineNum":" 2678","line":"    } else if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 2679","line":"        return mkdiratWasi(dir_fd, sub_dir_path, mode);"},
{"lineNum":" 2680","line":"    } else {"},
{"lineNum":" 2681","line":"        const sub_dir_path_c = try toPosixPath(sub_dir_path);"},
{"lineNum":" 2682","line":"        return mkdiratZ(dir_fd, &sub_dir_path_c, mode);"},
{"lineNum":" 2683","line":"    }"},
{"lineNum":" 2684","line":"}"},
{"lineNum":" 2685","line":""},
{"lineNum":" 2686","line":"pub fn mkdiratWasi(dir_fd: fd_t, sub_dir_path: []const u8, mode: u32) MakeDirError!void {"},
{"lineNum":" 2687","line":"    _ = mode;"},
{"lineNum":" 2688","line":"    switch (wasi.path_create_directory(dir_fd, sub_dir_path.ptr, sub_dir_path.len)) {"},
{"lineNum":" 2689","line":"        .SUCCESS => return,"},
{"lineNum":" 2690","line":"        .ACCES => return error.AccessDenied,"},
{"lineNum":" 2691","line":"        .BADF => unreachable,"},
{"lineNum":" 2692","line":"        .PERM => return error.AccessDenied,"},
{"lineNum":" 2693","line":"        .DQUOT => return error.DiskQuota,"},
{"lineNum":" 2694","line":"        .EXIST => return error.PathAlreadyExists,"},
{"lineNum":" 2695","line":"        .FAULT => unreachable,"},
{"lineNum":" 2696","line":"        .LOOP => return error.SymLinkLoop,"},
{"lineNum":" 2697","line":"        .MLINK => return error.LinkQuotaExceeded,"},
{"lineNum":" 2698","line":"        .NAMETOOLONG => return error.NameTooLong,"},
{"lineNum":" 2699","line":"        .NOENT => return error.FileNotFound,"},
{"lineNum":" 2700","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 2701","line":"        .NOSPC => return error.NoSpaceLeft,"},
{"lineNum":" 2702","line":"        .NOTDIR => return error.NotDir,"},
{"lineNum":" 2703","line":"        .ROFS => return error.ReadOnlyFileSystem,"},
{"lineNum":" 2704","line":"        .NOTCAPABLE => return error.AccessDenied,"},
{"lineNum":" 2705","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 2706","line":"    }"},
{"lineNum":" 2707","line":"}"},
{"lineNum":" 2708","line":""},
{"lineNum":" 2709","line":"pub fn mkdiratZ(dir_fd: fd_t, sub_dir_path: [*:0]const u8, mode: u32) MakeDirError!void {"},
{"lineNum":" 2710","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 2711","line":"        const sub_dir_path_w = try windows.cStrToPrefixedFileW(sub_dir_path);"},
{"lineNum":" 2712","line":"        return mkdiratW(dir_fd, sub_dir_path_w.span().ptr, mode);"},
{"lineNum":" 2713","line":"    } else if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 2714","line":"        return mkdirat(dir_fd, mem.sliceTo(sub_dir_path, 0), mode);"},
{"lineNum":" 2715","line":"    }"},
{"lineNum":" 2716","line":"    switch (errno(system.mkdirat(dir_fd, sub_dir_path, mode))) {"},
{"lineNum":" 2717","line":"        .SUCCESS => return,"},
{"lineNum":" 2718","line":"        .ACCES => return error.AccessDenied,"},
{"lineNum":" 2719","line":"        .BADF => unreachable,"},
{"lineNum":" 2720","line":"        .PERM => return error.AccessDenied,"},
{"lineNum":" 2721","line":"        .DQUOT => return error.DiskQuota,"},
{"lineNum":" 2722","line":"        .EXIST => return error.PathAlreadyExists,"},
{"lineNum":" 2723","line":"        .FAULT => unreachable,"},
{"lineNum":" 2724","line":"        .LOOP => return error.SymLinkLoop,"},
{"lineNum":" 2725","line":"        .MLINK => return error.LinkQuotaExceeded,"},
{"lineNum":" 2726","line":"        .NAMETOOLONG => return error.NameTooLong,"},
{"lineNum":" 2727","line":"        .NOENT => return error.FileNotFound,"},
{"lineNum":" 2728","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 2729","line":"        .NOSPC => return error.NoSpaceLeft,"},
{"lineNum":" 2730","line":"        .NOTDIR => return error.NotDir,"},
{"lineNum":" 2731","line":"        .ROFS => return error.ReadOnlyFileSystem,"},
{"lineNum":" 2732","line":"        // dragonfly: when dir_fd is unlinked from filesystem"},
{"lineNum":" 2733","line":"        .NOTCONN => return error.FileNotFound,"},
{"lineNum":" 2734","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 2735","line":"    }"},
{"lineNum":" 2736","line":"}"},
{"lineNum":" 2737","line":""},
{"lineNum":" 2738","line":"pub fn mkdiratW(dir_fd: fd_t, sub_path_w: []const u16, mode: u32) MakeDirError!void {"},
{"lineNum":" 2739","line":"    _ = mode;"},
{"lineNum":" 2740","line":"    const sub_dir_handle = windows.OpenFile(sub_path_w, .{"},
{"lineNum":" 2741","line":"        .dir = dir_fd,"},
{"lineNum":" 2742","line":"        .access_mask = windows.GENERIC_READ | windows.SYNCHRONIZE,"},
{"lineNum":" 2743","line":"        .creation = windows.FILE_CREATE,"},
{"lineNum":" 2744","line":"        .io_mode = .blocking,"},
{"lineNum":" 2745","line":"        .filter = .dir_only,"},
{"lineNum":" 2746","line":"    }) catch |err| switch (err) {"},
{"lineNum":" 2747","line":"        error.IsDir => unreachable,"},
{"lineNum":" 2748","line":"        error.PipeBusy => unreachable,"},
{"lineNum":" 2749","line":"        error.WouldBlock => unreachable,"},
{"lineNum":" 2750","line":"        else => |e| return e,"},
{"lineNum":" 2751","line":"    };"},
{"lineNum":" 2752","line":"    windows.CloseHandle(sub_dir_handle);"},
{"lineNum":" 2753","line":"}"},
{"lineNum":" 2754","line":""},
{"lineNum":" 2755","line":"pub const MakeDirError = error{"},
{"lineNum":" 2756","line":"    /// In WASI, this error may occur when the file descriptor does"},
{"lineNum":" 2757","line":"    /// not hold the required rights to create a new directory relative to it."},
{"lineNum":" 2758","line":"    AccessDenied,"},
{"lineNum":" 2759","line":"    DiskQuota,"},
{"lineNum":" 2760","line":"    PathAlreadyExists,"},
{"lineNum":" 2761","line":"    SymLinkLoop,"},
{"lineNum":" 2762","line":"    LinkQuotaExceeded,"},
{"lineNum":" 2763","line":"    NameTooLong,"},
{"lineNum":" 2764","line":"    FileNotFound,"},
{"lineNum":" 2765","line":"    SystemResources,"},
{"lineNum":" 2766","line":"    NoSpaceLeft,"},
{"lineNum":" 2767","line":"    NotDir,"},
{"lineNum":" 2768","line":"    ReadOnlyFileSystem,"},
{"lineNum":" 2769","line":"    InvalidUtf8,"},
{"lineNum":" 2770","line":"    BadPathName,"},
{"lineNum":" 2771","line":"    NoDevice,"},
{"lineNum":" 2772","line":"    /// On Windows, `\\\\server` or `\\\\server\\share` was not found."},
{"lineNum":" 2773","line":"    NetworkNotFound,"},
{"lineNum":" 2774","line":"} || UnexpectedError;"},
{"lineNum":" 2775","line":""},
{"lineNum":" 2776","line":"/// Create a directory."},
{"lineNum":" 2777","line":"/// `mode` is ignored on Windows and WASI."},
{"lineNum":" 2778","line":"pub fn mkdir(dir_path: []const u8, mode: u32) MakeDirError!void {"},
{"lineNum":" 2779","line":"    if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 2780","line":"        return mkdirat(wasi.AT.FDCWD, dir_path, mode);"},
{"lineNum":" 2781","line":"    } else if (builtin.os.tag == .windows) {"},
{"lineNum":" 2782","line":"        const dir_path_w = try windows.sliceToPrefixedFileW(dir_path);"},
{"lineNum":" 2783","line":"        return mkdirW(dir_path_w.span(), mode);"},
{"lineNum":" 2784","line":"    } else {"},
{"lineNum":" 2785","line":"        const dir_path_c = try toPosixPath(dir_path);"},
{"lineNum":" 2786","line":"        return mkdirZ(&dir_path_c, mode);"},
{"lineNum":" 2787","line":"    }"},
{"lineNum":" 2788","line":"}"},
{"lineNum":" 2789","line":""},
{"lineNum":" 2790","line":"/// Same as `mkdir` but the parameter is a null-terminated UTF8-encoded string."},
{"lineNum":" 2791","line":"pub fn mkdirZ(dir_path: [*:0]const u8, mode: u32) MakeDirError!void {"},
{"lineNum":" 2792","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 2793","line":"        const dir_path_w = try windows.cStrToPrefixedFileW(dir_path);"},
{"lineNum":" 2794","line":"        return mkdirW(dir_path_w.span(), mode);"},
{"lineNum":" 2795","line":"    } else if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 2796","line":"        return mkdir(mem.sliceTo(dir_path, 0), mode);"},
{"lineNum":" 2797","line":"    }"},
{"lineNum":" 2798","line":"    switch (errno(system.mkdir(dir_path, mode))) {"},
{"lineNum":" 2799","line":"        .SUCCESS => return,"},
{"lineNum":" 2800","line":"        .ACCES => return error.AccessDenied,"},
{"lineNum":" 2801","line":"        .PERM => return error.AccessDenied,"},
{"lineNum":" 2802","line":"        .DQUOT => return error.DiskQuota,"},
{"lineNum":" 2803","line":"        .EXIST => return error.PathAlreadyExists,"},
{"lineNum":" 2804","line":"        .FAULT => unreachable,"},
{"lineNum":" 2805","line":"        .LOOP => return error.SymLinkLoop,"},
{"lineNum":" 2806","line":"        .MLINK => return error.LinkQuotaExceeded,"},
{"lineNum":" 2807","line":"        .NAMETOOLONG => return error.NameTooLong,"},
{"lineNum":" 2808","line":"        .NOENT => return error.FileNotFound,"},
{"lineNum":" 2809","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 2810","line":"        .NOSPC => return error.NoSpaceLeft,"},
{"lineNum":" 2811","line":"        .NOTDIR => return error.NotDir,"},
{"lineNum":" 2812","line":"        .ROFS => return error.ReadOnlyFileSystem,"},
{"lineNum":" 2813","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 2814","line":"    }"},
{"lineNum":" 2815","line":"}"},
{"lineNum":" 2816","line":""},
{"lineNum":" 2817","line":"/// Windows-only. Same as `mkdir` but the parameters is  WTF16 encoded."},
{"lineNum":" 2818","line":"pub fn mkdirW(dir_path_w: []const u16, mode: u32) MakeDirError!void {"},
{"lineNum":" 2819","line":"    _ = mode;"},
{"lineNum":" 2820","line":"    const sub_dir_handle = windows.OpenFile(dir_path_w, .{"},
{"lineNum":" 2821","line":"        .dir = std.fs.cwd().fd,"},
{"lineNum":" 2822","line":"        .access_mask = windows.GENERIC_READ | windows.SYNCHRONIZE,"},
{"lineNum":" 2823","line":"        .creation = windows.FILE_CREATE,"},
{"lineNum":" 2824","line":"        .io_mode = .blocking,"},
{"lineNum":" 2825","line":"        .filter = .dir_only,"},
{"lineNum":" 2826","line":"    }) catch |err| switch (err) {"},
{"lineNum":" 2827","line":"        error.IsDir => unreachable,"},
{"lineNum":" 2828","line":"        error.PipeBusy => unreachable,"},
{"lineNum":" 2829","line":"        error.WouldBlock => unreachable,"},
{"lineNum":" 2830","line":"        else => |e| return e,"},
{"lineNum":" 2831","line":"    };"},
{"lineNum":" 2832","line":"    windows.CloseHandle(sub_dir_handle);"},
{"lineNum":" 2833","line":"}"},
{"lineNum":" 2834","line":""},
{"lineNum":" 2835","line":"pub const DeleteDirError = error{"},
{"lineNum":" 2836","line":"    AccessDenied,"},
{"lineNum":" 2837","line":"    FileBusy,"},
{"lineNum":" 2838","line":"    SymLinkLoop,"},
{"lineNum":" 2839","line":"    NameTooLong,"},
{"lineNum":" 2840","line":"    FileNotFound,"},
{"lineNum":" 2841","line":"    SystemResources,"},
{"lineNum":" 2842","line":"    NotDir,"},
{"lineNum":" 2843","line":"    DirNotEmpty,"},
{"lineNum":" 2844","line":"    ReadOnlyFileSystem,"},
{"lineNum":" 2845","line":"    InvalidUtf8,"},
{"lineNum":" 2846","line":"    BadPathName,"},
{"lineNum":" 2847","line":"    /// On Windows, `\\\\server` or `\\\\server\\share` was not found."},
{"lineNum":" 2848","line":"    NetworkNotFound,"},
{"lineNum":" 2849","line":"} || UnexpectedError;"},
{"lineNum":" 2850","line":""},
{"lineNum":" 2851","line":"/// Deletes an empty directory."},
{"lineNum":" 2852","line":"pub fn rmdir(dir_path: []const u8) DeleteDirError!void {"},
{"lineNum":" 2853","line":"    if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 2854","line":"        return unlinkat(wasi.AT.FDCWD, dir_path, AT.REMOVEDIR) catch |err| switch (err) {"},
{"lineNum":" 2855","line":"            error.FileSystem => unreachable, // only occurs when targeting files"},
{"lineNum":" 2856","line":"            error.IsDir => unreachable, // only occurs when targeting files"},
{"lineNum":" 2857","line":"            else => |e| return e,"},
{"lineNum":" 2858","line":"        };"},
{"lineNum":" 2859","line":"    } else if (builtin.os.tag == .windows) {"},
{"lineNum":" 2860","line":"        const dir_path_w = try windows.sliceToPrefixedFileW(dir_path);"},
{"lineNum":" 2861","line":"        return rmdirW(dir_path_w.span());"},
{"lineNum":" 2862","line":"    } else {"},
{"lineNum":" 2863","line":"        const dir_path_c = try toPosixPath(dir_path);"},
{"lineNum":" 2864","line":"        return rmdirZ(&dir_path_c);"},
{"lineNum":" 2865","line":"    }"},
{"lineNum":" 2866","line":"}"},
{"lineNum":" 2867","line":""},
{"lineNum":" 2868","line":"/// Same as `rmdir` except the parameter is null-terminated."},
{"lineNum":" 2869","line":"pub fn rmdirZ(dir_path: [*:0]const u8) DeleteDirError!void {"},
{"lineNum":" 2870","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 2871","line":"        const dir_path_w = try windows.cStrToPrefixedFileW(dir_path);"},
{"lineNum":" 2872","line":"        return rmdirW(dir_path_w.span());"},
{"lineNum":" 2873","line":"    } else if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 2874","line":"        return rmdir(mem.sliceTo(dir_path, 0));"},
{"lineNum":" 2875","line":"    }"},
{"lineNum":" 2876","line":"    switch (errno(system.rmdir(dir_path))) {"},
{"lineNum":" 2877","line":"        .SUCCESS => return,"},
{"lineNum":" 2878","line":"        .ACCES => return error.AccessDenied,"},
{"lineNum":" 2879","line":"        .PERM => return error.AccessDenied,"},
{"lineNum":" 2880","line":"        .BUSY => return error.FileBusy,"},
{"lineNum":" 2881","line":"        .FAULT => unreachable,"},
{"lineNum":" 2882","line":"        .INVAL => return error.BadPathName,"},
{"lineNum":" 2883","line":"        .LOOP => return error.SymLinkLoop,"},
{"lineNum":" 2884","line":"        .NAMETOOLONG => return error.NameTooLong,"},
{"lineNum":" 2885","line":"        .NOENT => return error.FileNotFound,"},
{"lineNum":" 2886","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 2887","line":"        .NOTDIR => return error.NotDir,"},
{"lineNum":" 2888","line":"        .EXIST => return error.DirNotEmpty,"},
{"lineNum":" 2889","line":"        .NOTEMPTY => return error.DirNotEmpty,"},
{"lineNum":" 2890","line":"        .ROFS => return error.ReadOnlyFileSystem,"},
{"lineNum":" 2891","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 2892","line":"    }"},
{"lineNum":" 2893","line":"}"},
{"lineNum":" 2894","line":""},
{"lineNum":" 2895","line":"/// Windows-only. Same as `rmdir` except the parameter is WTF16 encoded."},
{"lineNum":" 2896","line":"pub fn rmdirW(dir_path_w: []const u16) DeleteDirError!void {"},
{"lineNum":" 2897","line":"    return windows.DeleteFile(dir_path_w, .{ .dir = std.fs.cwd().fd, .remove_dir = true }) catch |err| switch (err) {"},
{"lineNum":" 2898","line":"        error.IsDir => unreachable,"},
{"lineNum":" 2899","line":"        else => |e| return e,"},
{"lineNum":" 2900","line":"    };"},
{"lineNum":" 2901","line":"}"},
{"lineNum":" 2902","line":""},
{"lineNum":" 2903","line":"pub const ChangeCurDirError = error{"},
{"lineNum":" 2904","line":"    AccessDenied,"},
{"lineNum":" 2905","line":"    FileSystem,"},
{"lineNum":" 2906","line":"    SymLinkLoop,"},
{"lineNum":" 2907","line":"    NameTooLong,"},
{"lineNum":" 2908","line":"    FileNotFound,"},
{"lineNum":" 2909","line":"    SystemResources,"},
{"lineNum":" 2910","line":"    NotDir,"},
{"lineNum":" 2911","line":"    BadPathName,"},
{"lineNum":" 2912","line":""},
{"lineNum":" 2913","line":"    /// On Windows, file paths must be valid Unicode."},
{"lineNum":" 2914","line":"    InvalidUtf8,"},
{"lineNum":" 2915","line":"} || UnexpectedError;"},
{"lineNum":" 2916","line":""},
{"lineNum":" 2917","line":"/// Changes the current working directory of the calling process."},
{"lineNum":" 2918","line":"/// `dir_path` is recommended to be a UTF-8 encoded string."},
{"lineNum":" 2919","line":"pub fn chdir(dir_path: []const u8) ChangeCurDirError!void {"},
{"lineNum":" 2920","line":"    if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 2921","line":"        @compileError(\"WASI does not support os.chdir\");"},
{"lineNum":" 2922","line":"    } else if (builtin.os.tag == .windows) {"},
{"lineNum":" 2923","line":"        var utf16_dir_path: [windows.PATH_MAX_WIDE]u16 = undefined;"},
{"lineNum":" 2924","line":"        const len = try std.unicode.utf8ToUtf16Le(utf16_dir_path[0..], dir_path);"},
{"lineNum":" 2925","line":"        if (len > utf16_dir_path.len) return error.NameTooLong;"},
{"lineNum":" 2926","line":"        return chdirW(utf16_dir_path[0..len]);"},
{"lineNum":" 2927","line":"    } else {"},
{"lineNum":" 2928","line":"        const dir_path_c = try toPosixPath(dir_path);"},
{"lineNum":" 2929","line":"        return chdirZ(&dir_path_c);"},
{"lineNum":" 2930","line":"    }"},
{"lineNum":" 2931","line":"}"},
{"lineNum":" 2932","line":""},
{"lineNum":" 2933","line":"/// Same as `chdir` except the parameter is null-terminated."},
{"lineNum":" 2934","line":"pub fn chdirZ(dir_path: [*:0]const u8) ChangeCurDirError!void {"},
{"lineNum":" 2935","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 2936","line":"        var utf16_dir_path: [windows.PATH_MAX_WIDE]u16 = undefined;"},
{"lineNum":" 2937","line":"        const len = try std.unicode.utf8ToUtf16Le(utf16_dir_path[0..], dir_path);"},
{"lineNum":" 2938","line":"        if (len > utf16_dir_path.len) return error.NameTooLong;"},
{"lineNum":" 2939","line":"        return chdirW(utf16_dir_path[0..len]);"},
{"lineNum":" 2940","line":"    } else if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 2941","line":"        return chdir(mem.sliceTo(dir_path, 0));"},
{"lineNum":" 2942","line":"    }"},
{"lineNum":" 2943","line":"    switch (errno(system.chdir(dir_path))) {"},
{"lineNum":" 2944","line":"        .SUCCESS => return,"},
{"lineNum":" 2945","line":"        .ACCES => return error.AccessDenied,"},
{"lineNum":" 2946","line":"        .FAULT => unreachable,"},
{"lineNum":" 2947","line":"        .IO => return error.FileSystem,"},
{"lineNum":" 2948","line":"        .LOOP => return error.SymLinkLoop,"},
{"lineNum":" 2949","line":"        .NAMETOOLONG => return error.NameTooLong,"},
{"lineNum":" 2950","line":"        .NOENT => return error.FileNotFound,"},
{"lineNum":" 2951","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 2952","line":"        .NOTDIR => return error.NotDir,"},
{"lineNum":" 2953","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 2954","line":"    }"},
{"lineNum":" 2955","line":"}"},
{"lineNum":" 2956","line":""},
{"lineNum":" 2957","line":"/// Windows-only. Same as `chdir` except the parameter is WTF16 encoded."},
{"lineNum":" 2958","line":"pub fn chdirW(dir_path: []const u16) ChangeCurDirError!void {"},
{"lineNum":" 2959","line":"    windows.SetCurrentDirectory(dir_path) catch |err| switch (err) {"},
{"lineNum":" 2960","line":"        error.NoDevice => return error.FileSystem,"},
{"lineNum":" 2961","line":"        else => |e| return e,"},
{"lineNum":" 2962","line":"    };"},
{"lineNum":" 2963","line":"}"},
{"lineNum":" 2964","line":""},
{"lineNum":" 2965","line":"pub const FchdirError = error{"},
{"lineNum":" 2966","line":"    AccessDenied,"},
{"lineNum":" 2967","line":"    NotDir,"},
{"lineNum":" 2968","line":"    FileSystem,"},
{"lineNum":" 2969","line":"} || UnexpectedError;"},
{"lineNum":" 2970","line":""},
{"lineNum":" 2971","line":"pub fn fchdir(dirfd: fd_t) FchdirError!void {"},
{"lineNum":" 2972","line":"    while (true) {"},
{"lineNum":" 2973","line":"        switch (errno(system.fchdir(dirfd))) {"},
{"lineNum":" 2974","line":"            .SUCCESS => return,"},
{"lineNum":" 2975","line":"            .ACCES => return error.AccessDenied,"},
{"lineNum":" 2976","line":"            .BADF => unreachable,"},
{"lineNum":" 2977","line":"            .NOTDIR => return error.NotDir,"},
{"lineNum":" 2978","line":"            .INTR => continue,"},
{"lineNum":" 2979","line":"            .IO => return error.FileSystem,"},
{"lineNum":" 2980","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 2981","line":"        }"},
{"lineNum":" 2982","line":"    }"},
{"lineNum":" 2983","line":"}"},
{"lineNum":" 2984","line":""},
{"lineNum":" 2985","line":"pub const ReadLinkError = error{"},
{"lineNum":" 2986","line":"    /// In WASI, this error may occur when the file descriptor does"},
{"lineNum":" 2987","line":"    /// not hold the required rights to read value of a symbolic link relative to it."},
{"lineNum":" 2988","line":"    AccessDenied,"},
{"lineNum":" 2989","line":"    FileSystem,"},
{"lineNum":" 2990","line":"    SymLinkLoop,"},
{"lineNum":" 2991","line":"    NameTooLong,"},
{"lineNum":" 2992","line":"    FileNotFound,"},
{"lineNum":" 2993","line":"    SystemResources,"},
{"lineNum":" 2994","line":"    NotLink,"},
{"lineNum":" 2995","line":"    NotDir,"},
{"lineNum":" 2996","line":"    InvalidUtf8,"},
{"lineNum":" 2997","line":"    BadPathName,"},
{"lineNum":" 2998","line":"    /// Windows-only. This error may occur if the opened reparse point is"},
{"lineNum":" 2999","line":"    /// of unsupported type."},
{"lineNum":" 3000","line":"    UnsupportedReparsePointType,"},
{"lineNum":" 3001","line":"} || UnexpectedError;"},
{"lineNum":" 3002","line":""},
{"lineNum":" 3003","line":"/// Read value of a symbolic link."},
{"lineNum":" 3004","line":"/// The return value is a slice of `out_buffer` from index 0."},
{"lineNum":" 3005","line":"pub fn readlink(file_path: []const u8, out_buffer: []u8) ReadLinkError![]u8 {"},
{"lineNum":" 3006","line":"    if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 3007","line":"        return readlinkat(wasi.AT.FDCWD, file_path, out_buffer);"},
{"lineNum":" 3008","line":"    } else if (builtin.os.tag == .windows) {"},
{"lineNum":" 3009","line":"        const file_path_w = try windows.sliceToPrefixedFileW(file_path);"},
{"lineNum":" 3010","line":"        return readlinkW(file_path_w.span(), out_buffer);"},
{"lineNum":" 3011","line":"    } else {"},
{"lineNum":" 3012","line":"        const file_path_c = try toPosixPath(file_path);"},
{"lineNum":" 3013","line":"        return readlinkZ(&file_path_c, out_buffer);"},
{"lineNum":" 3014","line":"    }"},
{"lineNum":" 3015","line":"}"},
{"lineNum":" 3016","line":""},
{"lineNum":" 3017","line":"/// Windows-only. Same as `readlink` except `file_path` is WTF16 encoded."},
{"lineNum":" 3018","line":"/// See also `readlinkZ`."},
{"lineNum":" 3019","line":"pub fn readlinkW(file_path: []const u16, out_buffer: []u8) ReadLinkError![]u8 {"},
{"lineNum":" 3020","line":"    return windows.ReadLink(std.fs.cwd().fd, file_path, out_buffer);"},
{"lineNum":" 3021","line":"}"},
{"lineNum":" 3022","line":""},
{"lineNum":" 3023","line":"/// Same as `readlink` except `file_path` is null-terminated."},
{"lineNum":" 3024","line":"pub fn readlinkZ(file_path: [*:0]const u8, out_buffer: []u8) ReadLinkError![]u8 {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 3025","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 3026","line":"        const file_path_w = try windows.cStrToWin32PrefixedFileW(file_path);"},
{"lineNum":" 3027","line":"        return readlinkW(file_path_w.span(), out_buffer);"},
{"lineNum":" 3028","line":"    } else if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 3029","line":"        return readlink(mem.sliceTo(file_path, 0), out_buffer);"},
{"lineNum":" 3030","line":"    }"},
{"lineNum":" 3031","line":"    const rc = system.readlink(file_path, out_buffer.ptr, out_buffer.len);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 3032","line":"    switch (errno(rc)) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 3033","line":"        .SUCCESS => return out_buffer[0..@as(usize, @bitCast(rc))],","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 3034","line":"        .ACCES => return error.AccessDenied,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 3035","line":"        .FAULT => unreachable,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 3036","line":"        .INVAL => return error.NotLink,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 3037","line":"        .IO => return error.FileSystem,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 3038","line":"        .LOOP => return error.SymLinkLoop,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 3039","line":"        .NAMETOOLONG => return error.NameTooLong,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 3040","line":"        .NOENT => return error.FileNotFound,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 3041","line":"        .NOMEM => return error.SystemResources,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 3042","line":"        .NOTDIR => return error.NotDir,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 3043","line":"        else => |err| return unexpectedErrno(err),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 3044","line":"    }"},
{"lineNum":" 3045","line":"}"},
{"lineNum":" 3046","line":""},
{"lineNum":" 3047","line":"/// Similar to `readlink` except reads value of a symbolink link **relative** to `dirfd` directory handle."},
{"lineNum":" 3048","line":"/// The return value is a slice of `out_buffer` from index 0."},
{"lineNum":" 3049","line":"/// See also `readlinkatWasi`, `realinkatZ` and `realinkatW`."},
{"lineNum":" 3050","line":"pub fn readlinkat(dirfd: fd_t, file_path: []const u8, out_buffer: []u8) ReadLinkError![]u8 {"},
{"lineNum":" 3051","line":"    if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 3052","line":"        return readlinkatWasi(dirfd, file_path, out_buffer);"},
{"lineNum":" 3053","line":"    }"},
{"lineNum":" 3054","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 3055","line":"        const file_path_w = try windows.sliceToPrefixedFileW(file_path);"},
{"lineNum":" 3056","line":"        return readlinkatW(dirfd, file_path_w.span(), out_buffer);"},
{"lineNum":" 3057","line":"    }"},
{"lineNum":" 3058","line":"    const file_path_c = try toPosixPath(file_path);"},
{"lineNum":" 3059","line":"    return readlinkatZ(dirfd, &file_path_c, out_buffer);"},
{"lineNum":" 3060","line":"}"},
{"lineNum":" 3061","line":""},
{"lineNum":" 3062","line":"/// WASI-only. Same as `readlinkat` but targets WASI."},
{"lineNum":" 3063","line":"/// See also `readlinkat`."},
{"lineNum":" 3064","line":"pub fn readlinkatWasi(dirfd: fd_t, file_path: []const u8, out_buffer: []u8) ReadLinkError![]u8 {"},
{"lineNum":" 3065","line":"    var bufused: usize = undefined;"},
{"lineNum":" 3066","line":"    switch (wasi.path_readlink(dirfd, file_path.ptr, file_path.len, out_buffer.ptr, out_buffer.len, &bufused)) {"},
{"lineNum":" 3067","line":"        .SUCCESS => return out_buffer[0..bufused],"},
{"lineNum":" 3068","line":"        .ACCES => return error.AccessDenied,"},
{"lineNum":" 3069","line":"        .FAULT => unreachable,"},
{"lineNum":" 3070","line":"        .INVAL => return error.NotLink,"},
{"lineNum":" 3071","line":"        .IO => return error.FileSystem,"},
{"lineNum":" 3072","line":"        .LOOP => return error.SymLinkLoop,"},
{"lineNum":" 3073","line":"        .NAMETOOLONG => return error.NameTooLong,"},
{"lineNum":" 3074","line":"        .NOENT => return error.FileNotFound,"},
{"lineNum":" 3075","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 3076","line":"        .NOTDIR => return error.NotDir,"},
{"lineNum":" 3077","line":"        .NOTCAPABLE => return error.AccessDenied,"},
{"lineNum":" 3078","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 3079","line":"    }"},
{"lineNum":" 3080","line":"}"},
{"lineNum":" 3081","line":""},
{"lineNum":" 3082","line":"/// Windows-only. Same as `readlinkat` except `file_path` is null-terminated, WTF16 encoded."},
{"lineNum":" 3083","line":"/// See also `readlinkat`."},
{"lineNum":" 3084","line":"pub fn readlinkatW(dirfd: fd_t, file_path: []const u16, out_buffer: []u8) ReadLinkError![]u8 {"},
{"lineNum":" 3085","line":"    return windows.ReadLink(dirfd, file_path, out_buffer);"},
{"lineNum":" 3086","line":"}"},
{"lineNum":" 3087","line":""},
{"lineNum":" 3088","line":"/// Same as `readlinkat` except `file_path` is null-terminated."},
{"lineNum":" 3089","line":"/// See also `readlinkat`."},
{"lineNum":" 3090","line":"pub fn readlinkatZ(dirfd: fd_t, file_path: [*:0]const u8, out_buffer: []u8) ReadLinkError![]u8 {"},
{"lineNum":" 3091","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 3092","line":"        const file_path_w = try windows.cStrToPrefixedFileW(file_path);"},
{"lineNum":" 3093","line":"        return readlinkatW(dirfd, file_path_w.span(), out_buffer);"},
{"lineNum":" 3094","line":"    } else if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 3095","line":"        return readlinkat(dirfd, mem.sliceTo(file_path, 0), out_buffer);"},
{"lineNum":" 3096","line":"    }"},
{"lineNum":" 3097","line":"    const rc = system.readlinkat(dirfd, file_path, out_buffer.ptr, out_buffer.len);"},
{"lineNum":" 3098","line":"    switch (errno(rc)) {"},
{"lineNum":" 3099","line":"        .SUCCESS => return out_buffer[0..@as(usize, @bitCast(rc))],"},
{"lineNum":" 3100","line":"        .ACCES => return error.AccessDenied,"},
{"lineNum":" 3101","line":"        .FAULT => unreachable,"},
{"lineNum":" 3102","line":"        .INVAL => return error.NotLink,"},
{"lineNum":" 3103","line":"        .IO => return error.FileSystem,"},
{"lineNum":" 3104","line":"        .LOOP => return error.SymLinkLoop,"},
{"lineNum":" 3105","line":"        .NAMETOOLONG => return error.NameTooLong,"},
{"lineNum":" 3106","line":"        .NOENT => return error.FileNotFound,"},
{"lineNum":" 3107","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 3108","line":"        .NOTDIR => return error.NotDir,"},
{"lineNum":" 3109","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 3110","line":"    }"},
{"lineNum":" 3111","line":"}"},
{"lineNum":" 3112","line":""},
{"lineNum":" 3113","line":"pub const SetEidError = error{"},
{"lineNum":" 3114","line":"    InvalidUserId,"},
{"lineNum":" 3115","line":"    PermissionDenied,"},
{"lineNum":" 3116","line":"} || UnexpectedError;"},
{"lineNum":" 3117","line":""},
{"lineNum":" 3118","line":"pub const SetIdError = error{ResourceLimitReached} || SetEidError;"},
{"lineNum":" 3119","line":""},
{"lineNum":" 3120","line":"pub fn setuid(uid: uid_t) SetIdError!void {"},
{"lineNum":" 3121","line":"    switch (errno(system.setuid(uid))) {"},
{"lineNum":" 3122","line":"        .SUCCESS => return,"},
{"lineNum":" 3123","line":"        .AGAIN => return error.ResourceLimitReached,"},
{"lineNum":" 3124","line":"        .INVAL => return error.InvalidUserId,"},
{"lineNum":" 3125","line":"        .PERM => return error.PermissionDenied,"},
{"lineNum":" 3126","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 3127","line":"    }"},
{"lineNum":" 3128","line":"}"},
{"lineNum":" 3129","line":""},
{"lineNum":" 3130","line":"pub fn seteuid(uid: uid_t) SetEidError!void {"},
{"lineNum":" 3131","line":"    switch (errno(system.seteuid(uid))) {"},
{"lineNum":" 3132","line":"        .SUCCESS => return,"},
{"lineNum":" 3133","line":"        .INVAL => return error.InvalidUserId,"},
{"lineNum":" 3134","line":"        .PERM => return error.PermissionDenied,"},
{"lineNum":" 3135","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 3136","line":"    }"},
{"lineNum":" 3137","line":"}"},
{"lineNum":" 3138","line":""},
{"lineNum":" 3139","line":"pub fn setreuid(ruid: uid_t, euid: uid_t) SetIdError!void {"},
{"lineNum":" 3140","line":"    switch (errno(system.setreuid(ruid, euid))) {"},
{"lineNum":" 3141","line":"        .SUCCESS => return,"},
{"lineNum":" 3142","line":"        .AGAIN => return error.ResourceLimitReached,"},
{"lineNum":" 3143","line":"        .INVAL => return error.InvalidUserId,"},
{"lineNum":" 3144","line":"        .PERM => return error.PermissionDenied,"},
{"lineNum":" 3145","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 3146","line":"    }"},
{"lineNum":" 3147","line":"}"},
{"lineNum":" 3148","line":""},
{"lineNum":" 3149","line":"pub fn setgid(gid: gid_t) SetIdError!void {"},
{"lineNum":" 3150","line":"    switch (errno(system.setgid(gid))) {"},
{"lineNum":" 3151","line":"        .SUCCESS => return,"},
{"lineNum":" 3152","line":"        .AGAIN => return error.ResourceLimitReached,"},
{"lineNum":" 3153","line":"        .INVAL => return error.InvalidUserId,"},
{"lineNum":" 3154","line":"        .PERM => return error.PermissionDenied,"},
{"lineNum":" 3155","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 3156","line":"    }"},
{"lineNum":" 3157","line":"}"},
{"lineNum":" 3158","line":""},
{"lineNum":" 3159","line":"pub fn setegid(uid: uid_t) SetEidError!void {"},
{"lineNum":" 3160","line":"    switch (errno(system.setegid(uid))) {"},
{"lineNum":" 3161","line":"        .SUCCESS => return,"},
{"lineNum":" 3162","line":"        .INVAL => return error.InvalidUserId,"},
{"lineNum":" 3163","line":"        .PERM => return error.PermissionDenied,"},
{"lineNum":" 3164","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 3165","line":"    }"},
{"lineNum":" 3166","line":"}"},
{"lineNum":" 3167","line":""},
{"lineNum":" 3168","line":"pub fn setregid(rgid: gid_t, egid: gid_t) SetIdError!void {"},
{"lineNum":" 3169","line":"    switch (errno(system.setregid(rgid, egid))) {"},
{"lineNum":" 3170","line":"        .SUCCESS => return,"},
{"lineNum":" 3171","line":"        .AGAIN => return error.ResourceLimitReached,"},
{"lineNum":" 3172","line":"        .INVAL => return error.InvalidUserId,"},
{"lineNum":" 3173","line":"        .PERM => return error.PermissionDenied,"},
{"lineNum":" 3174","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 3175","line":"    }"},
{"lineNum":" 3176","line":"}"},
{"lineNum":" 3177","line":""},
{"lineNum":" 3178","line":"/// Test whether a file descriptor refers to a terminal."},
{"lineNum":" 3179","line":"pub fn isatty(handle: fd_t) bool {","class":"lineCov","hits":"1","order":"365","possible_hits":"1",},
{"lineNum":" 3180","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 3181","line":"        if (isCygwinPty(handle))"},
{"lineNum":" 3182","line":"            return true;"},
{"lineNum":" 3183","line":""},
{"lineNum":" 3184","line":"        var out: windows.DWORD = undefined;"},
{"lineNum":" 3185","line":"        return windows.kernel32.GetConsoleMode(handle, &out) != 0;"},
{"lineNum":" 3186","line":"    }"},
{"lineNum":" 3187","line":"    if (builtin.link_libc) {"},
{"lineNum":" 3188","line":"        return system.isatty(handle) != 0;"},
{"lineNum":" 3189","line":"    }"},
{"lineNum":" 3190","line":"    if (builtin.os.tag == .wasi) {"},
{"lineNum":" 3191","line":"        var statbuf: fdstat_t = undefined;"},
{"lineNum":" 3192","line":"        const err = system.fd_fdstat_get(handle, &statbuf);"},
{"lineNum":" 3193","line":"        if (err != .SUCCESS) {"},
{"lineNum":" 3194","line":"            // errno = err;"},
{"lineNum":" 3195","line":"            return false;"},
{"lineNum":" 3196","line":"        }"},
{"lineNum":" 3197","line":""},
{"lineNum":" 3198","line":"        // A tty is a character device that we can\'t seek or tell on."},
{"lineNum":" 3199","line":"        if (statbuf.fs_filetype != .CHARACTER_DEVICE or"},
{"lineNum":" 3200","line":"            (statbuf.fs_rights_base & (RIGHT.FD_SEEK | RIGHT.FD_TELL)) != 0)"},
{"lineNum":" 3201","line":"        {"},
{"lineNum":" 3202","line":"            // errno = ENOTTY;"},
{"lineNum":" 3203","line":"            return false;"},
{"lineNum":" 3204","line":"        }"},
{"lineNum":" 3205","line":""},
{"lineNum":" 3206","line":"        return true;"},
{"lineNum":" 3207","line":"    }"},
{"lineNum":" 3208","line":"    if (builtin.os.tag == .linux) {"},
{"lineNum":" 3209","line":"        while (true) {"},
{"lineNum":" 3210","line":"            var wsz: linux.winsize = undefined;","class":"lineCov","hits":"1","order":"366","possible_hits":"1",},
{"lineNum":" 3211","line":"            const fd = @as(usize, @bitCast(@as(isize, handle)));","class":"lineCov","hits":"1","order":"367","possible_hits":"1",},
{"lineNum":" 3212","line":"            const rc = linux.syscall3(.ioctl, fd, linux.T.IOCGWINSZ, @intFromPtr(&wsz));","class":"lineCov","hits":"1","order":"368","possible_hits":"1",},
{"lineNum":" 3213","line":"            switch (linux.getErrno(rc)) {","class":"lineCov","hits":"1","order":"371","possible_hits":"1",},
{"lineNum":" 3214","line":"                .SUCCESS => return true,","class":"lineCov","hits":"1","order":"372","possible_hits":"1",},
{"lineNum":" 3215","line":"                .INTR => continue,"},
{"lineNum":" 3216","line":"                else => return false,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 3217","line":"            }"},
{"lineNum":" 3218","line":"        }"},
{"lineNum":" 3219","line":"    }"},
{"lineNum":" 3220","line":"    return system.isatty(handle) != 0;"},
{"lineNum":" 3221","line":"}"},
{"lineNum":" 3222","line":""},
{"lineNum":" 3223","line":"pub fn isCygwinPty(handle: fd_t) bool {"},
{"lineNum":" 3224","line":"    if (builtin.os.tag != .windows) return false;"},
{"lineNum":" 3225","line":""},
{"lineNum":" 3226","line":"    // If this is a MSYS2/cygwin pty, then it will be a named pipe with a name in one of these formats:"},
{"lineNum":" 3227","line":"    //   msys-[...]-ptyN-[...]"},
{"lineNum":" 3228","line":"    //   cygwin-[...]-ptyN-[...]"},
{"lineNum":" 3229","line":"    //"},
{"lineNum":" 3230","line":"    // Example: msys-1888ae32e00d56aa-pty0-to-master"},
{"lineNum":" 3231","line":""},
{"lineNum":" 3232","line":"    // First, just check that the handle is a named pipe."},
{"lineNum":" 3233","line":"    // This allows us to avoid the more costly NtQueryInformationFile call"},
{"lineNum":" 3234","line":"    // for handles that aren\'t named pipes."},
{"lineNum":" 3235","line":"    {"},
{"lineNum":" 3236","line":"        var io_status: windows.IO_STATUS_BLOCK = undefined;"},
{"lineNum":" 3237","line":"        var device_info: windows.FILE_FS_DEVICE_INFORMATION = undefined;"},
{"lineNum":" 3238","line":"        const rc = windows.ntdll.NtQueryVolumeInformationFile(handle, &io_status, &device_info, @sizeOf(windows.FILE_FS_DEVICE_INFORMATION), .FileFsDeviceInformation);"},
{"lineNum":" 3239","line":"        switch (rc) {"},
{"lineNum":" 3240","line":"            .SUCCESS => {},"},
{"lineNum":" 3241","line":"            else => return false,"},
{"lineNum":" 3242","line":"        }"},
{"lineNum":" 3243","line":"        if (device_info.DeviceType != windows.FILE_DEVICE_NAMED_PIPE) return false;"},
{"lineNum":" 3244","line":"    }"},
{"lineNum":" 3245","line":""},
{"lineNum":" 3246","line":"    const name_bytes_offset = @offsetOf(windows.FILE_NAME_INFO, \"FileName\");"},
{"lineNum":" 3247","line":"    // `NAME_MAX` UTF-16 code units (2 bytes each)"},
{"lineNum":" 3248","line":"    // Note: This buffer may not be long enough to handle *all* possible paths (PATH_MAX_WIDE would be necessary for that),"},
{"lineNum":" 3249","line":"    //       but because we only care about certain paths and we know they must be within a reasonable length,"},
{"lineNum":" 3250","line":"    //       we can use this smaller buffer and just return false on any error from NtQueryInformationFile."},
{"lineNum":" 3251","line":"    const num_name_bytes = windows.MAX_PATH * 2;"},
{"lineNum":" 3252","line":"    var name_info_bytes align(@alignOf(windows.FILE_NAME_INFO)) = [_]u8{0} ** (name_bytes_offset + num_name_bytes);"},
{"lineNum":" 3253","line":""},
{"lineNum":" 3254","line":"    var io_status_block: windows.IO_STATUS_BLOCK = undefined;"},
{"lineNum":" 3255","line":"    const rc = windows.ntdll.NtQueryInformationFile(handle, &io_status_block, &name_info_bytes, @as(u32, @intCast(name_info_bytes.len)), .FileNameInformation);"},
{"lineNum":" 3256","line":"    switch (rc) {"},
{"lineNum":" 3257","line":"        .SUCCESS => {},"},
{"lineNum":" 3258","line":"        .INVALID_PARAMETER => unreachable,"},
{"lineNum":" 3259","line":"        else => return false,"},
{"lineNum":" 3260","line":"    }"},
{"lineNum":" 3261","line":""},
{"lineNum":" 3262","line":"    const name_info = @as(*const windows.FILE_NAME_INFO, @ptrCast(&name_info_bytes[0]));"},
{"lineNum":" 3263","line":"    const name_bytes = name_info_bytes[name_bytes_offset .. name_bytes_offset + @as(usize, name_info.FileNameLength)];"},
{"lineNum":" 3264","line":"    const name_wide = mem.bytesAsSlice(u16, name_bytes);"},
{"lineNum":" 3265","line":"    // Note: The name we get from NtQueryInformationFile will be prefixed with a \'\\\', e.g. \\msys-1888ae32e00d56aa-pty0-to-master"},
{"lineNum":" 3266","line":"    return (mem.startsWith(u16, name_wide, &[_]u16{ \'\\\\\', \'m\', \'s\', \'y\', \'s\', \'-\' }) or"},
{"lineNum":" 3267","line":"        mem.startsWith(u16, name_wide, &[_]u16{ \'\\\\\', \'c\', \'y\', \'g\', \'w\', \'i\', \'n\', \'-\' })) and"},
{"lineNum":" 3268","line":"        mem.indexOf(u16, name_wide, &[_]u16{ \'-\', \'p\', \'t\', \'y\' }) != null;"},
{"lineNum":" 3269","line":"}"},
{"lineNum":" 3270","line":""},
{"lineNum":" 3271","line":"pub const SocketError = error{"},
{"lineNum":" 3272","line":"    /// Permission to create a socket of the specified type and/or"},
{"lineNum":" 3273","line":"    /// protocol is denied."},
{"lineNum":" 3274","line":"    PermissionDenied,"},
{"lineNum":" 3275","line":""},
{"lineNum":" 3276","line":"    /// The implementation does not support the specified address family."},
{"lineNum":" 3277","line":"    AddressFamilyNotSupported,"},
{"lineNum":" 3278","line":""},
{"lineNum":" 3279","line":"    /// Unknown protocol, or protocol family not available."},
{"lineNum":" 3280","line":"    ProtocolFamilyNotAvailable,"},
{"lineNum":" 3281","line":""},
{"lineNum":" 3282","line":"    /// The per-process limit on the number of open file descriptors has been reached."},
{"lineNum":" 3283","line":"    ProcessFdQuotaExceeded,"},
{"lineNum":" 3284","line":""},
{"lineNum":" 3285","line":"    /// The system-wide limit on the total number of open files has been reached."},
{"lineNum":" 3286","line":"    SystemFdQuotaExceeded,"},
{"lineNum":" 3287","line":""},
{"lineNum":" 3288","line":"    /// Insufficient memory is available. The socket cannot be created until sufficient"},
{"lineNum":" 3289","line":"    /// resources are freed."},
{"lineNum":" 3290","line":"    SystemResources,"},
{"lineNum":" 3291","line":""},
{"lineNum":" 3292","line":"    /// The protocol type or the specified protocol is not supported within this domain."},
{"lineNum":" 3293","line":"    ProtocolNotSupported,"},
{"lineNum":" 3294","line":""},
{"lineNum":" 3295","line":"    /// The socket type is not supported by the protocol."},
{"lineNum":" 3296","line":"    SocketTypeNotSupported,"},
{"lineNum":" 3297","line":"} || UnexpectedError;"},
{"lineNum":" 3298","line":""},
{"lineNum":" 3299","line":"pub fn socket(domain: u32, socket_type: u32, protocol: u32) SocketError!socket_t {"},
{"lineNum":" 3300","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 3301","line":"        // NOTE: windows translates the SOCK.NONBLOCK/SOCK.CLOEXEC flags into"},
{"lineNum":" 3302","line":"        // windows-analagous operations"},
{"lineNum":" 3303","line":"        const filtered_sock_type = socket_type & ~@as(u32, SOCK.NONBLOCK | SOCK.CLOEXEC);"},
{"lineNum":" 3304","line":"        const flags: u32 = if ((socket_type & SOCK.CLOEXEC) != 0)"},
{"lineNum":" 3305","line":"            windows.ws2_32.WSA_FLAG_NO_HANDLE_INHERIT"},
{"lineNum":" 3306","line":"        else"},
{"lineNum":" 3307","line":"            0;"},
{"lineNum":" 3308","line":"        const rc = try windows.WSASocketW("},
{"lineNum":" 3309","line":"            @as(i32, @bitCast(domain)),"},
{"lineNum":" 3310","line":"            @as(i32, @bitCast(filtered_sock_type)),"},
{"lineNum":" 3311","line":"            @as(i32, @bitCast(protocol)),"},
{"lineNum":" 3312","line":"            null,"},
{"lineNum":" 3313","line":"            0,"},
{"lineNum":" 3314","line":"            flags,"},
{"lineNum":" 3315","line":"        );"},
{"lineNum":" 3316","line":"        errdefer windows.closesocket(rc) catch unreachable;"},
{"lineNum":" 3317","line":"        if ((socket_type & SOCK.NONBLOCK) != 0) {"},
{"lineNum":" 3318","line":"            var mode: c_ulong = 1; // nonblocking"},
{"lineNum":" 3319","line":"            if (windows.ws2_32.SOCKET_ERROR == windows.ws2_32.ioctlsocket(rc, windows.ws2_32.FIONBIO, &mode)) {"},
{"lineNum":" 3320","line":"                switch (windows.ws2_32.WSAGetLastError()) {"},
{"lineNum":" 3321","line":"                    // have not identified any error codes that should be handled yet"},
{"lineNum":" 3322","line":"                    else => unreachable,"},
{"lineNum":" 3323","line":"                }"},
{"lineNum":" 3324","line":"            }"},
{"lineNum":" 3325","line":"        }"},
{"lineNum":" 3326","line":"        return rc;"},
{"lineNum":" 3327","line":"    }"},
{"lineNum":" 3328","line":""},
{"lineNum":" 3329","line":"    const have_sock_flags = comptime !builtin.target.isDarwin();"},
{"lineNum":" 3330","line":"    const filtered_sock_type = if (!have_sock_flags)"},
{"lineNum":" 3331","line":"        socket_type & ~@as(u32, SOCK.NONBLOCK | SOCK.CLOEXEC)"},
{"lineNum":" 3332","line":"    else"},
{"lineNum":" 3333","line":"        socket_type;"},
{"lineNum":" 3334","line":"    const rc = system.socket(domain, filtered_sock_type, protocol);"},
{"lineNum":" 3335","line":"    switch (errno(rc)) {"},
{"lineNum":" 3336","line":"        .SUCCESS => {"},
{"lineNum":" 3337","line":"            const fd = @as(fd_t, @intCast(rc));"},
{"lineNum":" 3338","line":"            if (!have_sock_flags) {"},
{"lineNum":" 3339","line":"                try setSockFlags(fd, socket_type);"},
{"lineNum":" 3340","line":"            }"},
{"lineNum":" 3341","line":"            return fd;"},
{"lineNum":" 3342","line":"        },"},
{"lineNum":" 3343","line":"        .ACCES => return error.PermissionDenied,"},
{"lineNum":" 3344","line":"        .AFNOSUPPORT => return error.AddressFamilyNotSupported,"},
{"lineNum":" 3345","line":"        .INVAL => return error.ProtocolFamilyNotAvailable,"},
{"lineNum":" 3346","line":"        .MFILE => return error.ProcessFdQuotaExceeded,"},
{"lineNum":" 3347","line":"        .NFILE => return error.SystemFdQuotaExceeded,"},
{"lineNum":" 3348","line":"        .NOBUFS => return error.SystemResources,"},
{"lineNum":" 3349","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 3350","line":"        .PROTONOSUPPORT => return error.ProtocolNotSupported,"},
{"lineNum":" 3351","line":"        .PROTOTYPE => return error.SocketTypeNotSupported,"},
{"lineNum":" 3352","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 3353","line":"    }"},
{"lineNum":" 3354","line":"}"},
{"lineNum":" 3355","line":""},
{"lineNum":" 3356","line":"pub const ShutdownError = error{"},
{"lineNum":" 3357","line":"    ConnectionAborted,"},
{"lineNum":" 3358","line":""},
{"lineNum":" 3359","line":"    /// Connection was reset by peer, application should close socket as it is no longer usable."},
{"lineNum":" 3360","line":"    ConnectionResetByPeer,"},
{"lineNum":" 3361","line":"    BlockingOperationInProgress,"},
{"lineNum":" 3362","line":""},
{"lineNum":" 3363","line":"    /// The network subsystem has failed."},
{"lineNum":" 3364","line":"    NetworkSubsystemFailed,"},
{"lineNum":" 3365","line":""},
{"lineNum":" 3366","line":"    /// The socket is not connected (connection-oriented sockets only)."},
{"lineNum":" 3367","line":"    SocketNotConnected,"},
{"lineNum":" 3368","line":"    SystemResources,"},
{"lineNum":" 3369","line":"} || UnexpectedError;"},
{"lineNum":" 3370","line":""},
{"lineNum":" 3371","line":"pub const ShutdownHow = enum { recv, send, both };"},
{"lineNum":" 3372","line":""},
{"lineNum":" 3373","line":"/// Shutdown socket send/receive operations"},
{"lineNum":" 3374","line":"pub fn shutdown(sock: socket_t, how: ShutdownHow) ShutdownError!void {"},
{"lineNum":" 3375","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 3376","line":"        const result = windows.ws2_32.shutdown(sock, switch (how) {"},
{"lineNum":" 3377","line":"            .recv => windows.ws2_32.SD_RECEIVE,"},
{"lineNum":" 3378","line":"            .send => windows.ws2_32.SD_SEND,"},
{"lineNum":" 3379","line":"            .both => windows.ws2_32.SD_BOTH,"},
{"lineNum":" 3380","line":"        });"},
{"lineNum":" 3381","line":"        if (0 != result) switch (windows.ws2_32.WSAGetLastError()) {"},
{"lineNum":" 3382","line":"            .WSAECONNABORTED => return error.ConnectionAborted,"},
{"lineNum":" 3383","line":"            .WSAECONNRESET => return error.ConnectionResetByPeer,"},
{"lineNum":" 3384","line":"            .WSAEINPROGRESS => return error.BlockingOperationInProgress,"},
{"lineNum":" 3385","line":"            .WSAEINVAL => unreachable,"},
{"lineNum":" 3386","line":"            .WSAENETDOWN => return error.NetworkSubsystemFailed,"},
{"lineNum":" 3387","line":"            .WSAENOTCONN => return error.SocketNotConnected,"},
{"lineNum":" 3388","line":"            .WSAENOTSOCK => unreachable,"},
{"lineNum":" 3389","line":"            .WSANOTINITIALISED => unreachable,"},
{"lineNum":" 3390","line":"            else => |err| return windows.unexpectedWSAError(err),"},
{"lineNum":" 3391","line":"        };"},
{"lineNum":" 3392","line":"    } else {"},
{"lineNum":" 3393","line":"        const rc = system.shutdown(sock, switch (how) {"},
{"lineNum":" 3394","line":"            .recv => SHUT.RD,"},
{"lineNum":" 3395","line":"            .send => SHUT.WR,"},
{"lineNum":" 3396","line":"            .both => SHUT.RDWR,"},
{"lineNum":" 3397","line":"        });"},
{"lineNum":" 3398","line":"        switch (errno(rc)) {"},
{"lineNum":" 3399","line":"            .SUCCESS => return,"},
{"lineNum":" 3400","line":"            .BADF => unreachable,"},
{"lineNum":" 3401","line":"            .INVAL => unreachable,"},
{"lineNum":" 3402","line":"            .NOTCONN => return error.SocketNotConnected,"},
{"lineNum":" 3403","line":"            .NOTSOCK => unreachable,"},
{"lineNum":" 3404","line":"            .NOBUFS => return error.SystemResources,"},
{"lineNum":" 3405","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 3406","line":"        }"},
{"lineNum":" 3407","line":"    }"},
{"lineNum":" 3408","line":"}"},
{"lineNum":" 3409","line":""},
{"lineNum":" 3410","line":"pub fn closeSocket(sock: socket_t) void {"},
{"lineNum":" 3411","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 3412","line":"        windows.closesocket(sock) catch unreachable;"},
{"lineNum":" 3413","line":"    } else {"},
{"lineNum":" 3414","line":"        close(sock);"},
{"lineNum":" 3415","line":"    }"},
{"lineNum":" 3416","line":"}"},
{"lineNum":" 3417","line":""},
{"lineNum":" 3418","line":"pub const BindError = error{"},
{"lineNum":" 3419","line":"    /// The address is protected, and the user is not the superuser."},
{"lineNum":" 3420","line":"    /// For UNIX domain sockets: Search permission is denied on  a  component"},
{"lineNum":" 3421","line":"    /// of  the  path  prefix."},
{"lineNum":" 3422","line":"    AccessDenied,"},
{"lineNum":" 3423","line":""},
{"lineNum":" 3424","line":"    /// The given address is already in use, or in the case of Internet domain sockets,"},
{"lineNum":" 3425","line":"    /// The  port number was specified as zero in the socket"},
{"lineNum":" 3426","line":"    /// address structure, but, upon attempting to bind to  an  ephemeral  port,  it  was"},
{"lineNum":" 3427","line":"    /// determined  that  all  port  numbers in the ephemeral port range are currently in"},
{"lineNum":" 3428","line":"    /// use.  See the discussion of /proc/sys/net/ipv4/ip_local_port_range ip(7)."},
{"lineNum":" 3429","line":"    AddressInUse,"},
{"lineNum":" 3430","line":""},
{"lineNum":" 3431","line":"    /// A nonexistent interface was requested or the requested address was not local."},
{"lineNum":" 3432","line":"    AddressNotAvailable,"},
{"lineNum":" 3433","line":""},
{"lineNum":" 3434","line":"    /// The address is not valid for the address family of socket."},
{"lineNum":" 3435","line":"    AddressFamilyNotSupported,"},
{"lineNum":" 3436","line":""},
{"lineNum":" 3437","line":"    /// Too many symbolic links were encountered in resolving addr."},
{"lineNum":" 3438","line":"    SymLinkLoop,"},
{"lineNum":" 3439","line":""},
{"lineNum":" 3440","line":"    /// addr is too long."},
{"lineNum":" 3441","line":"    NameTooLong,"},
{"lineNum":" 3442","line":""},
{"lineNum":" 3443","line":"    /// A component in the directory prefix of the socket pathname does not exist."},
{"lineNum":" 3444","line":"    FileNotFound,"},
{"lineNum":" 3445","line":""},
{"lineNum":" 3446","line":"    /// Insufficient kernel memory was available."},
{"lineNum":" 3447","line":"    SystemResources,"},
{"lineNum":" 3448","line":""},
{"lineNum":" 3449","line":"    /// A component of the path prefix is not a directory."},
{"lineNum":" 3450","line":"    NotDir,"},
{"lineNum":" 3451","line":""},
{"lineNum":" 3452","line":"    /// The socket inode would reside on a read-only filesystem."},
{"lineNum":" 3453","line":"    ReadOnlyFileSystem,"},
{"lineNum":" 3454","line":""},
{"lineNum":" 3455","line":"    /// The network subsystem has failed."},
{"lineNum":" 3456","line":"    NetworkSubsystemFailed,"},
{"lineNum":" 3457","line":""},
{"lineNum":" 3458","line":"    FileDescriptorNotASocket,"},
{"lineNum":" 3459","line":""},
{"lineNum":" 3460","line":"    AlreadyBound,"},
{"lineNum":" 3461","line":"} || UnexpectedError;"},
{"lineNum":" 3462","line":""},
{"lineNum":" 3463","line":"/// addr is `*const T` where T is one of the sockaddr"},
{"lineNum":" 3464","line":"pub fn bind(sock: socket_t, addr: *const sockaddr, len: socklen_t) BindError!void {"},
{"lineNum":" 3465","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 3466","line":"        const rc = windows.bind(sock, addr, len);"},
{"lineNum":" 3467","line":"        if (rc == windows.ws2_32.SOCKET_ERROR) {"},
{"lineNum":" 3468","line":"            switch (windows.ws2_32.WSAGetLastError()) {"},
{"lineNum":" 3469","line":"                .WSANOTINITIALISED => unreachable, // not initialized WSA"},
{"lineNum":" 3470","line":"                .WSAEACCES => return error.AccessDenied,"},
{"lineNum":" 3471","line":"                .WSAEADDRINUSE => return error.AddressInUse,"},
{"lineNum":" 3472","line":"                .WSAEADDRNOTAVAIL => return error.AddressNotAvailable,"},
{"lineNum":" 3473","line":"                .WSAENOTSOCK => return error.FileDescriptorNotASocket,"},
{"lineNum":" 3474","line":"                .WSAEFAULT => unreachable, // invalid pointers"},
{"lineNum":" 3475","line":"                .WSAEINVAL => return error.AlreadyBound,"},
{"lineNum":" 3476","line":"                .WSAENOBUFS => return error.SystemResources,"},
{"lineNum":" 3477","line":"                .WSAENETDOWN => return error.NetworkSubsystemFailed,"},
{"lineNum":" 3478","line":"                else => |err| return windows.unexpectedWSAError(err),"},
{"lineNum":" 3479","line":"            }"},
{"lineNum":" 3480","line":"            unreachable;"},
{"lineNum":" 3481","line":"        }"},
{"lineNum":" 3482","line":"        return;"},
{"lineNum":" 3483","line":"    } else {"},
{"lineNum":" 3484","line":"        const rc = system.bind(sock, addr, len);"},
{"lineNum":" 3485","line":"        switch (errno(rc)) {"},
{"lineNum":" 3486","line":"            .SUCCESS => return,"},
{"lineNum":" 3487","line":"            .ACCES, .PERM => return error.AccessDenied,"},
{"lineNum":" 3488","line":"            .ADDRINUSE => return error.AddressInUse,"},
{"lineNum":" 3489","line":"            .BADF => unreachable, // always a race condition if this error is returned"},
{"lineNum":" 3490","line":"            .INVAL => unreachable, // invalid parameters"},
{"lineNum":" 3491","line":"            .NOTSOCK => unreachable, // invalid `sockfd`"},
{"lineNum":" 3492","line":"            .AFNOSUPPORT => return error.AddressFamilyNotSupported,"},
{"lineNum":" 3493","line":"            .ADDRNOTAVAIL => return error.AddressNotAvailable,"},
{"lineNum":" 3494","line":"            .FAULT => unreachable, // invalid `addr` pointer"},
{"lineNum":" 3495","line":"            .LOOP => return error.SymLinkLoop,"},
{"lineNum":" 3496","line":"            .NAMETOOLONG => return error.NameTooLong,"},
{"lineNum":" 3497","line":"            .NOENT => return error.FileNotFound,"},
{"lineNum":" 3498","line":"            .NOMEM => return error.SystemResources,"},
{"lineNum":" 3499","line":"            .NOTDIR => return error.NotDir,"},
{"lineNum":" 3500","line":"            .ROFS => return error.ReadOnlyFileSystem,"},
{"lineNum":" 3501","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 3502","line":"        }"},
{"lineNum":" 3503","line":"    }"},
{"lineNum":" 3504","line":"    unreachable;"},
{"lineNum":" 3505","line":"}"},
{"lineNum":" 3506","line":""},
{"lineNum":" 3507","line":"pub const ListenError = error{"},
{"lineNum":" 3508","line":"    /// Another socket is already listening on the same port."},
{"lineNum":" 3509","line":"    /// For Internet domain sockets, the  socket referred to by sockfd had not previously"},
{"lineNum":" 3510","line":"    /// been bound to an address and, upon attempting to bind it to an ephemeral port, it"},
{"lineNum":" 3511","line":"    /// was determined that all port numbers in the ephemeral port range are currently in"},
{"lineNum":" 3512","line":"    /// use.  See the discussion of /proc/sys/net/ipv4/ip_local_port_range in ip(7)."},
{"lineNum":" 3513","line":"    AddressInUse,"},
{"lineNum":" 3514","line":""},
{"lineNum":" 3515","line":"    /// The file descriptor sockfd does not refer to a socket."},
{"lineNum":" 3516","line":"    FileDescriptorNotASocket,"},
{"lineNum":" 3517","line":""},
{"lineNum":" 3518","line":"    /// The socket is not of a type that supports the listen() operation."},
{"lineNum":" 3519","line":"    OperationNotSupported,"},
{"lineNum":" 3520","line":""},
{"lineNum":" 3521","line":"    /// The network subsystem has failed."},
{"lineNum":" 3522","line":"    NetworkSubsystemFailed,"},
{"lineNum":" 3523","line":""},
{"lineNum":" 3524","line":"    /// Ran out of system resources"},
{"lineNum":" 3525","line":"    /// On Windows it can either run out of socket descriptors or buffer space"},
{"lineNum":" 3526","line":"    SystemResources,"},
{"lineNum":" 3527","line":""},
{"lineNum":" 3528","line":"    /// Already connected"},
{"lineNum":" 3529","line":"    AlreadyConnected,"},
{"lineNum":" 3530","line":""},
{"lineNum":" 3531","line":"    /// Socket has not been bound yet"},
{"lineNum":" 3532","line":"    SocketNotBound,"},
{"lineNum":" 3533","line":"} || UnexpectedError;"},
{"lineNum":" 3534","line":""},
{"lineNum":" 3535","line":"pub fn listen(sock: socket_t, backlog: u31) ListenError!void {"},
{"lineNum":" 3536","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 3537","line":"        const rc = windows.listen(sock, backlog);"},
{"lineNum":" 3538","line":"        if (rc == windows.ws2_32.SOCKET_ERROR) {"},
{"lineNum":" 3539","line":"            switch (windows.ws2_32.WSAGetLastError()) {"},
{"lineNum":" 3540","line":"                .WSANOTINITIALISED => unreachable, // not initialized WSA"},
{"lineNum":" 3541","line":"                .WSAENETDOWN => return error.NetworkSubsystemFailed,"},
{"lineNum":" 3542","line":"                .WSAEADDRINUSE => return error.AddressInUse,"},
{"lineNum":" 3543","line":"                .WSAEISCONN => return error.AlreadyConnected,"},
{"lineNum":" 3544","line":"                .WSAEINVAL => return error.SocketNotBound,"},
{"lineNum":" 3545","line":"                .WSAEMFILE, .WSAENOBUFS => return error.SystemResources,"},
{"lineNum":" 3546","line":"                .WSAENOTSOCK => return error.FileDescriptorNotASocket,"},
{"lineNum":" 3547","line":"                .WSAEOPNOTSUPP => return error.OperationNotSupported,"},
{"lineNum":" 3548","line":"                .WSAEINPROGRESS => unreachable,"},
{"lineNum":" 3549","line":"                else => |err| return windows.unexpectedWSAError(err),"},
{"lineNum":" 3550","line":"            }"},
{"lineNum":" 3551","line":"        }"},
{"lineNum":" 3552","line":"        return;"},
{"lineNum":" 3553","line":"    } else {"},
{"lineNum":" 3554","line":"        const rc = system.listen(sock, backlog);"},
{"lineNum":" 3555","line":"        switch (errno(rc)) {"},
{"lineNum":" 3556","line":"            .SUCCESS => return,"},
{"lineNum":" 3557","line":"            .ADDRINUSE => return error.AddressInUse,"},
{"lineNum":" 3558","line":"            .BADF => unreachable,"},
{"lineNum":" 3559","line":"            .NOTSOCK => return error.FileDescriptorNotASocket,"},
{"lineNum":" 3560","line":"            .OPNOTSUPP => return error.OperationNotSupported,"},
{"lineNum":" 3561","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 3562","line":"        }"},
{"lineNum":" 3563","line":"    }"},
{"lineNum":" 3564","line":"}"},
{"lineNum":" 3565","line":""},
{"lineNum":" 3566","line":"pub const AcceptError = error{"},
{"lineNum":" 3567","line":"    ConnectionAborted,"},
{"lineNum":" 3568","line":""},
{"lineNum":" 3569","line":"    /// The file descriptor sockfd does not refer to a socket."},
{"lineNum":" 3570","line":"    FileDescriptorNotASocket,"},
{"lineNum":" 3571","line":""},
{"lineNum":" 3572","line":"    /// The per-process limit on the number of open file descriptors has been reached."},
{"lineNum":" 3573","line":"    ProcessFdQuotaExceeded,"},
{"lineNum":" 3574","line":""},
{"lineNum":" 3575","line":"    /// The system-wide limit on the total number of open files has been reached."},
{"lineNum":" 3576","line":"    SystemFdQuotaExceeded,"},
{"lineNum":" 3577","line":""},
{"lineNum":" 3578","line":"    /// Not enough free memory.  This often means that the memory allocation  is  limited"},
{"lineNum":" 3579","line":"    /// by the socket buffer limits, not by the system memory."},
{"lineNum":" 3580","line":"    SystemResources,"},
{"lineNum":" 3581","line":""},
{"lineNum":" 3582","line":"    /// Socket is not listening for new connections."},
{"lineNum":" 3583","line":"    SocketNotListening,"},
{"lineNum":" 3584","line":""},
{"lineNum":" 3585","line":"    ProtocolFailure,"},
{"lineNum":" 3586","line":""},
{"lineNum":" 3587","line":"    /// Firewall rules forbid connection."},
{"lineNum":" 3588","line":"    BlockedByFirewall,"},
{"lineNum":" 3589","line":""},
{"lineNum":" 3590","line":"    /// This error occurs when no global event loop is configured,"},
{"lineNum":" 3591","line":"    /// and accepting from the socket would block."},
{"lineNum":" 3592","line":"    WouldBlock,"},
{"lineNum":" 3593","line":""},
{"lineNum":" 3594","line":"    /// An incoming connection was indicated, but was subsequently terminated by the"},
{"lineNum":" 3595","line":"    /// remote peer prior to accepting the call."},
{"lineNum":" 3596","line":"    ConnectionResetByPeer,"},
{"lineNum":" 3597","line":""},
{"lineNum":" 3598","line":"    /// The network subsystem has failed."},
{"lineNum":" 3599","line":"    NetworkSubsystemFailed,"},
{"lineNum":" 3600","line":""},
{"lineNum":" 3601","line":"    /// The referenced socket is not a type that supports connection-oriented service."},
{"lineNum":" 3602","line":"    OperationNotSupported,"},
{"lineNum":" 3603","line":"} || UnexpectedError;"},
{"lineNum":" 3604","line":""},
{"lineNum":" 3605","line":"/// Accept a connection on a socket."},
{"lineNum":" 3606","line":"/// If `sockfd` is opened in non blocking mode, the function will"},
{"lineNum":" 3607","line":"/// return error.WouldBlock when EAGAIN is received."},
{"lineNum":" 3608","line":"pub fn accept("},
{"lineNum":" 3609","line":"    /// This argument is a socket that has been created with `socket`, bound to a local address"},
{"lineNum":" 3610","line":"    /// with `bind`, and is listening for connections after a `listen`."},
{"lineNum":" 3611","line":"    sock: socket_t,"},
{"lineNum":" 3612","line":"    /// This argument is a pointer to a sockaddr structure.  This structure is filled in with  the"},
{"lineNum":" 3613","line":"    /// address  of  the  peer  socket, as known to the communications layer.  The exact format of the"},
{"lineNum":" 3614","line":"    /// address returned addr is determined by the socket\'s address  family  (see  `socket`  and  the"},
{"lineNum":" 3615","line":"    /// respective  protocol  man  pages)."},
{"lineNum":" 3616","line":"    addr: ?*sockaddr,"},
{"lineNum":" 3617","line":"    /// This argument is a value-result argument: the caller must initialize it to contain  the"},
{"lineNum":" 3618","line":"    /// size (in bytes) of the structure pointed to by addr; on return it will contain the actual size"},
{"lineNum":" 3619","line":"    /// of the peer address."},
{"lineNum":" 3620","line":"    ///"},
{"lineNum":" 3621","line":"    /// The returned address is truncated if the buffer provided is too small; in this  case,  `addr_size`"},
{"lineNum":" 3622","line":"    /// will return a value greater than was supplied to the call."},
{"lineNum":" 3623","line":"    addr_size: ?*socklen_t,"},
{"lineNum":" 3624","line":"    /// The following values can be bitwise ORed in flags to obtain different behavior:"},
{"lineNum":" 3625","line":"    /// * `SOCK.NONBLOCK` - Set the `O.NONBLOCK` file status flag on the open file description (see `open`)"},
{"lineNum":" 3626","line":"    ///   referred  to by the new file descriptor.  Using this flag saves extra calls to `fcntl` to achieve"},
{"lineNum":" 3627","line":"    ///   the same result."},
{"lineNum":" 3628","line":"    /// * `SOCK.CLOEXEC`  - Set the close-on-exec (`FD_CLOEXEC`) flag on the new file descriptor.   See  the"},
{"lineNum":" 3629","line":"    ///   description  of the `O.CLOEXEC` flag in `open` for reasons why this may be useful."},
{"lineNum":" 3630","line":"    flags: u32,"},
{"lineNum":" 3631","line":") AcceptError!socket_t {"},
{"lineNum":" 3632","line":"    const have_accept4 = comptime !(builtin.target.isDarwin() or builtin.os.tag == .windows);"},
{"lineNum":" 3633","line":"    assert(0 == (flags & ~@as(u32, SOCK.NONBLOCK | SOCK.CLOEXEC))); // Unsupported flag(s)"},
{"lineNum":" 3634","line":""},
{"lineNum":" 3635","line":"    const accepted_sock = while (true) {"},
{"lineNum":" 3636","line":"        const rc = if (have_accept4)"},
{"lineNum":" 3637","line":"            system.accept4(sock, addr, addr_size, flags)"},
{"lineNum":" 3638","line":"        else if (builtin.os.tag == .windows)"},
{"lineNum":" 3639","line":"            windows.accept(sock, addr, addr_size)"},
{"lineNum":" 3640","line":"        else"},
{"lineNum":" 3641","line":"            system.accept(sock, addr, addr_size);"},
{"lineNum":" 3642","line":""},
{"lineNum":" 3643","line":"        if (builtin.os.tag == .windows) {"},
{"lineNum":" 3644","line":"            if (rc == windows.ws2_32.INVALID_SOCKET) {"},
{"lineNum":" 3645","line":"                switch (windows.ws2_32.WSAGetLastError()) {"},
{"lineNum":" 3646","line":"                    .WSANOTINITIALISED => unreachable, // not initialized WSA"},
{"lineNum":" 3647","line":"                    .WSAECONNRESET => return error.ConnectionResetByPeer,"},
{"lineNum":" 3648","line":"                    .WSAEFAULT => unreachable,"},
{"lineNum":" 3649","line":"                    .WSAEINVAL => return error.SocketNotListening,"},
{"lineNum":" 3650","line":"                    .WSAEMFILE => return error.ProcessFdQuotaExceeded,"},
{"lineNum":" 3651","line":"                    .WSAENETDOWN => return error.NetworkSubsystemFailed,"},
{"lineNum":" 3652","line":"                    .WSAENOBUFS => return error.FileDescriptorNotASocket,"},
{"lineNum":" 3653","line":"                    .WSAEOPNOTSUPP => return error.OperationNotSupported,"},
{"lineNum":" 3654","line":"                    .WSAEWOULDBLOCK => return error.WouldBlock,"},
{"lineNum":" 3655","line":"                    else => |err| return windows.unexpectedWSAError(err),"},
{"lineNum":" 3656","line":"                }"},
{"lineNum":" 3657","line":"            } else {"},
{"lineNum":" 3658","line":"                break rc;"},
{"lineNum":" 3659","line":"            }"},
{"lineNum":" 3660","line":"        } else {"},
{"lineNum":" 3661","line":"            switch (errno(rc)) {"},
{"lineNum":" 3662","line":"                .SUCCESS => {"},
{"lineNum":" 3663","line":"                    break @as(socket_t, @intCast(rc));"},
{"lineNum":" 3664","line":"                },"},
{"lineNum":" 3665","line":"                .INTR => continue,"},
{"lineNum":" 3666","line":"                .AGAIN => return error.WouldBlock,"},
{"lineNum":" 3667","line":"                .BADF => unreachable, // always a race condition"},
{"lineNum":" 3668","line":"                .CONNABORTED => return error.ConnectionAborted,"},
{"lineNum":" 3669","line":"                .FAULT => unreachable,"},
{"lineNum":" 3670","line":"                .INVAL => return error.SocketNotListening,"},
{"lineNum":" 3671","line":"                .NOTSOCK => unreachable,"},
{"lineNum":" 3672","line":"                .MFILE => return error.ProcessFdQuotaExceeded,"},
{"lineNum":" 3673","line":"                .NFILE => return error.SystemFdQuotaExceeded,"},
{"lineNum":" 3674","line":"                .NOBUFS => return error.SystemResources,"},
{"lineNum":" 3675","line":"                .NOMEM => return error.SystemResources,"},
{"lineNum":" 3676","line":"                .OPNOTSUPP => unreachable,"},
{"lineNum":" 3677","line":"                .PROTO => return error.ProtocolFailure,"},
{"lineNum":" 3678","line":"                .PERM => return error.BlockedByFirewall,"},
{"lineNum":" 3679","line":"                else => |err| return unexpectedErrno(err),"},
{"lineNum":" 3680","line":"            }"},
{"lineNum":" 3681","line":"        }"},
{"lineNum":" 3682","line":"    };"},
{"lineNum":" 3683","line":""},
{"lineNum":" 3684","line":"    if (!have_accept4) {"},
{"lineNum":" 3685","line":"        try setSockFlags(accepted_sock, flags);"},
{"lineNum":" 3686","line":"    }"},
{"lineNum":" 3687","line":"    return accepted_sock;"},
{"lineNum":" 3688","line":"}"},
{"lineNum":" 3689","line":""},
{"lineNum":" 3690","line":"pub const EpollCreateError = error{"},
{"lineNum":" 3691","line":"    /// The  per-user   limit   on   the   number   of   epoll   instances   imposed   by"},
{"lineNum":" 3692","line":"    /// /proc/sys/fs/epoll/max_user_instances  was encountered.  See epoll(7) for further"},
{"lineNum":" 3693","line":"    /// details."},
{"lineNum":" 3694","line":"    /// Or, The per-process limit on the number of open file descriptors has been reached."},
{"lineNum":" 3695","line":"    ProcessFdQuotaExceeded,"},
{"lineNum":" 3696","line":""},
{"lineNum":" 3697","line":"    /// The system-wide limit on the total number of open files has been reached."},
{"lineNum":" 3698","line":"    SystemFdQuotaExceeded,"},
{"lineNum":" 3699","line":""},
{"lineNum":" 3700","line":"    /// There was insufficient memory to create the kernel object."},
{"lineNum":" 3701","line":"    SystemResources,"},
{"lineNum":" 3702","line":"} || UnexpectedError;"},
{"lineNum":" 3703","line":""},
{"lineNum":" 3704","line":"pub fn epoll_create1(flags: u32) EpollCreateError!i32 {"},
{"lineNum":" 3705","line":"    const rc = system.epoll_create1(flags);"},
{"lineNum":" 3706","line":"    switch (errno(rc)) {"},
{"lineNum":" 3707","line":"        .SUCCESS => return @as(i32, @intCast(rc)),"},
{"lineNum":" 3708","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 3709","line":""},
{"lineNum":" 3710","line":"        .INVAL => unreachable,"},
{"lineNum":" 3711","line":"        .MFILE => return error.ProcessFdQuotaExceeded,"},
{"lineNum":" 3712","line":"        .NFILE => return error.SystemFdQuotaExceeded,"},
{"lineNum":" 3713","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 3714","line":"    }"},
{"lineNum":" 3715","line":"}"},
{"lineNum":" 3716","line":""},
{"lineNum":" 3717","line":"pub const EpollCtlError = error{"},
{"lineNum":" 3718","line":"    /// op was EPOLL_CTL_ADD, and the supplied file descriptor fd is  already  registered"},
{"lineNum":" 3719","line":"    /// with this epoll instance."},
{"lineNum":" 3720","line":"    FileDescriptorAlreadyPresentInSet,"},
{"lineNum":" 3721","line":""},
{"lineNum":" 3722","line":"    /// fd refers to an epoll instance and this EPOLL_CTL_ADD operation would result in a"},
{"lineNum":" 3723","line":"    /// circular loop of epoll instances monitoring one another."},
{"lineNum":" 3724","line":"    OperationCausesCircularLoop,"},
{"lineNum":" 3725","line":""},
{"lineNum":" 3726","line":"    /// op was EPOLL_CTL_MOD or EPOLL_CTL_DEL, and fd is not registered with  this  epoll"},
{"lineNum":" 3727","line":"    /// instance."},
{"lineNum":" 3728","line":"    FileDescriptorNotRegistered,"},
{"lineNum":" 3729","line":""},
{"lineNum":" 3730","line":"    /// There was insufficient memory to handle the requested op control operation."},
{"lineNum":" 3731","line":"    SystemResources,"},
{"lineNum":" 3732","line":""},
{"lineNum":" 3733","line":"    /// The  limit  imposed  by /proc/sys/fs/epoll/max_user_watches was encountered while"},
{"lineNum":" 3734","line":"    /// trying to register (EPOLL_CTL_ADD) a new file descriptor on  an  epoll  instance."},
{"lineNum":" 3735","line":"    /// See epoll(7) for further details."},
{"lineNum":" 3736","line":"    UserResourceLimitReached,"},
{"lineNum":" 3737","line":""},
{"lineNum":" 3738","line":"    /// The target file fd does not support epoll.  This error can occur if fd refers to,"},
{"lineNum":" 3739","line":"    /// for example, a regular file or a directory."},
{"lineNum":" 3740","line":"    FileDescriptorIncompatibleWithEpoll,"},
{"lineNum":" 3741","line":"} || UnexpectedError;"},
{"lineNum":" 3742","line":""},
{"lineNum":" 3743","line":"pub fn epoll_ctl(epfd: i32, op: u32, fd: i32, event: ?*linux.epoll_event) EpollCtlError!void {"},
{"lineNum":" 3744","line":"    const rc = system.epoll_ctl(epfd, op, fd, event);"},
{"lineNum":" 3745","line":"    switch (errno(rc)) {"},
{"lineNum":" 3746","line":"        .SUCCESS => return,"},
{"lineNum":" 3747","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 3748","line":""},
{"lineNum":" 3749","line":"        .BADF => unreachable, // always a race condition if this happens"},
{"lineNum":" 3750","line":"        .EXIST => return error.FileDescriptorAlreadyPresentInSet,"},
{"lineNum":" 3751","line":"        .INVAL => unreachable,"},
{"lineNum":" 3752","line":"        .LOOP => return error.OperationCausesCircularLoop,"},
{"lineNum":" 3753","line":"        .NOENT => return error.FileDescriptorNotRegistered,"},
{"lineNum":" 3754","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 3755","line":"        .NOSPC => return error.UserResourceLimitReached,"},
{"lineNum":" 3756","line":"        .PERM => return error.FileDescriptorIncompatibleWithEpoll,"},
{"lineNum":" 3757","line":"    }"},
{"lineNum":" 3758","line":"}"},
{"lineNum":" 3759","line":""},
{"lineNum":" 3760","line":"/// Waits for an I/O event on an epoll file descriptor."},
{"lineNum":" 3761","line":"/// Returns the number of file descriptors ready for the requested I/O,"},
{"lineNum":" 3762","line":"/// or zero if no file descriptor became ready during the requested timeout milliseconds."},
{"lineNum":" 3763","line":"pub fn epoll_wait(epfd: i32, events: []linux.epoll_event, timeout: i32) usize {"},
{"lineNum":" 3764","line":"    while (true) {"},
{"lineNum":" 3765","line":"        // TODO get rid of the @intCast"},
{"lineNum":" 3766","line":"        const rc = system.epoll_wait(epfd, events.ptr, @as(u32, @intCast(events.len)), timeout);"},
{"lineNum":" 3767","line":"        switch (errno(rc)) {"},
{"lineNum":" 3768","line":"            .SUCCESS => return @as(usize, @intCast(rc)),"},
{"lineNum":" 3769","line":"            .INTR => continue,"},
{"lineNum":" 3770","line":"            .BADF => unreachable,"},
{"lineNum":" 3771","line":"            .FAULT => unreachable,"},
{"lineNum":" 3772","line":"            .INVAL => unreachable,"},
{"lineNum":" 3773","line":"            else => unreachable,"},
{"lineNum":" 3774","line":"        }"},
{"lineNum":" 3775","line":"    }"},
{"lineNum":" 3776","line":"}"},
{"lineNum":" 3777","line":""},
{"lineNum":" 3778","line":"pub const EventFdError = error{"},
{"lineNum":" 3779","line":"    SystemResources,"},
{"lineNum":" 3780","line":"    ProcessFdQuotaExceeded,"},
{"lineNum":" 3781","line":"    SystemFdQuotaExceeded,"},
{"lineNum":" 3782","line":"} || UnexpectedError;"},
{"lineNum":" 3783","line":""},
{"lineNum":" 3784","line":"pub fn eventfd(initval: u32, flags: u32) EventFdError!i32 {"},
{"lineNum":" 3785","line":"    const rc = system.eventfd(initval, flags);"},
{"lineNum":" 3786","line":"    switch (errno(rc)) {"},
{"lineNum":" 3787","line":"        .SUCCESS => return @as(i32, @intCast(rc)),"},
{"lineNum":" 3788","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 3789","line":""},
{"lineNum":" 3790","line":"        .INVAL => unreachable, // invalid parameters"},
{"lineNum":" 3791","line":"        .MFILE => return error.ProcessFdQuotaExceeded,"},
{"lineNum":" 3792","line":"        .NFILE => return error.SystemFdQuotaExceeded,"},
{"lineNum":" 3793","line":"        .NODEV => return error.SystemResources,"},
{"lineNum":" 3794","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 3795","line":"    }"},
{"lineNum":" 3796","line":"}"},
{"lineNum":" 3797","line":""},
{"lineNum":" 3798","line":"pub const GetSockNameError = error{"},
{"lineNum":" 3799","line":"    /// Insufficient resources were available in the system to perform the operation."},
{"lineNum":" 3800","line":"    SystemResources,"},
{"lineNum":" 3801","line":""},
{"lineNum":" 3802","line":"    /// The network subsystem has failed."},
{"lineNum":" 3803","line":"    NetworkSubsystemFailed,"},
{"lineNum":" 3804","line":""},
{"lineNum":" 3805","line":"    /// Socket hasn\'t been bound yet"},
{"lineNum":" 3806","line":"    SocketNotBound,"},
{"lineNum":" 3807","line":""},
{"lineNum":" 3808","line":"    FileDescriptorNotASocket,"},
{"lineNum":" 3809","line":"} || UnexpectedError;"},
{"lineNum":" 3810","line":""},
{"lineNum":" 3811","line":"pub fn getsockname(sock: socket_t, addr: *sockaddr, addrlen: *socklen_t) GetSockNameError!void {"},
{"lineNum":" 3812","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 3813","line":"        const rc = windows.getsockname(sock, addr, addrlen);"},
{"lineNum":" 3814","line":"        if (rc == windows.ws2_32.SOCKET_ERROR) {"},
{"lineNum":" 3815","line":"            switch (windows.ws2_32.WSAGetLastError()) {"},
{"lineNum":" 3816","line":"                .WSANOTINITIALISED => unreachable,"},
{"lineNum":" 3817","line":"                .WSAENETDOWN => return error.NetworkSubsystemFailed,"},
{"lineNum":" 3818","line":"                .WSAEFAULT => unreachable, // addr or addrlen have invalid pointers or addrlen points to an incorrect value"},
{"lineNum":" 3819","line":"                .WSAENOTSOCK => return error.FileDescriptorNotASocket,"},
{"lineNum":" 3820","line":"                .WSAEINVAL => return error.SocketNotBound,"},
{"lineNum":" 3821","line":"                else => |err| return windows.unexpectedWSAError(err),"},
{"lineNum":" 3822","line":"            }"},
{"lineNum":" 3823","line":"        }"},
{"lineNum":" 3824","line":"        return;"},
{"lineNum":" 3825","line":"    } else {"},
{"lineNum":" 3826","line":"        const rc = system.getsockname(sock, addr, addrlen);"},
{"lineNum":" 3827","line":"        switch (errno(rc)) {"},
{"lineNum":" 3828","line":"            .SUCCESS => return,"},
{"lineNum":" 3829","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 3830","line":""},
{"lineNum":" 3831","line":"            .BADF => unreachable, // always a race condition"},
{"lineNum":" 3832","line":"            .FAULT => unreachable,"},
{"lineNum":" 3833","line":"            .INVAL => unreachable, // invalid parameters"},
{"lineNum":" 3834","line":"            .NOTSOCK => return error.FileDescriptorNotASocket,"},
{"lineNum":" 3835","line":"            .NOBUFS => return error.SystemResources,"},
{"lineNum":" 3836","line":"        }"},
{"lineNum":" 3837","line":"    }"},
{"lineNum":" 3838","line":"}"},
{"lineNum":" 3839","line":""},
{"lineNum":" 3840","line":"pub fn getpeername(sock: socket_t, addr: *sockaddr, addrlen: *socklen_t) GetSockNameError!void {"},
{"lineNum":" 3841","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 3842","line":"        const rc = windows.getpeername(sock, addr, addrlen);"},
{"lineNum":" 3843","line":"        if (rc == windows.ws2_32.SOCKET_ERROR) {"},
{"lineNum":" 3844","line":"            switch (windows.ws2_32.WSAGetLastError()) {"},
{"lineNum":" 3845","line":"                .WSANOTINITIALISED => unreachable,"},
{"lineNum":" 3846","line":"                .WSAENETDOWN => return error.NetworkSubsystemFailed,"},
{"lineNum":" 3847","line":"                .WSAEFAULT => unreachable, // addr or addrlen have invalid pointers or addrlen points to an incorrect value"},
{"lineNum":" 3848","line":"                .WSAENOTSOCK => return error.FileDescriptorNotASocket,"},
{"lineNum":" 3849","line":"                .WSAEINVAL => return error.SocketNotBound,"},
{"lineNum":" 3850","line":"                else => |err| return windows.unexpectedWSAError(err),"},
{"lineNum":" 3851","line":"            }"},
{"lineNum":" 3852","line":"        }"},
{"lineNum":" 3853","line":"        return;"},
{"lineNum":" 3854","line":"    } else {"},
{"lineNum":" 3855","line":"        const rc = system.getpeername(sock, addr, addrlen);"},
{"lineNum":" 3856","line":"        switch (errno(rc)) {"},
{"lineNum":" 3857","line":"            .SUCCESS => return,"},
{"lineNum":" 3858","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 3859","line":""},
{"lineNum":" 3860","line":"            .BADF => unreachable, // always a race condition"},
{"lineNum":" 3861","line":"            .FAULT => unreachable,"},
{"lineNum":" 3862","line":"            .INVAL => unreachable, // invalid parameters"},
{"lineNum":" 3863","line":"            .NOTSOCK => return error.FileDescriptorNotASocket,"},
{"lineNum":" 3864","line":"            .NOBUFS => return error.SystemResources,"},
{"lineNum":" 3865","line":"        }"},
{"lineNum":" 3866","line":"    }"},
{"lineNum":" 3867","line":"}"},
{"lineNum":" 3868","line":""},
{"lineNum":" 3869","line":"pub const ConnectError = error{"},
{"lineNum":" 3870","line":"    /// For UNIX domain sockets, which are identified by pathname: Write permission is denied on  the  socket"},
{"lineNum":" 3871","line":"    /// file,  or  search  permission  is  denied  for  one of the directories in the path prefix."},
{"lineNum":" 3872","line":"    /// or"},
{"lineNum":" 3873","line":"    /// The user tried to connect to a broadcast address without having the socket broadcast flag enabled  or"},
{"lineNum":" 3874","line":"    /// the connection request failed because of a local firewall rule."},
{"lineNum":" 3875","line":"    PermissionDenied,"},
{"lineNum":" 3876","line":""},
{"lineNum":" 3877","line":"    /// Local address is already in use."},
{"lineNum":" 3878","line":"    AddressInUse,"},
{"lineNum":" 3879","line":""},
{"lineNum":" 3880","line":"    /// (Internet  domain  sockets)  The  socket  referred  to  by sockfd had not previously been bound to an"},
{"lineNum":" 3881","line":"    /// address and, upon attempting to bind it to an ephemeral port, it was determined that all port numbers"},
{"lineNum":" 3882","line":"    /// in    the    ephemeral    port    range    are   currently   in   use.    See   the   discussion   of"},
{"lineNum":" 3883","line":"    /// /proc/sys/net/ipv4/ip_local_port_range in ip(7)."},
{"lineNum":" 3884","line":"    AddressNotAvailable,"},
{"lineNum":" 3885","line":""},
{"lineNum":" 3886","line":"    /// The passed address didn\'t have the correct address family in its sa_family field."},
{"lineNum":" 3887","line":"    AddressFamilyNotSupported,"},
{"lineNum":" 3888","line":""},
{"lineNum":" 3889","line":"    /// Insufficient entries in the routing cache."},
{"lineNum":" 3890","line":"    SystemResources,"},
{"lineNum":" 3891","line":""},
{"lineNum":" 3892","line":"    /// A connect() on a stream socket found no one listening on the remote address."},
{"lineNum":" 3893","line":"    ConnectionRefused,"},
{"lineNum":" 3894","line":""},
{"lineNum":" 3895","line":"    /// Network is unreachable."},
{"lineNum":" 3896","line":"    NetworkUnreachable,"},
{"lineNum":" 3897","line":""},
{"lineNum":" 3898","line":"    /// Timeout  while  attempting  connection.   The server may be too busy to accept new connections.  Note"},
{"lineNum":" 3899","line":"    /// that for IP sockets the timeout may be very long when syncookies are enabled on the server."},
{"lineNum":" 3900","line":"    ConnectionTimedOut,"},
{"lineNum":" 3901","line":""},
{"lineNum":" 3902","line":"    /// This error occurs when no global event loop is configured,"},
{"lineNum":" 3903","line":"    /// and connecting to the socket would block."},
{"lineNum":" 3904","line":"    WouldBlock,"},
{"lineNum":" 3905","line":""},
{"lineNum":" 3906","line":"    /// The given path for the unix socket does not exist."},
{"lineNum":" 3907","line":"    FileNotFound,"},
{"lineNum":" 3908","line":""},
{"lineNum":" 3909","line":"    /// Connection was reset by peer before connect could complete."},
{"lineNum":" 3910","line":"    ConnectionResetByPeer,"},
{"lineNum":" 3911","line":""},
{"lineNum":" 3912","line":"    /// Socket is non-blocking and already has a pending connection in progress."},
{"lineNum":" 3913","line":"    ConnectionPending,"},
{"lineNum":" 3914","line":"} || UnexpectedError;"},
{"lineNum":" 3915","line":""},
{"lineNum":" 3916","line":"/// Initiate a connection on a socket."},
{"lineNum":" 3917","line":"/// If `sockfd` is opened in non blocking mode, the function will"},
{"lineNum":" 3918","line":"/// return error.WouldBlock when EAGAIN or EINPROGRESS is received."},
{"lineNum":" 3919","line":"pub fn connect(sock: socket_t, sock_addr: *const sockaddr, len: socklen_t) ConnectError!void {"},
{"lineNum":" 3920","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 3921","line":"        const rc = windows.ws2_32.connect(sock, sock_addr, @as(i32, @intCast(len)));"},
{"lineNum":" 3922","line":"        if (rc == 0) return;"},
{"lineNum":" 3923","line":"        switch (windows.ws2_32.WSAGetLastError()) {"},
{"lineNum":" 3924","line":"            .WSAEADDRINUSE => return error.AddressInUse,"},
{"lineNum":" 3925","line":"            .WSAEADDRNOTAVAIL => return error.AddressNotAvailable,"},
{"lineNum":" 3926","line":"            .WSAECONNREFUSED => return error.ConnectionRefused,"},
{"lineNum":" 3927","line":"            .WSAECONNRESET => return error.ConnectionResetByPeer,"},
{"lineNum":" 3928","line":"            .WSAETIMEDOUT => return error.ConnectionTimedOut,"},
{"lineNum":" 3929","line":"            .WSAEHOSTUNREACH, // TODO: should we return NetworkUnreachable in this case as well?"},
{"lineNum":" 3930","line":"            .WSAENETUNREACH,"},
{"lineNum":" 3931","line":"            => return error.NetworkUnreachable,"},
{"lineNum":" 3932","line":"            .WSAEFAULT => unreachable,"},
{"lineNum":" 3933","line":"            .WSAEINVAL => unreachable,"},
{"lineNum":" 3934","line":"            .WSAEISCONN => unreachable,"},
{"lineNum":" 3935","line":"            .WSAENOTSOCK => unreachable,"},
{"lineNum":" 3936","line":"            .WSAEWOULDBLOCK => unreachable,"},
{"lineNum":" 3937","line":"            .WSAEACCES => unreachable,"},
{"lineNum":" 3938","line":"            .WSAENOBUFS => return error.SystemResources,"},
{"lineNum":" 3939","line":"            .WSAEAFNOSUPPORT => return error.AddressFamilyNotSupported,"},
{"lineNum":" 3940","line":"            else => |err| return windows.unexpectedWSAError(err),"},
{"lineNum":" 3941","line":"        }"},
{"lineNum":" 3942","line":"        return;"},
{"lineNum":" 3943","line":"    }"},
{"lineNum":" 3944","line":""},
{"lineNum":" 3945","line":"    while (true) {"},
{"lineNum":" 3946","line":"        switch (errno(system.connect(sock, sock_addr, len))) {"},
{"lineNum":" 3947","line":"            .SUCCESS => return,"},
{"lineNum":" 3948","line":"            .ACCES => return error.PermissionDenied,"},
{"lineNum":" 3949","line":"            .PERM => return error.PermissionDenied,"},
{"lineNum":" 3950","line":"            .ADDRINUSE => return error.AddressInUse,"},
{"lineNum":" 3951","line":"            .ADDRNOTAVAIL => return error.AddressNotAvailable,"},
{"lineNum":" 3952","line":"            .AFNOSUPPORT => return error.AddressFamilyNotSupported,"},
{"lineNum":" 3953","line":"            .AGAIN, .INPROGRESS => return error.WouldBlock,"},
{"lineNum":" 3954","line":"            .ALREADY => return error.ConnectionPending,"},
{"lineNum":" 3955","line":"            .BADF => unreachable, // sockfd is not a valid open file descriptor."},
{"lineNum":" 3956","line":"            .CONNREFUSED => return error.ConnectionRefused,"},
{"lineNum":" 3957","line":"            .CONNRESET => return error.ConnectionResetByPeer,"},
{"lineNum":" 3958","line":"            .FAULT => unreachable, // The socket structure address is outside the user\'s address space."},
{"lineNum":" 3959","line":"            .INTR => continue,"},
{"lineNum":" 3960","line":"            .ISCONN => unreachable, // The socket is already connected."},
{"lineNum":" 3961","line":"            .HOSTUNREACH => return error.NetworkUnreachable,"},
{"lineNum":" 3962","line":"            .NETUNREACH => return error.NetworkUnreachable,"},
{"lineNum":" 3963","line":"            .NOTSOCK => unreachable, // The file descriptor sockfd does not refer to a socket."},
{"lineNum":" 3964","line":"            .PROTOTYPE => unreachable, // The socket type does not support the requested communications protocol."},
{"lineNum":" 3965","line":"            .TIMEDOUT => return error.ConnectionTimedOut,"},
{"lineNum":" 3966","line":"            .NOENT => return error.FileNotFound, // Returned when socket is AF.UNIX and the given path does not exist."},
{"lineNum":" 3967","line":"            .CONNABORTED => unreachable, // Tried to reuse socket that previously received error.ConnectionRefused."},
{"lineNum":" 3968","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 3969","line":"        }"},
{"lineNum":" 3970","line":"    }"},
{"lineNum":" 3971","line":"}"},
{"lineNum":" 3972","line":""},
{"lineNum":" 3973","line":"pub fn getsockoptError(sockfd: fd_t) ConnectError!void {"},
{"lineNum":" 3974","line":"    var err_code: i32 = undefined;"},
{"lineNum":" 3975","line":"    var size: u32 = @sizeOf(u32);"},
{"lineNum":" 3976","line":"    const rc = system.getsockopt(sockfd, SOL.SOCKET, SO.ERROR, @as([*]u8, @ptrCast(&err_code)), &size);"},
{"lineNum":" 3977","line":"    assert(size == 4);"},
{"lineNum":" 3978","line":"    switch (errno(rc)) {"},
{"lineNum":" 3979","line":"        .SUCCESS => switch (@as(E, @enumFromInt(err_code))) {"},
{"lineNum":" 3980","line":"            .SUCCESS => return,"},
{"lineNum":" 3981","line":"            .ACCES => return error.PermissionDenied,"},
{"lineNum":" 3982","line":"            .PERM => return error.PermissionDenied,"},
{"lineNum":" 3983","line":"            .ADDRINUSE => return error.AddressInUse,"},
{"lineNum":" 3984","line":"            .ADDRNOTAVAIL => return error.AddressNotAvailable,"},
{"lineNum":" 3985","line":"            .AFNOSUPPORT => return error.AddressFamilyNotSupported,"},
{"lineNum":" 3986","line":"            .AGAIN => return error.SystemResources,"},
{"lineNum":" 3987","line":"            .ALREADY => return error.ConnectionPending,"},
{"lineNum":" 3988","line":"            .BADF => unreachable, // sockfd is not a valid open file descriptor."},
{"lineNum":" 3989","line":"            .CONNREFUSED => return error.ConnectionRefused,"},
{"lineNum":" 3990","line":"            .FAULT => unreachable, // The socket structure address is outside the user\'s address space."},
{"lineNum":" 3991","line":"            .ISCONN => unreachable, // The socket is already connected."},
{"lineNum":" 3992","line":"            .HOSTUNREACH => return error.NetworkUnreachable,"},
{"lineNum":" 3993","line":"            .NETUNREACH => return error.NetworkUnreachable,"},
{"lineNum":" 3994","line":"            .NOTSOCK => unreachable, // The file descriptor sockfd does not refer to a socket."},
{"lineNum":" 3995","line":"            .PROTOTYPE => unreachable, // The socket type does not support the requested communications protocol."},
{"lineNum":" 3996","line":"            .TIMEDOUT => return error.ConnectionTimedOut,"},
{"lineNum":" 3997","line":"            .CONNRESET => return error.ConnectionResetByPeer,"},
{"lineNum":" 3998","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 3999","line":"        },"},
{"lineNum":" 4000","line":"        .BADF => unreachable, // The argument sockfd is not a valid file descriptor."},
{"lineNum":" 4001","line":"        .FAULT => unreachable, // The address pointed to by optval or optlen is not in a valid part of the process address space."},
{"lineNum":" 4002","line":"        .INVAL => unreachable,"},
{"lineNum":" 4003","line":"        .NOPROTOOPT => unreachable, // The option is unknown at the level indicated."},
{"lineNum":" 4004","line":"        .NOTSOCK => unreachable, // The file descriptor sockfd does not refer to a socket."},
{"lineNum":" 4005","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 4006","line":"    }"},
{"lineNum":" 4007","line":"}"},
{"lineNum":" 4008","line":""},
{"lineNum":" 4009","line":"pub const WaitPidResult = struct {"},
{"lineNum":" 4010","line":"    pid: pid_t,"},
{"lineNum":" 4011","line":"    status: u32,"},
{"lineNum":" 4012","line":"};"},
{"lineNum":" 4013","line":""},
{"lineNum":" 4014","line":"/// Use this version of the `waitpid` wrapper if you spawned your child process using explicit"},
{"lineNum":" 4015","line":"/// `fork` and `execve` method."},
{"lineNum":" 4016","line":"pub fn waitpid(pid: pid_t, flags: u32) WaitPidResult {"},
{"lineNum":" 4017","line":"    const Status = if (builtin.link_libc) c_int else u32;"},
{"lineNum":" 4018","line":"    var status: Status = undefined;"},
{"lineNum":" 4019","line":"    const coerced_flags = if (builtin.link_libc) @as(c_int, @intCast(flags)) else flags;"},
{"lineNum":" 4020","line":"    while (true) {"},
{"lineNum":" 4021","line":"        const rc = system.waitpid(pid, &status, coerced_flags);"},
{"lineNum":" 4022","line":"        switch (errno(rc)) {"},
{"lineNum":" 4023","line":"            .SUCCESS => return .{"},
{"lineNum":" 4024","line":"                .pid = @as(pid_t, @intCast(rc)),"},
{"lineNum":" 4025","line":"                .status = @as(u32, @bitCast(status)),"},
{"lineNum":" 4026","line":"            },"},
{"lineNum":" 4027","line":"            .INTR => continue,"},
{"lineNum":" 4028","line":"            .CHILD => unreachable, // The process specified does not exist. It would be a race condition to handle this error."},
{"lineNum":" 4029","line":"            .INVAL => unreachable, // Invalid flags."},
{"lineNum":" 4030","line":"            else => unreachable,"},
{"lineNum":" 4031","line":"        }"},
{"lineNum":" 4032","line":"    }"},
{"lineNum":" 4033","line":"}"},
{"lineNum":" 4034","line":""},
{"lineNum":" 4035","line":"pub fn wait4(pid: pid_t, flags: u32, ru: ?*rusage) WaitPidResult {"},
{"lineNum":" 4036","line":"    const Status = if (builtin.link_libc) c_int else u32;"},
{"lineNum":" 4037","line":"    var status: Status = undefined;"},
{"lineNum":" 4038","line":"    const coerced_flags = if (builtin.link_libc) @as(c_int, @intCast(flags)) else flags;"},
{"lineNum":" 4039","line":"    while (true) {"},
{"lineNum":" 4040","line":"        const rc = system.wait4(pid, &status, coerced_flags, ru);"},
{"lineNum":" 4041","line":"        switch (errno(rc)) {"},
{"lineNum":" 4042","line":"            .SUCCESS => return .{"},
{"lineNum":" 4043","line":"                .pid = @as(pid_t, @intCast(rc)),"},
{"lineNum":" 4044","line":"                .status = @as(u32, @bitCast(status)),"},
{"lineNum":" 4045","line":"            },"},
{"lineNum":" 4046","line":"            .INTR => continue,"},
{"lineNum":" 4047","line":"            .CHILD => unreachable, // The process specified does not exist. It would be a race condition to handle this error."},
{"lineNum":" 4048","line":"            .INVAL => unreachable, // Invalid flags."},
{"lineNum":" 4049","line":"            else => unreachable,"},
{"lineNum":" 4050","line":"        }"},
{"lineNum":" 4051","line":"    }"},
{"lineNum":" 4052","line":"}"},
{"lineNum":" 4053","line":""},
{"lineNum":" 4054","line":"pub const FStatError = error{"},
{"lineNum":" 4055","line":"    SystemResources,"},
{"lineNum":" 4056","line":""},
{"lineNum":" 4057","line":"    /// In WASI, this error may occur when the file descriptor does"},
{"lineNum":" 4058","line":"    /// not hold the required rights to get its filestat information."},
{"lineNum":" 4059","line":"    AccessDenied,"},
{"lineNum":" 4060","line":"} || UnexpectedError;"},
{"lineNum":" 4061","line":""},
{"lineNum":" 4062","line":"/// Return information about a file descriptor."},
{"lineNum":" 4063","line":"pub fn fstat(fd: fd_t) FStatError!Stat {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 4064","line":"    if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 4065","line":"        var stat: wasi.filestat_t = undefined;"},
{"lineNum":" 4066","line":"        switch (wasi.fd_filestat_get(fd, &stat)) {"},
{"lineNum":" 4067","line":"            .SUCCESS => return Stat.fromFilestat(stat),"},
{"lineNum":" 4068","line":"            .INVAL => unreachable,"},
{"lineNum":" 4069","line":"            .BADF => unreachable, // Always a race condition."},
{"lineNum":" 4070","line":"            .NOMEM => return error.SystemResources,"},
{"lineNum":" 4071","line":"            .ACCES => return error.AccessDenied,"},
{"lineNum":" 4072","line":"            .NOTCAPABLE => return error.AccessDenied,"},
{"lineNum":" 4073","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 4074","line":"        }"},
{"lineNum":" 4075","line":"    }"},
{"lineNum":" 4076","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 4077","line":"        @compileError(\"fstat is not yet implemented on Windows\");"},
{"lineNum":" 4078","line":"    }"},
{"lineNum":" 4079","line":""},
{"lineNum":" 4080","line":"    const fstat_sym = if (lfs64_abi) system.fstat64 else system.fstat;"},
{"lineNum":" 4081","line":""},
{"lineNum":" 4082","line":"    var stat = mem.zeroes(Stat);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 4083","line":"    switch (errno(fstat_sym(fd, &stat))) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 4084","line":"        .SUCCESS => return stat,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 4085","line":"        .INVAL => unreachable,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 4086","line":"        .BADF => unreachable, // Always a race condition.","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 4087","line":"        .NOMEM => return error.SystemResources,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 4088","line":"        .ACCES => return error.AccessDenied,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 4089","line":"        else => |err| return unexpectedErrno(err),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 4090","line":"    }"},
{"lineNum":" 4091","line":"}"},
{"lineNum":" 4092","line":""},
{"lineNum":" 4093","line":"pub const FStatAtError = FStatError || error{ NameTooLong, FileNotFound, SymLinkLoop };"},
{"lineNum":" 4094","line":""},
{"lineNum":" 4095","line":"/// Similar to `fstat`, but returns stat of a resource pointed to by `pathname`"},
{"lineNum":" 4096","line":"/// which is relative to `dirfd` handle."},
{"lineNum":" 4097","line":"/// See also `fstatatZ` and `fstatatWasi`."},
{"lineNum":" 4098","line":"pub fn fstatat(dirfd: fd_t, pathname: []const u8, flags: u32) FStatAtError!Stat {"},
{"lineNum":" 4099","line":"    if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 4100","line":"        const wasi_flags = if (flags & linux.AT.SYMLINK_NOFOLLOW == 0) wasi.LOOKUP_SYMLINK_FOLLOW else 0;"},
{"lineNum":" 4101","line":"        return fstatatWasi(dirfd, pathname, wasi_flags);"},
{"lineNum":" 4102","line":"    } else if (builtin.os.tag == .windows) {"},
{"lineNum":" 4103","line":"        @compileError(\"fstatat is not yet implemented on Windows\");"},
{"lineNum":" 4104","line":"    } else {"},
{"lineNum":" 4105","line":"        const pathname_c = try toPosixPath(pathname);"},
{"lineNum":" 4106","line":"        return fstatatZ(dirfd, &pathname_c, flags);"},
{"lineNum":" 4107","line":"    }"},
{"lineNum":" 4108","line":"}"},
{"lineNum":" 4109","line":""},
{"lineNum":" 4110","line":"/// WASI-only. Same as `fstatat` but targeting WASI."},
{"lineNum":" 4111","line":"/// See also `fstatat`."},
{"lineNum":" 4112","line":"pub fn fstatatWasi(dirfd: fd_t, pathname: []const u8, flags: u32) FStatAtError!Stat {"},
{"lineNum":" 4113","line":"    var stat: wasi.filestat_t = undefined;"},
{"lineNum":" 4114","line":"    switch (wasi.path_filestat_get(dirfd, flags, pathname.ptr, pathname.len, &stat)) {"},
{"lineNum":" 4115","line":"        .SUCCESS => return Stat.fromFilestat(stat),"},
{"lineNum":" 4116","line":"        .INVAL => unreachable,"},
{"lineNum":" 4117","line":"        .BADF => unreachable, // Always a race condition."},
{"lineNum":" 4118","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 4119","line":"        .ACCES => return error.AccessDenied,"},
{"lineNum":" 4120","line":"        .FAULT => unreachable,"},
{"lineNum":" 4121","line":"        .NAMETOOLONG => return error.NameTooLong,"},
{"lineNum":" 4122","line":"        .NOENT => return error.FileNotFound,"},
{"lineNum":" 4123","line":"        .NOTDIR => return error.FileNotFound,"},
{"lineNum":" 4124","line":"        .NOTCAPABLE => return error.AccessDenied,"},
{"lineNum":" 4125","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 4126","line":"    }"},
{"lineNum":" 4127","line":"}"},
{"lineNum":" 4128","line":""},
{"lineNum":" 4129","line":"/// Same as `fstatat` but `pathname` is null-terminated."},
{"lineNum":" 4130","line":"/// See also `fstatat`."},
{"lineNum":" 4131","line":"pub fn fstatatZ(dirfd: fd_t, pathname: [*:0]const u8, flags: u32) FStatAtError!Stat {"},
{"lineNum":" 4132","line":"    if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 4133","line":"        return fstatatWasi(dirfd, mem.sliceTo(pathname), flags);"},
{"lineNum":" 4134","line":"    }"},
{"lineNum":" 4135","line":""},
{"lineNum":" 4136","line":"    const fstatat_sym = if (lfs64_abi) system.fstatat64 else system.fstatat;"},
{"lineNum":" 4137","line":""},
{"lineNum":" 4138","line":"    var stat = mem.zeroes(Stat);"},
{"lineNum":" 4139","line":"    switch (errno(fstatat_sym(dirfd, pathname, &stat, flags))) {"},
{"lineNum":" 4140","line":"        .SUCCESS => return stat,"},
{"lineNum":" 4141","line":"        .INVAL => unreachable,"},
{"lineNum":" 4142","line":"        .BADF => unreachable, // Always a race condition."},
{"lineNum":" 4143","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 4144","line":"        .ACCES => return error.AccessDenied,"},
{"lineNum":" 4145","line":"        .PERM => return error.AccessDenied,"},
{"lineNum":" 4146","line":"        .FAULT => unreachable,"},
{"lineNum":" 4147","line":"        .NAMETOOLONG => return error.NameTooLong,"},
{"lineNum":" 4148","line":"        .LOOP => return error.SymLinkLoop,"},
{"lineNum":" 4149","line":"        .NOENT => return error.FileNotFound,"},
{"lineNum":" 4150","line":"        .NOTDIR => return error.FileNotFound,"},
{"lineNum":" 4151","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 4152","line":"    }"},
{"lineNum":" 4153","line":"}"},
{"lineNum":" 4154","line":""},
{"lineNum":" 4155","line":"pub const KQueueError = error{"},
{"lineNum":" 4156","line":"    /// The per-process limit on the number of open file descriptors has been reached."},
{"lineNum":" 4157","line":"    ProcessFdQuotaExceeded,"},
{"lineNum":" 4158","line":""},
{"lineNum":" 4159","line":"    /// The system-wide limit on the total number of open files has been reached."},
{"lineNum":" 4160","line":"    SystemFdQuotaExceeded,"},
{"lineNum":" 4161","line":"} || UnexpectedError;"},
{"lineNum":" 4162","line":""},
{"lineNum":" 4163","line":"pub fn kqueue() KQueueError!i32 {"},
{"lineNum":" 4164","line":"    const rc = system.kqueue();"},
{"lineNum":" 4165","line":"    switch (errno(rc)) {"},
{"lineNum":" 4166","line":"        .SUCCESS => return @as(i32, @intCast(rc)),"},
{"lineNum":" 4167","line":"        .MFILE => return error.ProcessFdQuotaExceeded,"},
{"lineNum":" 4168","line":"        .NFILE => return error.SystemFdQuotaExceeded,"},
{"lineNum":" 4169","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 4170","line":"    }"},
{"lineNum":" 4171","line":"}"},
{"lineNum":" 4172","line":""},
{"lineNum":" 4173","line":"pub const KEventError = error{"},
{"lineNum":" 4174","line":"    /// The process does not have permission to register a filter."},
{"lineNum":" 4175","line":"    AccessDenied,"},
{"lineNum":" 4176","line":""},
{"lineNum":" 4177","line":"    /// The event could not be found to be modified or deleted."},
{"lineNum":" 4178","line":"    EventNotFound,"},
{"lineNum":" 4179","line":""},
{"lineNum":" 4180","line":"    /// No memory was available to register the event."},
{"lineNum":" 4181","line":"    SystemResources,"},
{"lineNum":" 4182","line":""},
{"lineNum":" 4183","line":"    /// The specified process to attach to does not exist."},
{"lineNum":" 4184","line":"    ProcessNotFound,"},
{"lineNum":" 4185","line":""},
{"lineNum":" 4186","line":"    /// changelist or eventlist had too many items on it."},
{"lineNum":" 4187","line":"    /// TODO remove this possibility"},
{"lineNum":" 4188","line":"    Overflow,"},
{"lineNum":" 4189","line":"};"},
{"lineNum":" 4190","line":""},
{"lineNum":" 4191","line":"pub fn kevent("},
{"lineNum":" 4192","line":"    kq: i32,"},
{"lineNum":" 4193","line":"    changelist: []const Kevent,"},
{"lineNum":" 4194","line":"    eventlist: []Kevent,"},
{"lineNum":" 4195","line":"    timeout: ?*const timespec,"},
{"lineNum":" 4196","line":") KEventError!usize {"},
{"lineNum":" 4197","line":"    while (true) {"},
{"lineNum":" 4198","line":"        const rc = system.kevent("},
{"lineNum":" 4199","line":"            kq,"},
{"lineNum":" 4200","line":"            changelist.ptr,"},
{"lineNum":" 4201","line":"            math.cast(c_int, changelist.len) orelse return error.Overflow,"},
{"lineNum":" 4202","line":"            eventlist.ptr,"},
{"lineNum":" 4203","line":"            math.cast(c_int, eventlist.len) orelse return error.Overflow,"},
{"lineNum":" 4204","line":"            timeout,"},
{"lineNum":" 4205","line":"        );"},
{"lineNum":" 4206","line":"        switch (errno(rc)) {"},
{"lineNum":" 4207","line":"            .SUCCESS => return @as(usize, @intCast(rc)),"},
{"lineNum":" 4208","line":"            .ACCES => return error.AccessDenied,"},
{"lineNum":" 4209","line":"            .FAULT => unreachable,"},
{"lineNum":" 4210","line":"            .BADF => unreachable, // Always a race condition."},
{"lineNum":" 4211","line":"            .INTR => continue,"},
{"lineNum":" 4212","line":"            .INVAL => unreachable,"},
{"lineNum":" 4213","line":"            .NOENT => return error.EventNotFound,"},
{"lineNum":" 4214","line":"            .NOMEM => return error.SystemResources,"},
{"lineNum":" 4215","line":"            .SRCH => return error.ProcessNotFound,"},
{"lineNum":" 4216","line":"            else => unreachable,"},
{"lineNum":" 4217","line":"        }"},
{"lineNum":" 4218","line":"    }"},
{"lineNum":" 4219","line":"}"},
{"lineNum":" 4220","line":""},
{"lineNum":" 4221","line":"pub const INotifyInitError = error{"},
{"lineNum":" 4222","line":"    ProcessFdQuotaExceeded,"},
{"lineNum":" 4223","line":"    SystemFdQuotaExceeded,"},
{"lineNum":" 4224","line":"    SystemResources,"},
{"lineNum":" 4225","line":"} || UnexpectedError;"},
{"lineNum":" 4226","line":""},
{"lineNum":" 4227","line":"/// initialize an inotify instance"},
{"lineNum":" 4228","line":"pub fn inotify_init1(flags: u32) INotifyInitError!i32 {"},
{"lineNum":" 4229","line":"    const rc = system.inotify_init1(flags);"},
{"lineNum":" 4230","line":"    switch (errno(rc)) {"},
{"lineNum":" 4231","line":"        .SUCCESS => return @as(i32, @intCast(rc)),"},
{"lineNum":" 4232","line":"        .INVAL => unreachable,"},
{"lineNum":" 4233","line":"        .MFILE => return error.ProcessFdQuotaExceeded,"},
{"lineNum":" 4234","line":"        .NFILE => return error.SystemFdQuotaExceeded,"},
{"lineNum":" 4235","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 4236","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 4237","line":"    }"},
{"lineNum":" 4238","line":"}"},
{"lineNum":" 4239","line":""},
{"lineNum":" 4240","line":"pub const INotifyAddWatchError = error{"},
{"lineNum":" 4241","line":"    AccessDenied,"},
{"lineNum":" 4242","line":"    NameTooLong,"},
{"lineNum":" 4243","line":"    FileNotFound,"},
{"lineNum":" 4244","line":"    SystemResources,"},
{"lineNum":" 4245","line":"    UserResourceLimitReached,"},
{"lineNum":" 4246","line":"    NotDir,"},
{"lineNum":" 4247","line":"    WatchAlreadyExists,"},
{"lineNum":" 4248","line":"} || UnexpectedError;"},
{"lineNum":" 4249","line":""},
{"lineNum":" 4250","line":"/// add a watch to an initialized inotify instance"},
{"lineNum":" 4251","line":"pub fn inotify_add_watch(inotify_fd: i32, pathname: []const u8, mask: u32) INotifyAddWatchError!i32 {"},
{"lineNum":" 4252","line":"    const pathname_c = try toPosixPath(pathname);"},
{"lineNum":" 4253","line":"    return inotify_add_watchZ(inotify_fd, &pathname_c, mask);"},
{"lineNum":" 4254","line":"}"},
{"lineNum":" 4255","line":""},
{"lineNum":" 4256","line":"/// Same as `inotify_add_watch` except pathname is null-terminated."},
{"lineNum":" 4257","line":"pub fn inotify_add_watchZ(inotify_fd: i32, pathname: [*:0]const u8, mask: u32) INotifyAddWatchError!i32 {"},
{"lineNum":" 4258","line":"    const rc = system.inotify_add_watch(inotify_fd, pathname, mask);"},
{"lineNum":" 4259","line":"    switch (errno(rc)) {"},
{"lineNum":" 4260","line":"        .SUCCESS => return @as(i32, @intCast(rc)),"},
{"lineNum":" 4261","line":"        .ACCES => return error.AccessDenied,"},
{"lineNum":" 4262","line":"        .BADF => unreachable,"},
{"lineNum":" 4263","line":"        .FAULT => unreachable,"},
{"lineNum":" 4264","line":"        .INVAL => unreachable,"},
{"lineNum":" 4265","line":"        .NAMETOOLONG => return error.NameTooLong,"},
{"lineNum":" 4266","line":"        .NOENT => return error.FileNotFound,"},
{"lineNum":" 4267","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 4268","line":"        .NOSPC => return error.UserResourceLimitReached,"},
{"lineNum":" 4269","line":"        .NOTDIR => return error.NotDir,"},
{"lineNum":" 4270","line":"        .EXIST => return error.WatchAlreadyExists,"},
{"lineNum":" 4271","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 4272","line":"    }"},
{"lineNum":" 4273","line":"}"},
{"lineNum":" 4274","line":""},
{"lineNum":" 4275","line":"/// remove an existing watch from an inotify instance"},
{"lineNum":" 4276","line":"pub fn inotify_rm_watch(inotify_fd: i32, wd: i32) void {"},
{"lineNum":" 4277","line":"    switch (errno(system.inotify_rm_watch(inotify_fd, wd))) {"},
{"lineNum":" 4278","line":"        .SUCCESS => return,"},
{"lineNum":" 4279","line":"        .BADF => unreachable,"},
{"lineNum":" 4280","line":"        .INVAL => unreachable,"},
{"lineNum":" 4281","line":"        else => unreachable,"},
{"lineNum":" 4282","line":"    }"},
{"lineNum":" 4283","line":"}"},
{"lineNum":" 4284","line":""},
{"lineNum":" 4285","line":"pub const MProtectError = error{"},
{"lineNum":" 4286","line":"    /// The memory cannot be given the specified access.  This can happen, for example, if you"},
{"lineNum":" 4287","line":"    /// mmap(2)  a  file  to  which  you have read-only access, then ask mprotect() to mark it"},
{"lineNum":" 4288","line":"    /// PROT_WRITE."},
{"lineNum":" 4289","line":"    AccessDenied,"},
{"lineNum":" 4290","line":""},
{"lineNum":" 4291","line":"    /// Changing  the  protection  of a memory region would result in the total number of map"},
{"lineNum":" 4292","line":"    /// pings with distinct attributes (e.g., read versus read/write protection) exceeding the"},
{"lineNum":" 4293","line":"    /// allowed maximum.  (For example, making the protection of a range PROT_READ in the mid"},
{"lineNum":" 4294","line":"    /// dle of a region currently protected as PROT_READ|PROT_WRITE would result in three map"},
{"lineNum":" 4295","line":"    /// pings: two read/write mappings at each end and a read-only mapping in the middle.)"},
{"lineNum":" 4296","line":"    OutOfMemory,"},
{"lineNum":" 4297","line":"} || UnexpectedError;"},
{"lineNum":" 4298","line":""},
{"lineNum":" 4299","line":"/// `memory.len` must be page-aligned."},
{"lineNum":" 4300","line":"pub fn mprotect(memory: []align(mem.page_size) u8, protection: u32) MProtectError!void {"},
{"lineNum":" 4301","line":"    assert(mem.isAligned(memory.len, mem.page_size));"},
{"lineNum":" 4302","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 4303","line":"        const win_prot: windows.DWORD = switch (@as(u3, @truncate(protection))) {"},
{"lineNum":" 4304","line":"            0b000 => windows.PAGE_NOACCESS,"},
{"lineNum":" 4305","line":"            0b001 => windows.PAGE_READONLY,"},
{"lineNum":" 4306","line":"            0b010 => unreachable, // +w -r not allowed"},
{"lineNum":" 4307","line":"            0b011 => windows.PAGE_READWRITE,"},
{"lineNum":" 4308","line":"            0b100 => windows.PAGE_EXECUTE,"},
{"lineNum":" 4309","line":"            0b101 => windows.PAGE_EXECUTE_READ,"},
{"lineNum":" 4310","line":"            0b110 => unreachable, // +w -r not allowed"},
{"lineNum":" 4311","line":"            0b111 => windows.PAGE_EXECUTE_READWRITE,"},
{"lineNum":" 4312","line":"        };"},
{"lineNum":" 4313","line":"        var old: windows.DWORD = undefined;"},
{"lineNum":" 4314","line":"        windows.VirtualProtect(memory.ptr, memory.len, win_prot, &old) catch |err| switch (err) {"},
{"lineNum":" 4315","line":"            error.InvalidAddress => return error.AccessDenied,"},
{"lineNum":" 4316","line":"            error.Unexpected => return error.Unexpected,"},
{"lineNum":" 4317","line":"        };"},
{"lineNum":" 4318","line":"    } else {"},
{"lineNum":" 4319","line":"        switch (errno(system.mprotect(memory.ptr, memory.len, protection))) {"},
{"lineNum":" 4320","line":"            .SUCCESS => return,"},
{"lineNum":" 4321","line":"            .INVAL => unreachable,"},
{"lineNum":" 4322","line":"            .ACCES => return error.AccessDenied,"},
{"lineNum":" 4323","line":"            .NOMEM => return error.OutOfMemory,"},
{"lineNum":" 4324","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 4325","line":"        }"},
{"lineNum":" 4326","line":"    }"},
{"lineNum":" 4327","line":"}"},
{"lineNum":" 4328","line":""},
{"lineNum":" 4329","line":"pub const ForkError = error{SystemResources} || UnexpectedError;"},
{"lineNum":" 4330","line":""},
{"lineNum":" 4331","line":"pub fn fork() ForkError!pid_t {"},
{"lineNum":" 4332","line":"    const rc = system.fork();"},
{"lineNum":" 4333","line":"    switch (errno(rc)) {"},
{"lineNum":" 4334","line":"        .SUCCESS => return @as(pid_t, @intCast(rc)),"},
{"lineNum":" 4335","line":"        .AGAIN => return error.SystemResources,"},
{"lineNum":" 4336","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 4337","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 4338","line":"    }"},
{"lineNum":" 4339","line":"}"},
{"lineNum":" 4340","line":""},
{"lineNum":" 4341","line":"pub const MMapError = error{"},
{"lineNum":" 4342","line":"    /// The underlying filesystem of the specified file does not support memory mapping."},
{"lineNum":" 4343","line":"    MemoryMappingNotSupported,"},
{"lineNum":" 4344","line":""},
{"lineNum":" 4345","line":"    /// A file descriptor refers to a non-regular file. Or a file mapping was requested,"},
{"lineNum":" 4346","line":"    /// but the file descriptor is not open for reading. Or `MAP.SHARED` was requested"},
{"lineNum":" 4347","line":"    /// and `PROT_WRITE` is set, but the file descriptor is not open in `O.RDWR` mode."},
{"lineNum":" 4348","line":"    /// Or `PROT_WRITE` is set, but the file is append-only."},
{"lineNum":" 4349","line":"    AccessDenied,"},
{"lineNum":" 4350","line":""},
{"lineNum":" 4351","line":"    /// The `prot` argument asks for `PROT_EXEC` but the mapped area belongs to a file on"},
{"lineNum":" 4352","line":"    /// a filesystem that was mounted no-exec."},
{"lineNum":" 4353","line":"    PermissionDenied,"},
{"lineNum":" 4354","line":"    LockedMemoryLimitExceeded,"},
{"lineNum":" 4355","line":"    ProcessFdQuotaExceeded,"},
{"lineNum":" 4356","line":"    SystemFdQuotaExceeded,"},
{"lineNum":" 4357","line":"    OutOfMemory,"},
{"lineNum":" 4358","line":"} || UnexpectedError;"},
{"lineNum":" 4359","line":""},
{"lineNum":" 4360","line":"/// Map files or devices into memory."},
{"lineNum":" 4361","line":"/// `length` does not need to be aligned."},
{"lineNum":" 4362","line":"/// Use of a mapped region can result in these signals:"},
{"lineNum":" 4363","line":"/// * SIGSEGV - Attempted write into a region mapped as read-only."},
{"lineNum":" 4364","line":"/// * SIGBUS - Attempted  access to a portion of the buffer that does not correspond to the file"},
{"lineNum":" 4365","line":"pub fn mmap("},
{"lineNum":" 4366","line":"    ptr: ?[*]align(mem.page_size) u8,"},
{"lineNum":" 4367","line":"    length: usize,"},
{"lineNum":" 4368","line":"    prot: u32,"},
{"lineNum":" 4369","line":"    flags: u32,"},
{"lineNum":" 4370","line":"    fd: fd_t,"},
{"lineNum":" 4371","line":"    offset: u64,"},
{"lineNum":" 4372","line":") MMapError![]align(mem.page_size) u8 {","class":"lineCov","hits":"1","order":"758","possible_hits":"1",},
{"lineNum":" 4373","line":"    const mmap_sym = if (lfs64_abi) system.mmap64 else system.mmap;"},
{"lineNum":" 4374","line":""},
{"lineNum":" 4375","line":"    const ioffset = @as(i64, @bitCast(offset)); // the OS treats this as unsigned","class":"lineCov","hits":"1","order":"759","possible_hits":"1",},
{"lineNum":" 4376","line":"    const rc = mmap_sym(ptr, length, prot, flags, fd, ioffset);","class":"lineCov","hits":"1","order":"760","possible_hits":"1",},
{"lineNum":" 4377","line":"    const err = if (builtin.link_libc) blk: {"},
{"lineNum":" 4378","line":"        if (rc != std.c.MAP.FAILED) return @as([*]align(mem.page_size) u8, @ptrCast(@alignCast(rc)))[0..length];"},
{"lineNum":" 4379","line":"        break :blk @as(E, @enumFromInt(system._errno().*));"},
{"lineNum":" 4380","line":"    } else blk: {"},
{"lineNum":" 4381","line":"        const err = errno(rc);","class":"lineCov","hits":"1","order":"766","possible_hits":"1",},
{"lineNum":" 4382","line":"        if (err == .SUCCESS) return @as([*]align(mem.page_size) u8, @ptrFromInt(rc))[0..length];","class":"lineCov","hits":"2","order":"767","possible_hits":"2",},
{"lineNum":" 4383","line":"        break :blk err;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 4384","line":"    };"},
{"lineNum":" 4385","line":"    switch (err) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 4386","line":"        .SUCCESS => unreachable,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 4387","line":"        .TXTBSY => return error.AccessDenied,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 4388","line":"        .ACCES => return error.AccessDenied,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 4389","line":"        .PERM => return error.PermissionDenied,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 4390","line":"        .AGAIN => return error.LockedMemoryLimitExceeded,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 4391","line":"        .BADF => unreachable, // Always a race condition.","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 4392","line":"        .OVERFLOW => unreachable, // The number of pages used for length + offset would overflow.","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 4393","line":"        .NODEV => return error.MemoryMappingNotSupported,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 4394","line":"        .INVAL => unreachable, // Invalid parameters to mmap()","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 4395","line":"        .MFILE => return error.ProcessFdQuotaExceeded,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 4396","line":"        .NFILE => return error.SystemFdQuotaExceeded,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 4397","line":"        .NOMEM => return error.OutOfMemory,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 4398","line":"        else => return unexpectedErrno(err),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 4399","line":"    }"},
{"lineNum":" 4400","line":"}"},
{"lineNum":" 4401","line":""},
{"lineNum":" 4402","line":"/// Deletes the mappings for the specified address range, causing"},
{"lineNum":" 4403","line":"/// further references to addresses within the range to generate invalid memory references."},
{"lineNum":" 4404","line":"/// Note that while POSIX allows unmapping a region in the middle of an existing mapping,"},
{"lineNum":" 4405","line":"/// Zig\'s munmap function does not, for two reasons:"},
{"lineNum":" 4406","line":"/// * It violates the Zig principle that resource deallocation must succeed."},
{"lineNum":" 4407","line":"/// * The Windows function, VirtualFree, has this restriction."},
{"lineNum":" 4408","line":"pub fn munmap(memory: []align(mem.page_size) const u8) void {","class":"lineCov","hits":"1","order":"1502","possible_hits":"1",},
{"lineNum":" 4409","line":"    switch (errno(system.munmap(memory.ptr, memory.len))) {","class":"lineCov","hits":"1","order":"1503","possible_hits":"1",},
{"lineNum":" 4410","line":"        .SUCCESS => return,","class":"lineCov","hits":"1","order":"1506","possible_hits":"1",},
{"lineNum":" 4411","line":"        .INVAL => unreachable, // Invalid parameters.","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 4412","line":"        .NOMEM => unreachable, // Attempted to unmap a region in the middle of an existing mapping.","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 4413","line":"        else => unreachable,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 4414","line":"    }"},
{"lineNum":" 4415","line":"}"},
{"lineNum":" 4416","line":""},
{"lineNum":" 4417","line":"pub const MSyncError = error{"},
{"lineNum":" 4418","line":"    UnmappedMemory,"},
{"lineNum":" 4419","line":"} || UnexpectedError;"},
{"lineNum":" 4420","line":""},
{"lineNum":" 4421","line":"pub fn msync(memory: []align(mem.page_size) u8, flags: i32) MSyncError!void {","class":"lineCov","hits":"1","order":"3030","possible_hits":"1",},
{"lineNum":" 4422","line":"    switch (errno(system.msync(memory.ptr, memory.len, flags))) {","class":"lineCov","hits":"1","order":"3031","possible_hits":"1",},
{"lineNum":" 4423","line":"        .SUCCESS => return,","class":"lineCov","hits":"1","order":"3034","possible_hits":"1",},
{"lineNum":" 4424","line":"        .NOMEM => return error.UnmappedMemory, // Unsuccessful, provided pointer does not point mapped memory","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 4425","line":"        .INVAL => unreachable, // Invalid parameters.","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 4426","line":"        else => unreachable,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 4427","line":"    }"},
{"lineNum":" 4428","line":"}"},
{"lineNum":" 4429","line":""},
{"lineNum":" 4430","line":"pub const AccessError = error{"},
{"lineNum":" 4431","line":"    PermissionDenied,"},
{"lineNum":" 4432","line":"    FileNotFound,"},
{"lineNum":" 4433","line":"    NameTooLong,"},
{"lineNum":" 4434","line":"    InputOutput,"},
{"lineNum":" 4435","line":"    SystemResources,"},
{"lineNum":" 4436","line":"    BadPathName,"},
{"lineNum":" 4437","line":"    FileBusy,"},
{"lineNum":" 4438","line":"    SymLinkLoop,"},
{"lineNum":" 4439","line":"    ReadOnlyFileSystem,"},
{"lineNum":" 4440","line":""},
{"lineNum":" 4441","line":"    /// On Windows, file paths must be valid Unicode."},
{"lineNum":" 4442","line":"    InvalidUtf8,"},
{"lineNum":" 4443","line":"} || UnexpectedError;"},
{"lineNum":" 4444","line":""},
{"lineNum":" 4445","line":"/// check user\'s permissions for a file"},
{"lineNum":" 4446","line":"/// TODO currently this assumes `mode` is `F.OK` on Windows."},
{"lineNum":" 4447","line":"pub fn access(path: []const u8, mode: u32) AccessError!void {"},
{"lineNum":" 4448","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 4449","line":"        const path_w = try windows.sliceToPrefixedFileW(path);"},
{"lineNum":" 4450","line":"        _ = try windows.GetFileAttributesW(path_w.span().ptr);"},
{"lineNum":" 4451","line":"        return;"},
{"lineNum":" 4452","line":"    } else if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 4453","line":"        return faccessat(wasi.AT.FDCWD, path, mode, 0);"},
{"lineNum":" 4454","line":"    }"},
{"lineNum":" 4455","line":"    const path_c = try toPosixPath(path);"},
{"lineNum":" 4456","line":"    return accessZ(&path_c, mode);"},
{"lineNum":" 4457","line":"}"},
{"lineNum":" 4458","line":""},
{"lineNum":" 4459","line":"/// Same as `access` except `path` is null-terminated."},
{"lineNum":" 4460","line":"pub fn accessZ(path: [*:0]const u8, mode: u32) AccessError!void {"},
{"lineNum":" 4461","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 4462","line":"        const path_w = try windows.cStrToPrefixedFileW(path);"},
{"lineNum":" 4463","line":"        _ = try windows.GetFileAttributesW(path_w.span().ptr);"},
{"lineNum":" 4464","line":"        return;"},
{"lineNum":" 4465","line":"    } else if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 4466","line":"        return access(mem.sliceTo(path, 0), mode);"},
{"lineNum":" 4467","line":"    }"},
{"lineNum":" 4468","line":"    switch (errno(system.access(path, mode))) {"},
{"lineNum":" 4469","line":"        .SUCCESS => return,"},
{"lineNum":" 4470","line":"        .ACCES => return error.PermissionDenied,"},
{"lineNum":" 4471","line":"        .ROFS => return error.ReadOnlyFileSystem,"},
{"lineNum":" 4472","line":"        .LOOP => return error.SymLinkLoop,"},
{"lineNum":" 4473","line":"        .TXTBSY => return error.FileBusy,"},
{"lineNum":" 4474","line":"        .NOTDIR => return error.FileNotFound,"},
{"lineNum":" 4475","line":"        .NOENT => return error.FileNotFound,"},
{"lineNum":" 4476","line":"        .NAMETOOLONG => return error.NameTooLong,"},
{"lineNum":" 4477","line":"        .INVAL => unreachable,"},
{"lineNum":" 4478","line":"        .FAULT => unreachable,"},
{"lineNum":" 4479","line":"        .IO => return error.InputOutput,"},
{"lineNum":" 4480","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 4481","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 4482","line":"    }"},
{"lineNum":" 4483","line":"}"},
{"lineNum":" 4484","line":""},
{"lineNum":" 4485","line":"/// Call from Windows-specific code if you already have a UTF-16LE encoded, null terminated string."},
{"lineNum":" 4486","line":"/// Otherwise use `access` or `accessC`."},
{"lineNum":" 4487","line":"/// TODO currently this ignores `mode`."},
{"lineNum":" 4488","line":"pub fn accessW(path: [*:0]const u16, mode: u32) windows.GetFileAttributesError!void {"},
{"lineNum":" 4489","line":"    _ = mode;"},
{"lineNum":" 4490","line":"    const ret = try windows.GetFileAttributesW(path);"},
{"lineNum":" 4491","line":"    if (ret != windows.INVALID_FILE_ATTRIBUTES) {"},
{"lineNum":" 4492","line":"        return;"},
{"lineNum":" 4493","line":"    }"},
{"lineNum":" 4494","line":"    switch (windows.kernel32.GetLastError()) {"},
{"lineNum":" 4495","line":"        .FILE_NOT_FOUND => return error.FileNotFound,"},
{"lineNum":" 4496","line":"        .PATH_NOT_FOUND => return error.FileNotFound,"},
{"lineNum":" 4497","line":"        .ACCESS_DENIED => return error.PermissionDenied,"},
{"lineNum":" 4498","line":"        else => |err| return windows.unexpectedError(err),"},
{"lineNum":" 4499","line":"    }"},
{"lineNum":" 4500","line":"}"},
{"lineNum":" 4501","line":""},
{"lineNum":" 4502","line":"/// Check user\'s permissions for a file, based on an open directory handle."},
{"lineNum":" 4503","line":"/// TODO currently this ignores `mode` and `flags` on Windows."},
{"lineNum":" 4504","line":"pub fn faccessat(dirfd: fd_t, path: []const u8, mode: u32, flags: u32) AccessError!void {"},
{"lineNum":" 4505","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 4506","line":"        const path_w = try windows.sliceToPrefixedFileW(path);"},
{"lineNum":" 4507","line":"        return faccessatW(dirfd, path_w.span().ptr, mode, flags);"},
{"lineNum":" 4508","line":"    } else if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 4509","line":"        var resolved = RelativePathWasi{ .dir_fd = dirfd, .relative_path = path };"},
{"lineNum":" 4510","line":""},
{"lineNum":" 4511","line":"        const file = blk: {"},
{"lineNum":" 4512","line":"            break :blk fstatat(dirfd, path, flags);"},
{"lineNum":" 4513","line":"        } catch |err| switch (err) {"},
{"lineNum":" 4514","line":"            error.AccessDenied => return error.PermissionDenied,"},
{"lineNum":" 4515","line":"            else => |e| return e,"},
{"lineNum":" 4516","line":"        };"},
{"lineNum":" 4517","line":""},
{"lineNum":" 4518","line":"        if (mode != F_OK) {"},
{"lineNum":" 4519","line":"            var directory: wasi.fdstat_t = undefined;"},
{"lineNum":" 4520","line":"            if (wasi.fd_fdstat_get(resolved.dir_fd, &directory) != .SUCCESS) {"},
{"lineNum":" 4521","line":"                return error.PermissionDenied;"},
{"lineNum":" 4522","line":"            }"},
{"lineNum":" 4523","line":""},
{"lineNum":" 4524","line":"            var rights: wasi.rights_t = 0;"},
{"lineNum":" 4525","line":"            if (mode & R_OK != 0) {"},
{"lineNum":" 4526","line":"                rights |= if (file.filetype == .DIRECTORY)"},
{"lineNum":" 4527","line":"                    wasi.RIGHT.FD_READDIR"},
{"lineNum":" 4528","line":"                else"},
{"lineNum":" 4529","line":"                    wasi.RIGHT.FD_READ;"},
{"lineNum":" 4530","line":"            }"},
{"lineNum":" 4531","line":"            if (mode & W_OK != 0) {"},
{"lineNum":" 4532","line":"                rights |= wasi.RIGHT.FD_WRITE;"},
{"lineNum":" 4533","line":"            }"},
{"lineNum":" 4534","line":"            // No validation for X_OK"},
{"lineNum":" 4535","line":""},
{"lineNum":" 4536","line":"            if ((rights & directory.fs_rights_inheriting) != rights) {"},
{"lineNum":" 4537","line":"                return error.PermissionDenied;"},
{"lineNum":" 4538","line":"            }"},
{"lineNum":" 4539","line":"        }"},
{"lineNum":" 4540","line":"        return;"},
{"lineNum":" 4541","line":"    }"},
{"lineNum":" 4542","line":"    const path_c = try toPosixPath(path);"},
{"lineNum":" 4543","line":"    return faccessatZ(dirfd, &path_c, mode, flags);"},
{"lineNum":" 4544","line":"}"},
{"lineNum":" 4545","line":""},
{"lineNum":" 4546","line":"/// Same as `faccessat` except the path parameter is null-terminated."},
{"lineNum":" 4547","line":"pub fn faccessatZ(dirfd: fd_t, path: [*:0]const u8, mode: u32, flags: u32) AccessError!void {"},
{"lineNum":" 4548","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 4549","line":"        const path_w = try windows.cStrToPrefixedFileW(path);"},
{"lineNum":" 4550","line":"        return faccessatW(dirfd, path_w.span().ptr, mode, flags);"},
{"lineNum":" 4551","line":"    } else if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 4552","line":"        return faccessat(dirfd, mem.sliceTo(path, 0), mode, flags);"},
{"lineNum":" 4553","line":"    }"},
{"lineNum":" 4554","line":"    switch (errno(system.faccessat(dirfd, path, mode, flags))) {"},
{"lineNum":" 4555","line":"        .SUCCESS => return,"},
{"lineNum":" 4556","line":"        .ACCES => return error.PermissionDenied,"},
{"lineNum":" 4557","line":"        .ROFS => return error.ReadOnlyFileSystem,"},
{"lineNum":" 4558","line":"        .LOOP => return error.SymLinkLoop,"},
{"lineNum":" 4559","line":"        .TXTBSY => return error.FileBusy,"},
{"lineNum":" 4560","line":"        .NOTDIR => return error.FileNotFound,"},
{"lineNum":" 4561","line":"        .NOENT => return error.FileNotFound,"},
{"lineNum":" 4562","line":"        .NAMETOOLONG => return error.NameTooLong,"},
{"lineNum":" 4563","line":"        .INVAL => unreachable,"},
{"lineNum":" 4564","line":"        .FAULT => unreachable,"},
{"lineNum":" 4565","line":"        .IO => return error.InputOutput,"},
{"lineNum":" 4566","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 4567","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 4568","line":"    }"},
{"lineNum":" 4569","line":"}"},
{"lineNum":" 4570","line":""},
{"lineNum":" 4571","line":"/// Same as `faccessat` except asserts the target is Windows and the path parameter"},
{"lineNum":" 4572","line":"/// is NtDll-prefixed, null-terminated, WTF-16 encoded."},
{"lineNum":" 4573","line":"/// TODO currently this ignores `mode` and `flags`"},
{"lineNum":" 4574","line":"pub fn faccessatW(dirfd: fd_t, sub_path_w: [*:0]const u16, mode: u32, flags: u32) AccessError!void {"},
{"lineNum":" 4575","line":"    _ = mode;"},
{"lineNum":" 4576","line":"    _ = flags;"},
{"lineNum":" 4577","line":"    if (sub_path_w[0] == \'.\' and sub_path_w[1] == 0) {"},
{"lineNum":" 4578","line":"        return;"},
{"lineNum":" 4579","line":"    }"},
{"lineNum":" 4580","line":"    if (sub_path_w[0] == \'.\' and sub_path_w[1] == \'.\' and sub_path_w[2] == 0) {"},
{"lineNum":" 4581","line":"        return;"},
{"lineNum":" 4582","line":"    }"},
{"lineNum":" 4583","line":""},
{"lineNum":" 4584","line":"    const path_len_bytes = math.cast(u16, mem.sliceTo(sub_path_w, 0).len * 2) orelse return error.NameTooLong;"},
{"lineNum":" 4585","line":"    var nt_name = windows.UNICODE_STRING{"},
{"lineNum":" 4586","line":"        .Length = path_len_bytes,"},
{"lineNum":" 4587","line":"        .MaximumLength = path_len_bytes,"},
{"lineNum":" 4588","line":"        .Buffer = @constCast(sub_path_w),"},
{"lineNum":" 4589","line":"    };"},
{"lineNum":" 4590","line":"    var attr = windows.OBJECT_ATTRIBUTES{"},
{"lineNum":" 4591","line":"        .Length = @sizeOf(windows.OBJECT_ATTRIBUTES),"},
{"lineNum":" 4592","line":"        .RootDirectory = if (std.fs.path.isAbsoluteWindowsW(sub_path_w)) null else dirfd,"},
{"lineNum":" 4593","line":"        .Attributes = 0, // Note we do not use OBJ_CASE_INSENSITIVE here."},
{"lineNum":" 4594","line":"        .ObjectName = &nt_name,"},
{"lineNum":" 4595","line":"        .SecurityDescriptor = null,"},
{"lineNum":" 4596","line":"        .SecurityQualityOfService = null,"},
{"lineNum":" 4597","line":"    };"},
{"lineNum":" 4598","line":"    var basic_info: windows.FILE_BASIC_INFORMATION = undefined;"},
{"lineNum":" 4599","line":"    switch (windows.ntdll.NtQueryAttributesFile(&attr, &basic_info)) {"},
{"lineNum":" 4600","line":"        .SUCCESS => return,"},
{"lineNum":" 4601","line":"        .OBJECT_NAME_NOT_FOUND => return error.FileNotFound,"},
{"lineNum":" 4602","line":"        .OBJECT_PATH_NOT_FOUND => return error.FileNotFound,"},
{"lineNum":" 4603","line":"        .OBJECT_NAME_INVALID => unreachable,"},
{"lineNum":" 4604","line":"        .INVALID_PARAMETER => unreachable,"},
{"lineNum":" 4605","line":"        .ACCESS_DENIED => return error.PermissionDenied,"},
{"lineNum":" 4606","line":"        .OBJECT_PATH_SYNTAX_BAD => unreachable,"},
{"lineNum":" 4607","line":"        else => |rc| return windows.unexpectedStatus(rc),"},
{"lineNum":" 4608","line":"    }"},
{"lineNum":" 4609","line":"}"},
{"lineNum":" 4610","line":""},
{"lineNum":" 4611","line":"pub const PipeError = error{"},
{"lineNum":" 4612","line":"    SystemFdQuotaExceeded,"},
{"lineNum":" 4613","line":"    ProcessFdQuotaExceeded,"},
{"lineNum":" 4614","line":"} || UnexpectedError;"},
{"lineNum":" 4615","line":""},
{"lineNum":" 4616","line":"/// Creates a unidirectional data channel that can be used for interprocess communication."},
{"lineNum":" 4617","line":"pub fn pipe() PipeError![2]fd_t {"},
{"lineNum":" 4618","line":"    var fds: [2]fd_t = undefined;"},
{"lineNum":" 4619","line":"    switch (errno(system.pipe(&fds))) {"},
{"lineNum":" 4620","line":"        .SUCCESS => return fds,"},
{"lineNum":" 4621","line":"        .INVAL => unreachable, // Invalid parameters to pipe()"},
{"lineNum":" 4622","line":"        .FAULT => unreachable, // Invalid fds pointer"},
{"lineNum":" 4623","line":"        .NFILE => return error.SystemFdQuotaExceeded,"},
{"lineNum":" 4624","line":"        .MFILE => return error.ProcessFdQuotaExceeded,"},
{"lineNum":" 4625","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 4626","line":"    }"},
{"lineNum":" 4627","line":"}"},
{"lineNum":" 4628","line":""},
{"lineNum":" 4629","line":"pub fn pipe2(flags: u32) PipeError![2]fd_t {"},
{"lineNum":" 4630","line":"    if (@hasDecl(system, \"pipe2\")) {"},
{"lineNum":" 4631","line":"        var fds: [2]fd_t = undefined;"},
{"lineNum":" 4632","line":"        switch (errno(system.pipe2(&fds, flags))) {"},
{"lineNum":" 4633","line":"            .SUCCESS => return fds,"},
{"lineNum":" 4634","line":"            .INVAL => unreachable, // Invalid flags"},
{"lineNum":" 4635","line":"            .FAULT => unreachable, // Invalid fds pointer"},
{"lineNum":" 4636","line":"            .NFILE => return error.SystemFdQuotaExceeded,"},
{"lineNum":" 4637","line":"            .MFILE => return error.ProcessFdQuotaExceeded,"},
{"lineNum":" 4638","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 4639","line":"        }"},
{"lineNum":" 4640","line":"    }"},
{"lineNum":" 4641","line":""},
{"lineNum":" 4642","line":"    var fds: [2]fd_t = try pipe();"},
{"lineNum":" 4643","line":"    errdefer {"},
{"lineNum":" 4644","line":"        close(fds[0]);"},
{"lineNum":" 4645","line":"        close(fds[1]);"},
{"lineNum":" 4646","line":"    }"},
{"lineNum":" 4647","line":""},
{"lineNum":" 4648","line":"    if (flags == 0)"},
{"lineNum":" 4649","line":"        return fds;"},
{"lineNum":" 4650","line":""},
{"lineNum":" 4651","line":"    // O.CLOEXEC is special, it\'s a file descriptor flag and must be set using"},
{"lineNum":" 4652","line":"    // F.SETFD."},
{"lineNum":" 4653","line":"    if (flags & O.CLOEXEC != 0) {"},
{"lineNum":" 4654","line":"        for (fds) |fd| {"},
{"lineNum":" 4655","line":"            switch (errno(system.fcntl(fd, F.SETFD, @as(u32, FD_CLOEXEC)))) {"},
{"lineNum":" 4656","line":"                .SUCCESS => {},"},
{"lineNum":" 4657","line":"                .INVAL => unreachable, // Invalid flags"},
{"lineNum":" 4658","line":"                .BADF => unreachable, // Always a race condition"},
{"lineNum":" 4659","line":"                else => |err| return unexpectedErrno(err),"},
{"lineNum":" 4660","line":"            }"},
{"lineNum":" 4661","line":"        }"},
{"lineNum":" 4662","line":"    }"},
{"lineNum":" 4663","line":""},
{"lineNum":" 4664","line":"    const new_flags = flags & ~@as(u32, O.CLOEXEC);"},
{"lineNum":" 4665","line":"    // Set every other flag affecting the file status using F.SETFL."},
{"lineNum":" 4666","line":"    if (new_flags != 0) {"},
{"lineNum":" 4667","line":"        for (fds) |fd| {"},
{"lineNum":" 4668","line":"            switch (errno(system.fcntl(fd, F.SETFL, new_flags))) {"},
{"lineNum":" 4669","line":"                .SUCCESS => {},"},
{"lineNum":" 4670","line":"                .INVAL => unreachable, // Invalid flags"},
{"lineNum":" 4671","line":"                .BADF => unreachable, // Always a race condition"},
{"lineNum":" 4672","line":"                else => |err| return unexpectedErrno(err),"},
{"lineNum":" 4673","line":"            }"},
{"lineNum":" 4674","line":"        }"},
{"lineNum":" 4675","line":"    }"},
{"lineNum":" 4676","line":""},
{"lineNum":" 4677","line":"    return fds;"},
{"lineNum":" 4678","line":"}"},
{"lineNum":" 4679","line":""},
{"lineNum":" 4680","line":"pub const SysCtlError = error{"},
{"lineNum":" 4681","line":"    PermissionDenied,"},
{"lineNum":" 4682","line":"    SystemResources,"},
{"lineNum":" 4683","line":"    NameTooLong,"},
{"lineNum":" 4684","line":"    UnknownName,"},
{"lineNum":" 4685","line":"} || UnexpectedError;"},
{"lineNum":" 4686","line":""},
{"lineNum":" 4687","line":"pub fn sysctl("},
{"lineNum":" 4688","line":"    name: []const c_int,"},
{"lineNum":" 4689","line":"    oldp: ?*anyopaque,"},
{"lineNum":" 4690","line":"    oldlenp: ?*usize,"},
{"lineNum":" 4691","line":"    newp: ?*anyopaque,"},
{"lineNum":" 4692","line":"    newlen: usize,"},
{"lineNum":" 4693","line":") SysCtlError!void {"},
{"lineNum":" 4694","line":"    if (builtin.os.tag == .wasi) {"},
{"lineNum":" 4695","line":"        @panic(\"unsupported\"); // TODO should be compile error, not panic"},
{"lineNum":" 4696","line":"    }"},
{"lineNum":" 4697","line":"    if (builtin.os.tag == .haiku) {"},
{"lineNum":" 4698","line":"        @panic(\"unsupported\"); // TODO should be compile error, not panic"},
{"lineNum":" 4699","line":"    }"},
{"lineNum":" 4700","line":""},
{"lineNum":" 4701","line":"    const name_len = math.cast(c_uint, name.len) orelse return error.NameTooLong;"},
{"lineNum":" 4702","line":"    switch (errno(system.sysctl(name.ptr, name_len, oldp, oldlenp, newp, newlen))) {"},
{"lineNum":" 4703","line":"        .SUCCESS => return,"},
{"lineNum":" 4704","line":"        .FAULT => unreachable,"},
{"lineNum":" 4705","line":"        .PERM => return error.PermissionDenied,"},
{"lineNum":" 4706","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 4707","line":"        .NOENT => return error.UnknownName,"},
{"lineNum":" 4708","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 4709","line":"    }"},
{"lineNum":" 4710","line":"}"},
{"lineNum":" 4711","line":""},
{"lineNum":" 4712","line":"pub fn sysctlbynameZ("},
{"lineNum":" 4713","line":"    name: [*:0]const u8,"},
{"lineNum":" 4714","line":"    oldp: ?*anyopaque,"},
{"lineNum":" 4715","line":"    oldlenp: ?*usize,"},
{"lineNum":" 4716","line":"    newp: ?*anyopaque,"},
{"lineNum":" 4717","line":"    newlen: usize,"},
{"lineNum":" 4718","line":") SysCtlError!void {"},
{"lineNum":" 4719","line":"    if (builtin.os.tag == .wasi) {"},
{"lineNum":" 4720","line":"        @panic(\"unsupported\"); // TODO should be compile error, not panic"},
{"lineNum":" 4721","line":"    }"},
{"lineNum":" 4722","line":"    if (builtin.os.tag == .haiku) {"},
{"lineNum":" 4723","line":"        @panic(\"unsupported\"); // TODO should be compile error, not panic"},
{"lineNum":" 4724","line":"    }"},
{"lineNum":" 4725","line":""},
{"lineNum":" 4726","line":"    switch (errno(system.sysctlbyname(name, oldp, oldlenp, newp, newlen))) {"},
{"lineNum":" 4727","line":"        .SUCCESS => return,"},
{"lineNum":" 4728","line":"        .FAULT => unreachable,"},
{"lineNum":" 4729","line":"        .PERM => return error.PermissionDenied,"},
{"lineNum":" 4730","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 4731","line":"        .NOENT => return error.UnknownName,"},
{"lineNum":" 4732","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 4733","line":"    }"},
{"lineNum":" 4734","line":"}"},
{"lineNum":" 4735","line":""},
{"lineNum":" 4736","line":"pub fn gettimeofday(tv: ?*timeval, tz: ?*timezone) void {"},
{"lineNum":" 4737","line":"    switch (errno(system.gettimeofday(tv, tz))) {"},
{"lineNum":" 4738","line":"        .SUCCESS => return,"},
{"lineNum":" 4739","line":"        .INVAL => unreachable,"},
{"lineNum":" 4740","line":"        else => unreachable,"},
{"lineNum":" 4741","line":"    }"},
{"lineNum":" 4742","line":"}"},
{"lineNum":" 4743","line":""},
{"lineNum":" 4744","line":"pub const SeekError = error{"},
{"lineNum":" 4745","line":"    Unseekable,"},
{"lineNum":" 4746","line":""},
{"lineNum":" 4747","line":"    /// In WASI, this error may occur when the file descriptor does"},
{"lineNum":" 4748","line":"    /// not hold the required rights to seek on it."},
{"lineNum":" 4749","line":"    AccessDenied,"},
{"lineNum":" 4750","line":"} || UnexpectedError;"},
{"lineNum":" 4751","line":""},
{"lineNum":" 4752","line":"/// Repositions read/write file offset relative to the beginning."},
{"lineNum":" 4753","line":"pub fn lseek_SET(fd: fd_t, offset: u64) SeekError!void {"},
{"lineNum":" 4754","line":"    if (builtin.os.tag == .linux and !builtin.link_libc and @sizeOf(usize) == 4) {"},
{"lineNum":" 4755","line":"        var result: u64 = undefined;"},
{"lineNum":" 4756","line":"        switch (errno(system.llseek(fd, offset, &result, SEEK.SET))) {"},
{"lineNum":" 4757","line":"            .SUCCESS => return,"},
{"lineNum":" 4758","line":"            .BADF => unreachable, // always a race condition"},
{"lineNum":" 4759","line":"            .INVAL => return error.Unseekable,"},
{"lineNum":" 4760","line":"            .OVERFLOW => return error.Unseekable,"},
{"lineNum":" 4761","line":"            .SPIPE => return error.Unseekable,"},
{"lineNum":" 4762","line":"            .NXIO => return error.Unseekable,"},
{"lineNum":" 4763","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 4764","line":"        }"},
{"lineNum":" 4765","line":"    }"},
{"lineNum":" 4766","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 4767","line":"        return windows.SetFilePointerEx_BEGIN(fd, offset);"},
{"lineNum":" 4768","line":"    }"},
{"lineNum":" 4769","line":"    if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 4770","line":"        var new_offset: wasi.filesize_t = undefined;"},
{"lineNum":" 4771","line":"        switch (wasi.fd_seek(fd, @as(wasi.filedelta_t, @bitCast(offset)), .SET, &new_offset)) {"},
{"lineNum":" 4772","line":"            .SUCCESS => return,"},
{"lineNum":" 4773","line":"            .BADF => unreachable, // always a race condition"},
{"lineNum":" 4774","line":"            .INVAL => return error.Unseekable,"},
{"lineNum":" 4775","line":"            .OVERFLOW => return error.Unseekable,"},
{"lineNum":" 4776","line":"            .SPIPE => return error.Unseekable,"},
{"lineNum":" 4777","line":"            .NXIO => return error.Unseekable,"},
{"lineNum":" 4778","line":"            .NOTCAPABLE => return error.AccessDenied,"},
{"lineNum":" 4779","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 4780","line":"        }"},
{"lineNum":" 4781","line":"    }"},
{"lineNum":" 4782","line":""},
{"lineNum":" 4783","line":"    const lseek_sym = if (lfs64_abi) system.lseek64 else system.lseek;"},
{"lineNum":" 4784","line":""},
{"lineNum":" 4785","line":"    const ioffset = @as(i64, @bitCast(offset)); // the OS treats this as unsigned"},
{"lineNum":" 4786","line":"    switch (errno(lseek_sym(fd, ioffset, SEEK.SET))) {"},
{"lineNum":" 4787","line":"        .SUCCESS => return,"},
{"lineNum":" 4788","line":"        .BADF => unreachable, // always a race condition"},
{"lineNum":" 4789","line":"        .INVAL => return error.Unseekable,"},
{"lineNum":" 4790","line":"        .OVERFLOW => return error.Unseekable,"},
{"lineNum":" 4791","line":"        .SPIPE => return error.Unseekable,"},
{"lineNum":" 4792","line":"        .NXIO => return error.Unseekable,"},
{"lineNum":" 4793","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 4794","line":"    }"},
{"lineNum":" 4795","line":"}"},
{"lineNum":" 4796","line":""},
{"lineNum":" 4797","line":"/// Repositions read/write file offset relative to the current offset."},
{"lineNum":" 4798","line":"pub fn lseek_CUR(fd: fd_t, offset: i64) SeekError!void {"},
{"lineNum":" 4799","line":"    if (builtin.os.tag == .linux and !builtin.link_libc and @sizeOf(usize) == 4) {"},
{"lineNum":" 4800","line":"        var result: u64 = undefined;"},
{"lineNum":" 4801","line":"        switch (errno(system.llseek(fd, @as(u64, @bitCast(offset)), &result, SEEK.CUR))) {"},
{"lineNum":" 4802","line":"            .SUCCESS => return,"},
{"lineNum":" 4803","line":"            .BADF => unreachable, // always a race condition"},
{"lineNum":" 4804","line":"            .INVAL => return error.Unseekable,"},
{"lineNum":" 4805","line":"            .OVERFLOW => return error.Unseekable,"},
{"lineNum":" 4806","line":"            .SPIPE => return error.Unseekable,"},
{"lineNum":" 4807","line":"            .NXIO => return error.Unseekable,"},
{"lineNum":" 4808","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 4809","line":"        }"},
{"lineNum":" 4810","line":"    }"},
{"lineNum":" 4811","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 4812","line":"        return windows.SetFilePointerEx_CURRENT(fd, offset);"},
{"lineNum":" 4813","line":"    }"},
{"lineNum":" 4814","line":"    if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 4815","line":"        var new_offset: wasi.filesize_t = undefined;"},
{"lineNum":" 4816","line":"        switch (wasi.fd_seek(fd, offset, .CUR, &new_offset)) {"},
{"lineNum":" 4817","line":"            .SUCCESS => return,"},
{"lineNum":" 4818","line":"            .BADF => unreachable, // always a race condition"},
{"lineNum":" 4819","line":"            .INVAL => return error.Unseekable,"},
{"lineNum":" 4820","line":"            .OVERFLOW => return error.Unseekable,"},
{"lineNum":" 4821","line":"            .SPIPE => return error.Unseekable,"},
{"lineNum":" 4822","line":"            .NXIO => return error.Unseekable,"},
{"lineNum":" 4823","line":"            .NOTCAPABLE => return error.AccessDenied,"},
{"lineNum":" 4824","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 4825","line":"        }"},
{"lineNum":" 4826","line":"    }"},
{"lineNum":" 4827","line":"    const lseek_sym = if (lfs64_abi) system.lseek64 else system.lseek;"},
{"lineNum":" 4828","line":""},
{"lineNum":" 4829","line":"    const ioffset = @as(i64, @bitCast(offset)); // the OS treats this as unsigned"},
{"lineNum":" 4830","line":"    switch (errno(lseek_sym(fd, ioffset, SEEK.CUR))) {"},
{"lineNum":" 4831","line":"        .SUCCESS => return,"},
{"lineNum":" 4832","line":"        .BADF => unreachable, // always a race condition"},
{"lineNum":" 4833","line":"        .INVAL => return error.Unseekable,"},
{"lineNum":" 4834","line":"        .OVERFLOW => return error.Unseekable,"},
{"lineNum":" 4835","line":"        .SPIPE => return error.Unseekable,"},
{"lineNum":" 4836","line":"        .NXIO => return error.Unseekable,"},
{"lineNum":" 4837","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 4838","line":"    }"},
{"lineNum":" 4839","line":"}"},
{"lineNum":" 4840","line":""},
{"lineNum":" 4841","line":"/// Repositions read/write file offset relative to the end."},
{"lineNum":" 4842","line":"pub fn lseek_END(fd: fd_t, offset: i64) SeekError!void {"},
{"lineNum":" 4843","line":"    if (builtin.os.tag == .linux and !builtin.link_libc and @sizeOf(usize) == 4) {"},
{"lineNum":" 4844","line":"        var result: u64 = undefined;"},
{"lineNum":" 4845","line":"        switch (errno(system.llseek(fd, @as(u64, @bitCast(offset)), &result, SEEK.END))) {"},
{"lineNum":" 4846","line":"            .SUCCESS => return,"},
{"lineNum":" 4847","line":"            .BADF => unreachable, // always a race condition"},
{"lineNum":" 4848","line":"            .INVAL => return error.Unseekable,"},
{"lineNum":" 4849","line":"            .OVERFLOW => return error.Unseekable,"},
{"lineNum":" 4850","line":"            .SPIPE => return error.Unseekable,"},
{"lineNum":" 4851","line":"            .NXIO => return error.Unseekable,"},
{"lineNum":" 4852","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 4853","line":"        }"},
{"lineNum":" 4854","line":"    }"},
{"lineNum":" 4855","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 4856","line":"        return windows.SetFilePointerEx_END(fd, offset);"},
{"lineNum":" 4857","line":"    }"},
{"lineNum":" 4858","line":"    if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 4859","line":"        var new_offset: wasi.filesize_t = undefined;"},
{"lineNum":" 4860","line":"        switch (wasi.fd_seek(fd, offset, .END, &new_offset)) {"},
{"lineNum":" 4861","line":"            .SUCCESS => return,"},
{"lineNum":" 4862","line":"            .BADF => unreachable, // always a race condition"},
{"lineNum":" 4863","line":"            .INVAL => return error.Unseekable,"},
{"lineNum":" 4864","line":"            .OVERFLOW => return error.Unseekable,"},
{"lineNum":" 4865","line":"            .SPIPE => return error.Unseekable,"},
{"lineNum":" 4866","line":"            .NXIO => return error.Unseekable,"},
{"lineNum":" 4867","line":"            .NOTCAPABLE => return error.AccessDenied,"},
{"lineNum":" 4868","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 4869","line":"        }"},
{"lineNum":" 4870","line":"    }"},
{"lineNum":" 4871","line":"    const lseek_sym = if (lfs64_abi) system.lseek64 else system.lseek;"},
{"lineNum":" 4872","line":""},
{"lineNum":" 4873","line":"    const ioffset = @as(i64, @bitCast(offset)); // the OS treats this as unsigned"},
{"lineNum":" 4874","line":"    switch (errno(lseek_sym(fd, ioffset, SEEK.END))) {"},
{"lineNum":" 4875","line":"        .SUCCESS => return,"},
{"lineNum":" 4876","line":"        .BADF => unreachable, // always a race condition"},
{"lineNum":" 4877","line":"        .INVAL => return error.Unseekable,"},
{"lineNum":" 4878","line":"        .OVERFLOW => return error.Unseekable,"},
{"lineNum":" 4879","line":"        .SPIPE => return error.Unseekable,"},
{"lineNum":" 4880","line":"        .NXIO => return error.Unseekable,"},
{"lineNum":" 4881","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 4882","line":"    }"},
{"lineNum":" 4883","line":"}"},
{"lineNum":" 4884","line":""},
{"lineNum":" 4885","line":"/// Returns the read/write file offset relative to the beginning."},
{"lineNum":" 4886","line":"pub fn lseek_CUR_get(fd: fd_t) SeekError!u64 {"},
{"lineNum":" 4887","line":"    if (builtin.os.tag == .linux and !builtin.link_libc and @sizeOf(usize) == 4) {"},
{"lineNum":" 4888","line":"        var result: u64 = undefined;"},
{"lineNum":" 4889","line":"        switch (errno(system.llseek(fd, 0, &result, SEEK.CUR))) {"},
{"lineNum":" 4890","line":"            .SUCCESS => return result,"},
{"lineNum":" 4891","line":"            .BADF => unreachable, // always a race condition"},
{"lineNum":" 4892","line":"            .INVAL => return error.Unseekable,"},
{"lineNum":" 4893","line":"            .OVERFLOW => return error.Unseekable,"},
{"lineNum":" 4894","line":"            .SPIPE => return error.Unseekable,"},
{"lineNum":" 4895","line":"            .NXIO => return error.Unseekable,"},
{"lineNum":" 4896","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 4897","line":"        }"},
{"lineNum":" 4898","line":"    }"},
{"lineNum":" 4899","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 4900","line":"        return windows.SetFilePointerEx_CURRENT_get(fd);"},
{"lineNum":" 4901","line":"    }"},
{"lineNum":" 4902","line":"    if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 4903","line":"        var new_offset: wasi.filesize_t = undefined;"},
{"lineNum":" 4904","line":"        switch (wasi.fd_seek(fd, 0, .CUR, &new_offset)) {"},
{"lineNum":" 4905","line":"            .SUCCESS => return new_offset,"},
{"lineNum":" 4906","line":"            .BADF => unreachable, // always a race condition"},
{"lineNum":" 4907","line":"            .INVAL => return error.Unseekable,"},
{"lineNum":" 4908","line":"            .OVERFLOW => return error.Unseekable,"},
{"lineNum":" 4909","line":"            .SPIPE => return error.Unseekable,"},
{"lineNum":" 4910","line":"            .NXIO => return error.Unseekable,"},
{"lineNum":" 4911","line":"            .NOTCAPABLE => return error.AccessDenied,"},
{"lineNum":" 4912","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 4913","line":"        }"},
{"lineNum":" 4914","line":"    }"},
{"lineNum":" 4915","line":"    const lseek_sym = if (lfs64_abi) system.lseek64 else system.lseek;"},
{"lineNum":" 4916","line":""},
{"lineNum":" 4917","line":"    const rc = lseek_sym(fd, 0, SEEK.CUR);"},
{"lineNum":" 4918","line":"    switch (errno(rc)) {"},
{"lineNum":" 4919","line":"        .SUCCESS => return @as(u64, @bitCast(rc)),"},
{"lineNum":" 4920","line":"        .BADF => unreachable, // always a race condition"},
{"lineNum":" 4921","line":"        .INVAL => return error.Unseekable,"},
{"lineNum":" 4922","line":"        .OVERFLOW => return error.Unseekable,"},
{"lineNum":" 4923","line":"        .SPIPE => return error.Unseekable,"},
{"lineNum":" 4924","line":"        .NXIO => return error.Unseekable,"},
{"lineNum":" 4925","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 4926","line":"    }"},
{"lineNum":" 4927","line":"}"},
{"lineNum":" 4928","line":""},
{"lineNum":" 4929","line":"pub const FcntlError = error{"},
{"lineNum":" 4930","line":"    PermissionDenied,"},
{"lineNum":" 4931","line":"    FileBusy,"},
{"lineNum":" 4932","line":"    ProcessFdQuotaExceeded,"},
{"lineNum":" 4933","line":"    Locked,"},
{"lineNum":" 4934","line":"    DeadLock,"},
{"lineNum":" 4935","line":"    LockedRegionLimitExceeded,"},
{"lineNum":" 4936","line":"} || UnexpectedError;"},
{"lineNum":" 4937","line":""},
{"lineNum":" 4938","line":"pub fn fcntl(fd: fd_t, cmd: i32, arg: usize) FcntlError!usize {"},
{"lineNum":" 4939","line":"    while (true) {"},
{"lineNum":" 4940","line":"        const rc = system.fcntl(fd, cmd, arg);"},
{"lineNum":" 4941","line":"        switch (errno(rc)) {"},
{"lineNum":" 4942","line":"            .SUCCESS => return @as(usize, @intCast(rc)),"},
{"lineNum":" 4943","line":"            .INTR => continue,"},
{"lineNum":" 4944","line":"            .AGAIN, .ACCES => return error.Locked,"},
{"lineNum":" 4945","line":"            .BADF => unreachable,"},
{"lineNum":" 4946","line":"            .BUSY => return error.FileBusy,"},
{"lineNum":" 4947","line":"            .INVAL => unreachable, // invalid parameters"},
{"lineNum":" 4948","line":"            .PERM => return error.PermissionDenied,"},
{"lineNum":" 4949","line":"            .MFILE => return error.ProcessFdQuotaExceeded,"},
{"lineNum":" 4950","line":"            .NOTDIR => unreachable, // invalid parameter"},
{"lineNum":" 4951","line":"            .DEADLK => return error.DeadLock,"},
{"lineNum":" 4952","line":"            .NOLCK => return error.LockedRegionLimitExceeded,"},
{"lineNum":" 4953","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 4954","line":"        }"},
{"lineNum":" 4955","line":"    }"},
{"lineNum":" 4956","line":"}"},
{"lineNum":" 4957","line":""},
{"lineNum":" 4958","line":"fn setSockFlags(sock: socket_t, flags: u32) !void {"},
{"lineNum":" 4959","line":"    if ((flags & SOCK.CLOEXEC) != 0) {"},
{"lineNum":" 4960","line":"        if (builtin.os.tag == .windows) {"},
{"lineNum":" 4961","line":"            // TODO: Find out if this is supported for sockets"},
{"lineNum":" 4962","line":"        } else {"},
{"lineNum":" 4963","line":"            var fd_flags = fcntl(sock, F.GETFD, 0) catch |err| switch (err) {"},
{"lineNum":" 4964","line":"                error.FileBusy => unreachable,"},
{"lineNum":" 4965","line":"                error.Locked => unreachable,"},
{"lineNum":" 4966","line":"                error.PermissionDenied => unreachable,"},
{"lineNum":" 4967","line":"                error.DeadLock => unreachable,"},
{"lineNum":" 4968","line":"                error.LockedRegionLimitExceeded => unreachable,"},
{"lineNum":" 4969","line":"                else => |e| return e,"},
{"lineNum":" 4970","line":"            };"},
{"lineNum":" 4971","line":"            fd_flags |= FD_CLOEXEC;"},
{"lineNum":" 4972","line":"            _ = fcntl(sock, F.SETFD, fd_flags) catch |err| switch (err) {"},
{"lineNum":" 4973","line":"                error.FileBusy => unreachable,"},
{"lineNum":" 4974","line":"                error.Locked => unreachable,"},
{"lineNum":" 4975","line":"                error.PermissionDenied => unreachable,"},
{"lineNum":" 4976","line":"                error.DeadLock => unreachable,"},
{"lineNum":" 4977","line":"                error.LockedRegionLimitExceeded => unreachable,"},
{"lineNum":" 4978","line":"                else => |e| return e,"},
{"lineNum":" 4979","line":"            };"},
{"lineNum":" 4980","line":"        }"},
{"lineNum":" 4981","line":"    }"},
{"lineNum":" 4982","line":"    if ((flags & SOCK.NONBLOCK) != 0) {"},
{"lineNum":" 4983","line":"        if (builtin.os.tag == .windows) {"},
{"lineNum":" 4984","line":"            var mode: c_ulong = 1;"},
{"lineNum":" 4985","line":"            if (windows.ws2_32.ioctlsocket(sock, windows.ws2_32.FIONBIO, &mode) == windows.ws2_32.SOCKET_ERROR) {"},
{"lineNum":" 4986","line":"                switch (windows.ws2_32.WSAGetLastError()) {"},
{"lineNum":" 4987","line":"                    .WSANOTINITIALISED => unreachable,"},
{"lineNum":" 4988","line":"                    .WSAENETDOWN => return error.NetworkSubsystemFailed,"},
{"lineNum":" 4989","line":"                    .WSAENOTSOCK => return error.FileDescriptorNotASocket,"},
{"lineNum":" 4990","line":"                    // TODO: handle more errors"},
{"lineNum":" 4991","line":"                    else => |err| return windows.unexpectedWSAError(err),"},
{"lineNum":" 4992","line":"                }"},
{"lineNum":" 4993","line":"            }"},
{"lineNum":" 4994","line":"        } else {"},
{"lineNum":" 4995","line":"            var fl_flags = fcntl(sock, F.GETFL, 0) catch |err| switch (err) {"},
{"lineNum":" 4996","line":"                error.FileBusy => unreachable,"},
{"lineNum":" 4997","line":"                error.Locked => unreachable,"},
{"lineNum":" 4998","line":"                error.PermissionDenied => unreachable,"},
{"lineNum":" 4999","line":"                error.DeadLock => unreachable,"},
{"lineNum":" 5000","line":"                error.LockedRegionLimitExceeded => unreachable,"},
{"lineNum":" 5001","line":"                else => |e| return e,"},
{"lineNum":" 5002","line":"            };"},
{"lineNum":" 5003","line":"            fl_flags |= O.NONBLOCK;"},
{"lineNum":" 5004","line":"            _ = fcntl(sock, F.SETFL, fl_flags) catch |err| switch (err) {"},
{"lineNum":" 5005","line":"                error.FileBusy => unreachable,"},
{"lineNum":" 5006","line":"                error.Locked => unreachable,"},
{"lineNum":" 5007","line":"                error.PermissionDenied => unreachable,"},
{"lineNum":" 5008","line":"                error.DeadLock => unreachable,"},
{"lineNum":" 5009","line":"                error.LockedRegionLimitExceeded => unreachable,"},
{"lineNum":" 5010","line":"                else => |e| return e,"},
{"lineNum":" 5011","line":"            };"},
{"lineNum":" 5012","line":"        }"},
{"lineNum":" 5013","line":"    }"},
{"lineNum":" 5014","line":"}"},
{"lineNum":" 5015","line":""},
{"lineNum":" 5016","line":"pub const FlockError = error{"},
{"lineNum":" 5017","line":"    WouldBlock,"},
{"lineNum":" 5018","line":""},
{"lineNum":" 5019","line":"    /// The kernel ran out of memory for allocating file locks"},
{"lineNum":" 5020","line":"    SystemResources,"},
{"lineNum":" 5021","line":""},
{"lineNum":" 5022","line":"    /// The underlying filesystem does not support file locks"},
{"lineNum":" 5023","line":"    FileLocksNotSupported,"},
{"lineNum":" 5024","line":"} || UnexpectedError;"},
{"lineNum":" 5025","line":""},
{"lineNum":" 5026","line":"/// Depending on the operating system `flock` may or may not interact with"},
{"lineNum":" 5027","line":"/// `fcntl` locks made by other processes."},
{"lineNum":" 5028","line":"pub fn flock(fd: fd_t, operation: i32) FlockError!void {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 5029","line":"    while (true) {"},
{"lineNum":" 5030","line":"        const rc = system.flock(fd, operation);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 5031","line":"        switch (errno(rc)) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 5032","line":"            .SUCCESS => return,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 5033","line":"            .BADF => unreachable,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 5034","line":"            .INTR => continue,"},
{"lineNum":" 5035","line":"            .INVAL => unreachable, // invalid parameters","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 5036","line":"            .NOLCK => return error.SystemResources,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 5037","line":"            .AGAIN => return error.WouldBlock, // TODO: integrate with async instead of just returning an error","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 5038","line":"            .OPNOTSUPP => return error.FileLocksNotSupported,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 5039","line":"            else => |err| return unexpectedErrno(err),","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 5040","line":"        }"},
{"lineNum":" 5041","line":"    }"},
{"lineNum":" 5042","line":"}"},
{"lineNum":" 5043","line":""},
{"lineNum":" 5044","line":"pub const RealPathError = error{"},
{"lineNum":" 5045","line":"    FileNotFound,"},
{"lineNum":" 5046","line":"    AccessDenied,"},
{"lineNum":" 5047","line":"    NameTooLong,"},
{"lineNum":" 5048","line":"    NotSupported,"},
{"lineNum":" 5049","line":"    NotDir,"},
{"lineNum":" 5050","line":"    SymLinkLoop,"},
{"lineNum":" 5051","line":"    InputOutput,"},
{"lineNum":" 5052","line":"    FileTooBig,"},
{"lineNum":" 5053","line":"    IsDir,"},
{"lineNum":" 5054","line":"    ProcessFdQuotaExceeded,"},
{"lineNum":" 5055","line":"    SystemFdQuotaExceeded,"},
{"lineNum":" 5056","line":"    NoDevice,"},
{"lineNum":" 5057","line":"    SystemResources,"},
{"lineNum":" 5058","line":"    NoSpaceLeft,"},
{"lineNum":" 5059","line":"    FileSystem,"},
{"lineNum":" 5060","line":"    BadPathName,"},
{"lineNum":" 5061","line":"    DeviceBusy,"},
{"lineNum":" 5062","line":""},
{"lineNum":" 5063","line":"    SharingViolation,"},
{"lineNum":" 5064","line":"    PipeBusy,"},
{"lineNum":" 5065","line":""},
{"lineNum":" 5066","line":"    /// On WASI, the current CWD may not be associated with an absolute path."},
{"lineNum":" 5067","line":"    InvalidHandle,"},
{"lineNum":" 5068","line":""},
{"lineNum":" 5069","line":"    /// On Windows, file paths must be valid Unicode."},
{"lineNum":" 5070","line":"    InvalidUtf8,"},
{"lineNum":" 5071","line":""},
{"lineNum":" 5072","line":"    /// On Windows, `\\\\server` or `\\\\server\\share` was not found."},
{"lineNum":" 5073","line":"    NetworkNotFound,"},
{"lineNum":" 5074","line":""},
{"lineNum":" 5075","line":"    PathAlreadyExists,"},
{"lineNum":" 5076","line":"} || UnexpectedError;"},
{"lineNum":" 5077","line":""},
{"lineNum":" 5078","line":"/// Return the canonicalized absolute pathname."},
{"lineNum":" 5079","line":"/// Expands all symbolic links and resolves references to `.`, `..`, and"},
{"lineNum":" 5080","line":"/// extra `/` characters in `pathname`."},
{"lineNum":" 5081","line":"/// The return value is a slice of `out_buffer`, but not necessarily from the beginning."},
{"lineNum":" 5082","line":"/// See also `realpathZ` and `realpathW`."},
{"lineNum":" 5083","line":"pub fn realpath(pathname: []const u8, out_buffer: *[MAX_PATH_BYTES]u8) RealPathError![]u8 {"},
{"lineNum":" 5084","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 5085","line":"        const pathname_w = try windows.sliceToPrefixedFileW(pathname);"},
{"lineNum":" 5086","line":"        return realpathW(pathname_w.span(), out_buffer);"},
{"lineNum":" 5087","line":"    } else if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 5088","line":"        @compileError(\"WASI does not support os.realpath\");"},
{"lineNum":" 5089","line":"    }"},
{"lineNum":" 5090","line":"    const pathname_c = try toPosixPath(pathname);"},
{"lineNum":" 5091","line":"    return realpathZ(&pathname_c, out_buffer);"},
{"lineNum":" 5092","line":"}"},
{"lineNum":" 5093","line":""},
{"lineNum":" 5094","line":"/// Same as `realpath` except `pathname` is null-terminated."},
{"lineNum":" 5095","line":"pub fn realpathZ(pathname: [*:0]const u8, out_buffer: *[MAX_PATH_BYTES]u8) RealPathError![]u8 {"},
{"lineNum":" 5096","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 5097","line":"        const pathname_w = try windows.cStrToPrefixedFileW(pathname);"},
{"lineNum":" 5098","line":"        return realpathW(pathname_w.span(), out_buffer);"},
{"lineNum":" 5099","line":"    } else if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 5100","line":"        return realpath(mem.sliceTo(pathname, 0), out_buffer);"},
{"lineNum":" 5101","line":"    }"},
{"lineNum":" 5102","line":"    if (!builtin.link_libc) {"},
{"lineNum":" 5103","line":"        const flags = if (builtin.os.tag == .linux) O.PATH | O.NONBLOCK | O.CLOEXEC else O.NONBLOCK | O.CLOEXEC;"},
{"lineNum":" 5104","line":"        const fd = openZ(pathname, flags, 0) catch |err| switch (err) {"},
{"lineNum":" 5105","line":"            error.FileLocksNotSupported => unreachable,"},
{"lineNum":" 5106","line":"            error.WouldBlock => unreachable,"},
{"lineNum":" 5107","line":"            error.FileBusy => unreachable, // not asking for write permissions"},
{"lineNum":" 5108","line":"            error.InvalidHandle => unreachable, // WASI-only"},
{"lineNum":" 5109","line":"            else => |e| return e,"},
{"lineNum":" 5110","line":"        };"},
{"lineNum":" 5111","line":"        defer close(fd);"},
{"lineNum":" 5112","line":""},
{"lineNum":" 5113","line":"        return getFdPath(fd, out_buffer);"},
{"lineNum":" 5114","line":"    }"},
{"lineNum":" 5115","line":"    const result_path = std.c.realpath(pathname, out_buffer) orelse switch (@as(E, @enumFromInt(std.c._errno().*))) {"},
{"lineNum":" 5116","line":"        .SUCCESS => unreachable,"},
{"lineNum":" 5117","line":"        .INVAL => unreachable,"},
{"lineNum":" 5118","line":"        .BADF => unreachable,"},
{"lineNum":" 5119","line":"        .FAULT => unreachable,"},
{"lineNum":" 5120","line":"        .ACCES => return error.AccessDenied,"},
{"lineNum":" 5121","line":"        .NOENT => return error.FileNotFound,"},
{"lineNum":" 5122","line":"        .OPNOTSUPP => return error.NotSupported,"},
{"lineNum":" 5123","line":"        .NOTDIR => return error.NotDir,"},
{"lineNum":" 5124","line":"        .NAMETOOLONG => return error.NameTooLong,"},
{"lineNum":" 5125","line":"        .LOOP => return error.SymLinkLoop,"},
{"lineNum":" 5126","line":"        .IO => return error.InputOutput,"},
{"lineNum":" 5127","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 5128","line":"    };"},
{"lineNum":" 5129","line":"    return mem.sliceTo(result_path, 0);"},
{"lineNum":" 5130","line":"}"},
{"lineNum":" 5131","line":""},
{"lineNum":" 5132","line":"/// Same as `realpath` except `pathname` is UTF16LE-encoded."},
{"lineNum":" 5133","line":"pub fn realpathW(pathname: []const u16, out_buffer: *[MAX_PATH_BYTES]u8) RealPathError![]u8 {"},
{"lineNum":" 5134","line":"    const w = windows;"},
{"lineNum":" 5135","line":""},
{"lineNum":" 5136","line":"    const dir = std.fs.cwd().fd;"},
{"lineNum":" 5137","line":"    const access_mask = w.GENERIC_READ | w.SYNCHRONIZE;"},
{"lineNum":" 5138","line":"    const share_access = w.FILE_SHARE_READ;"},
{"lineNum":" 5139","line":"    const creation = w.FILE_OPEN;"},
{"lineNum":" 5140","line":"    const h_file = blk: {"},
{"lineNum":" 5141","line":"        const res = w.OpenFile(pathname, .{"},
{"lineNum":" 5142","line":"            .dir = dir,"},
{"lineNum":" 5143","line":"            .access_mask = access_mask,"},
{"lineNum":" 5144","line":"            .share_access = share_access,"},
{"lineNum":" 5145","line":"            .creation = creation,"},
{"lineNum":" 5146","line":"            .io_mode = .blocking,"},
{"lineNum":" 5147","line":"        }) catch |err| switch (err) {"},
{"lineNum":" 5148","line":"            error.IsDir => break :blk w.OpenFile(pathname, .{"},
{"lineNum":" 5149","line":"                .dir = dir,"},
{"lineNum":" 5150","line":"                .access_mask = access_mask,"},
{"lineNum":" 5151","line":"                .share_access = share_access,"},
{"lineNum":" 5152","line":"                .creation = creation,"},
{"lineNum":" 5153","line":"                .io_mode = .blocking,"},
{"lineNum":" 5154","line":"                .filter = .dir_only,"},
{"lineNum":" 5155","line":"            }) catch |er| switch (er) {"},
{"lineNum":" 5156","line":"                error.WouldBlock => unreachable,"},
{"lineNum":" 5157","line":"                else => |e2| return e2,"},
{"lineNum":" 5158","line":"            },"},
{"lineNum":" 5159","line":"            error.WouldBlock => unreachable,"},
{"lineNum":" 5160","line":"            else => |e| return e,"},
{"lineNum":" 5161","line":"        };"},
{"lineNum":" 5162","line":"        break :blk res;"},
{"lineNum":" 5163","line":"    };"},
{"lineNum":" 5164","line":"    defer w.CloseHandle(h_file);"},
{"lineNum":" 5165","line":""},
{"lineNum":" 5166","line":"    return getFdPath(h_file, out_buffer);"},
{"lineNum":" 5167","line":"}"},
{"lineNum":" 5168","line":""},
{"lineNum":" 5169","line":"/// Return canonical path of handle `fd`."},
{"lineNum":" 5170","line":"/// This function is very host-specific and is not universally supported by all hosts."},
{"lineNum":" 5171","line":"/// For example, while it generally works on Linux, macOS, FreeBSD or Windows, it is"},
{"lineNum":" 5172","line":"/// unsupported on WASI."},
{"lineNum":" 5173","line":"pub fn getFdPath(fd: fd_t, out_buffer: *[MAX_PATH_BYTES]u8) RealPathError![]u8 {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 5174","line":"    switch (builtin.os.tag) {"},
{"lineNum":" 5175","line":"        .windows => {"},
{"lineNum":" 5176","line":"            var wide_buf: [windows.PATH_MAX_WIDE]u16 = undefined;"},
{"lineNum":" 5177","line":"            const wide_slice = try windows.GetFinalPathNameByHandle(fd, .{}, wide_buf[0..]);"},
{"lineNum":" 5178","line":""},
{"lineNum":" 5179","line":"            // Trust that Windows gives us valid UTF-16LE."},
{"lineNum":" 5180","line":"            const end_index = std.unicode.utf16leToUtf8(out_buffer, wide_slice) catch unreachable;"},
{"lineNum":" 5181","line":"            return out_buffer[0..end_index];"},
{"lineNum":" 5182","line":"        },"},
{"lineNum":" 5183","line":"        .macos, .ios, .watchos, .tvos => {"},
{"lineNum":" 5184","line":"            // On macOS, we can use F.GETPATH fcntl command to query the OS for"},
{"lineNum":" 5185","line":"            // the path to the file descriptor."},
{"lineNum":" 5186","line":"            @memset(out_buffer[0..MAX_PATH_BYTES], 0);"},
{"lineNum":" 5187","line":"            switch (errno(system.fcntl(fd, F.GETPATH, out_buffer))) {"},
{"lineNum":" 5188","line":"                .SUCCESS => {},"},
{"lineNum":" 5189","line":"                .BADF => return error.FileNotFound,"},
{"lineNum":" 5190","line":"                .NOSPC => return error.NameTooLong,"},
{"lineNum":" 5191","line":"                // TODO man pages for fcntl on macOS don\'t really tell you what"},
{"lineNum":" 5192","line":"                // errno values to expect when command is F.GETPATH..."},
{"lineNum":" 5193","line":"                else => |err| return unexpectedErrno(err),"},
{"lineNum":" 5194","line":"            }"},
{"lineNum":" 5195","line":"            const len = mem.indexOfScalar(u8, out_buffer[0..], @as(u8, 0)) orelse MAX_PATH_BYTES;"},
{"lineNum":" 5196","line":"            return out_buffer[0..len];"},
{"lineNum":" 5197","line":"        },"},
{"lineNum":" 5198","line":"        .linux => {"},
{"lineNum":" 5199","line":"            var procfs_buf: [\"/proc/self/fd/-2147483648\\x00\".len]u8 = undefined;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 5200","line":"            const proc_path = std.fmt.bufPrintZ(procfs_buf[0..], \"/proc/self/fd/{d}\", .{fd}) catch unreachable;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 5201","line":""},
{"lineNum":" 5202","line":"            const target = readlinkZ(proc_path, out_buffer) catch |err| {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 5203","line":"                switch (err) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 5204","line":"                    error.UnsupportedReparsePointType => unreachable, // Windows only,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 5205","line":"                    error.NotLink => unreachable,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 5206","line":"                    else => |e| return e,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 5207","line":"                }"},
{"lineNum":" 5208","line":"            };"},
{"lineNum":" 5209","line":"            return target;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 5210","line":"        },"},
{"lineNum":" 5211","line":"        .solaris => {"},
{"lineNum":" 5212","line":"            var procfs_buf: [\"/proc/self/path/-2147483648\\x00\".len]u8 = undefined;"},
{"lineNum":" 5213","line":"            const proc_path = std.fmt.bufPrintZ(procfs_buf[0..], \"/proc/self/path/{d}\", .{fd}) catch unreachable;"},
{"lineNum":" 5214","line":""},
{"lineNum":" 5215","line":"            const target = readlinkZ(proc_path, out_buffer) catch |err| switch (err) {"},
{"lineNum":" 5216","line":"                error.UnsupportedReparsePointType => unreachable,"},
{"lineNum":" 5217","line":"                error.NotLink => unreachable,"},
{"lineNum":" 5218","line":"                else => |e| return e,"},
{"lineNum":" 5219","line":"            };"},
{"lineNum":" 5220","line":"            return target;"},
{"lineNum":" 5221","line":"        },"},
{"lineNum":" 5222","line":"        .freebsd => {"},
{"lineNum":" 5223","line":"            if (comptime builtin.os.version_range.semver.max.order(.{ .major = 13, .minor = 0, .patch = 0 }) == .gt) {"},
{"lineNum":" 5224","line":"                var kfile: system.kinfo_file = undefined;"},
{"lineNum":" 5225","line":"                kfile.structsize = system.KINFO_FILE_SIZE;"},
{"lineNum":" 5226","line":"                switch (errno(system.fcntl(fd, system.F.KINFO, @intFromPtr(&kfile)))) {"},
{"lineNum":" 5227","line":"                    .SUCCESS => {},"},
{"lineNum":" 5228","line":"                    .BADF => return error.FileNotFound,"},
{"lineNum":" 5229","line":"                    else => |err| return unexpectedErrno(err),"},
{"lineNum":" 5230","line":"                }"},
{"lineNum":" 5231","line":"                const len = mem.indexOfScalar(u8, &kfile.path, 0) orelse MAX_PATH_BYTES;"},
{"lineNum":" 5232","line":"                if (len == 0) return error.NameTooLong;"},
{"lineNum":" 5233","line":"                const result = out_buffer[0..len];"},
{"lineNum":" 5234","line":"                @memcpy(result, kfile.path[0..len]);"},
{"lineNum":" 5235","line":"                return result;"},
{"lineNum":" 5236","line":"            } else {"},
{"lineNum":" 5237","line":"                // This fallback implementation reimplements libutil\'s `kinfo_getfile()`."},
{"lineNum":" 5238","line":"                // The motivation is to avoid linking -lutil when building zig or general"},
{"lineNum":" 5239","line":"                // user executables."},
{"lineNum":" 5240","line":"                var mib = [4]c_int{ CTL.KERN, KERN.PROC, KERN.PROC_FILEDESC, system.getpid() };"},
{"lineNum":" 5241","line":"                var len: usize = undefined;"},
{"lineNum":" 5242","line":"                sysctl(&mib, null, &len, null, 0) catch |err| switch (err) {"},
{"lineNum":" 5243","line":"                    error.PermissionDenied => unreachable,"},
{"lineNum":" 5244","line":"                    error.SystemResources => return error.SystemResources,"},
{"lineNum":" 5245","line":"                    error.NameTooLong => unreachable,"},
{"lineNum":" 5246","line":"                    error.UnknownName => unreachable,"},
{"lineNum":" 5247","line":"                    else => return error.Unexpected,"},
{"lineNum":" 5248","line":"                };"},
{"lineNum":" 5249","line":"                len = len * 4 / 3;"},
{"lineNum":" 5250","line":"                const buf = std.heap.c_allocator.alloc(u8, len) catch return error.SystemResources;"},
{"lineNum":" 5251","line":"                defer std.heap.c_allocator.free(buf);"},
{"lineNum":" 5252","line":"                len = buf.len;"},
{"lineNum":" 5253","line":"                sysctl(&mib, &buf[0], &len, null, 0) catch |err| switch (err) {"},
{"lineNum":" 5254","line":"                    error.PermissionDenied => unreachable,"},
{"lineNum":" 5255","line":"                    error.SystemResources => return error.SystemResources,"},
{"lineNum":" 5256","line":"                    error.NameTooLong => unreachable,"},
{"lineNum":" 5257","line":"                    error.UnknownName => unreachable,"},
{"lineNum":" 5258","line":"                    else => return error.Unexpected,"},
{"lineNum":" 5259","line":"                };"},
{"lineNum":" 5260","line":"                var i: usize = 0;"},
{"lineNum":" 5261","line":"                while (i < len) {"},
{"lineNum":" 5262","line":"                    const kf: *align(1) system.kinfo_file = @as(*align(1) system.kinfo_file, @ptrCast(&buf[i]));"},
{"lineNum":" 5263","line":"                    if (kf.fd == fd) {"},
{"lineNum":" 5264","line":"                        len = mem.indexOfScalar(u8, &kf.path, 0) orelse MAX_PATH_BYTES;"},
{"lineNum":" 5265","line":"                        if (len == 0) return error.NameTooLong;"},
{"lineNum":" 5266","line":"                        const result = out_buffer[0..len];"},
{"lineNum":" 5267","line":"                        @memcpy(result, kf.path[0..len]);"},
{"lineNum":" 5268","line":"                        return result;"},
{"lineNum":" 5269","line":"                    }"},
{"lineNum":" 5270","line":"                    i += @as(usize, @intCast(kf.structsize));"},
{"lineNum":" 5271","line":"                }"},
{"lineNum":" 5272","line":"                return error.InvalidHandle;"},
{"lineNum":" 5273","line":"            }"},
{"lineNum":" 5274","line":"        },"},
{"lineNum":" 5275","line":"        .dragonfly => {"},
{"lineNum":" 5276","line":"            if (comptime builtin.os.version_range.semver.max.order(.{ .major = 6, .minor = 0, .patch = 0 }) == .lt) {"},
{"lineNum":" 5277","line":"                @compileError(\"querying for canonical path of a handle is unsupported on this host\");"},
{"lineNum":" 5278","line":"            }"},
{"lineNum":" 5279","line":"            @memset(out_buffer[0..MAX_PATH_BYTES], 0);"},
{"lineNum":" 5280","line":"            switch (errno(system.fcntl(fd, F.GETPATH, out_buffer))) {"},
{"lineNum":" 5281","line":"                .SUCCESS => {},"},
{"lineNum":" 5282","line":"                .BADF => return error.FileNotFound,"},
{"lineNum":" 5283","line":"                .RANGE => return error.NameTooLong,"},
{"lineNum":" 5284","line":"                else => |err| return unexpectedErrno(err),"},
{"lineNum":" 5285","line":"            }"},
{"lineNum":" 5286","line":"            const len = mem.indexOfScalar(u8, out_buffer[0..], @as(u8, 0)) orelse MAX_PATH_BYTES;"},
{"lineNum":" 5287","line":"            return out_buffer[0..len];"},
{"lineNum":" 5288","line":"        },"},
{"lineNum":" 5289","line":"        .netbsd => {"},
{"lineNum":" 5290","line":"            if (comptime builtin.os.version_range.semver.max.order(.{ .major = 10, .minor = 0, .patch = 0 }) == .lt) {"},
{"lineNum":" 5291","line":"                @compileError(\"querying for canonical path of a handle is unsupported on this host\");"},
{"lineNum":" 5292","line":"            }"},
{"lineNum":" 5293","line":"            @memset(out_buffer[0..MAX_PATH_BYTES], 0);"},
{"lineNum":" 5294","line":"            switch (errno(system.fcntl(fd, F.GETPATH, out_buffer))) {"},
{"lineNum":" 5295","line":"                .SUCCESS => {},"},
{"lineNum":" 5296","line":"                .ACCES => return error.AccessDenied,"},
{"lineNum":" 5297","line":"                .BADF => return error.FileNotFound,"},
{"lineNum":" 5298","line":"                .NOENT => return error.FileNotFound,"},
{"lineNum":" 5299","line":"                .NOMEM => return error.SystemResources,"},
{"lineNum":" 5300","line":"                .RANGE => return error.NameTooLong,"},
{"lineNum":" 5301","line":"                else => |err| return unexpectedErrno(err),"},
{"lineNum":" 5302","line":"            }"},
{"lineNum":" 5303","line":"            const len = mem.indexOfScalar(u8, out_buffer[0..], @as(u8, 0)) orelse MAX_PATH_BYTES;"},
{"lineNum":" 5304","line":"            return out_buffer[0..len];"},
{"lineNum":" 5305","line":"        },"},
{"lineNum":" 5306","line":"        else => @compileError(\"querying for canonical path of a handle is unsupported on this host\"),"},
{"lineNum":" 5307","line":"    }"},
{"lineNum":" 5308","line":"}"},
{"lineNum":" 5309","line":""},
{"lineNum":" 5310","line":"/// Spurious wakeups are possible and no precision of timing is guaranteed."},
{"lineNum":" 5311","line":"pub fn nanosleep(seconds: u64, nanoseconds: u64) void {"},
{"lineNum":" 5312","line":"    var req = timespec{"},
{"lineNum":" 5313","line":"        .tv_sec = math.cast(isize, seconds) orelse math.maxInt(isize),"},
{"lineNum":" 5314","line":"        .tv_nsec = math.cast(isize, nanoseconds) orelse math.maxInt(isize),"},
{"lineNum":" 5315","line":"    };"},
{"lineNum":" 5316","line":"    var rem: timespec = undefined;"},
{"lineNum":" 5317","line":"    while (true) {"},
{"lineNum":" 5318","line":"        switch (errno(system.nanosleep(&req, &rem))) {"},
{"lineNum":" 5319","line":"            .FAULT => unreachable,"},
{"lineNum":" 5320","line":"            .INVAL => {"},
{"lineNum":" 5321","line":"                // Sometimes Darwin returns EINVAL for no reason."},
{"lineNum":" 5322","line":"                // We treat it as a spurious wakeup."},
{"lineNum":" 5323","line":"                return;"},
{"lineNum":" 5324","line":"            },"},
{"lineNum":" 5325","line":"            .INTR => {"},
{"lineNum":" 5326","line":"                req = rem;"},
{"lineNum":" 5327","line":"                continue;"},
{"lineNum":" 5328","line":"            },"},
{"lineNum":" 5329","line":"            // This prong handles success as well as unexpected errors."},
{"lineNum":" 5330","line":"            else => return,"},
{"lineNum":" 5331","line":"        }"},
{"lineNum":" 5332","line":"    }"},
{"lineNum":" 5333","line":"}"},
{"lineNum":" 5334","line":""},
{"lineNum":" 5335","line":"pub fn dl_iterate_phdr("},
{"lineNum":" 5336","line":"    context: anytype,"},
{"lineNum":" 5337","line":"    comptime Error: type,"},
{"lineNum":" 5338","line":"    comptime callback: fn (info: *dl_phdr_info, size: usize, context: @TypeOf(context)) Error!void,"},
{"lineNum":" 5339","line":") Error!void {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 5340","line":"    const Context = @TypeOf(context);"},
{"lineNum":" 5341","line":""},
{"lineNum":" 5342","line":"    switch (builtin.object_format) {"},
{"lineNum":" 5343","line":"        .elf, .c => {},"},
{"lineNum":" 5344","line":"        else => @compileError(\"dl_iterate_phdr is not available for this target\"),"},
{"lineNum":" 5345","line":"    }"},
{"lineNum":" 5346","line":""},
{"lineNum":" 5347","line":"    if (builtin.link_libc) {"},
{"lineNum":" 5348","line":"        switch (system.dl_iterate_phdr(struct {"},
{"lineNum":" 5349","line":"            fn callbackC(info: *dl_phdr_info, size: usize, data: ?*anyopaque) callconv(.C) c_int {"},
{"lineNum":" 5350","line":"                const context_ptr: *const Context = @ptrCast(@alignCast(data));"},
{"lineNum":" 5351","line":"                callback(info, size, context_ptr.*) catch |err| return @intFromError(err);"},
{"lineNum":" 5352","line":"                return 0;"},
{"lineNum":" 5353","line":"            }"},
{"lineNum":" 5354","line":"        }.callbackC, @as(?*anyopaque, @ptrFromInt(@intFromPtr(&context))))) {"},
{"lineNum":" 5355","line":"            0 => return,"},
{"lineNum":" 5356","line":"            else => |err| return @as(Error, @errSetCast(@errorFromInt(@as(u16, @intCast(err))))), // TODO don\'t hardcode u16"},
{"lineNum":" 5357","line":"        }"},
{"lineNum":" 5358","line":"    }"},
{"lineNum":" 5359","line":""},
{"lineNum":" 5360","line":"    const elf_base = std.process.getBaseAddress();","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 5361","line":"    const ehdr = @as(*elf.Ehdr, @ptrFromInt(elf_base));","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":" 5362","line":"    // Make sure the base address points to an ELF image."},
{"lineNum":" 5363","line":"    assert(mem.eql(u8, ehdr.e_ident[0..4], elf.MAGIC));","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 5364","line":"    const n_phdr = ehdr.e_phnum;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 5365","line":"    const phdrs = (@as([*]elf.Phdr, @ptrFromInt(elf_base + ehdr.e_phoff)))[0..n_phdr];","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":" 5366","line":""},
{"lineNum":" 5367","line":"    var it = dl.linkmap_iterator(phdrs) catch unreachable;","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":" 5368","line":""},
{"lineNum":" 5369","line":"    // The executable has no dynamic link segment, create a single entry for"},
{"lineNum":" 5370","line":"    // the whole ELF image."},
{"lineNum":" 5371","line":"    if (it.end()) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 5372","line":"        // Find the base address for the ELF image, if this is a PIE the value"},
{"lineNum":" 5373","line":"        // is non-zero."},
{"lineNum":" 5374","line":"        const base_address = for (phdrs) |*phdr| {","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":" 5375","line":"            if (phdr.p_type == elf.PT_PHDR) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 5376","line":"                break @intFromPtr(phdrs.ptr) - phdr.p_vaddr;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 5377","line":"                // We could try computing the difference between _DYNAMIC and"},
{"lineNum":" 5378","line":"                // the p_vaddr of the PT_DYNAMIC section, but using the phdr is"},
{"lineNum":" 5379","line":"                // good enough (Is it?)."},
{"lineNum":" 5380","line":"            }"},
{"lineNum":" 5381","line":"        } else unreachable;","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":" 5382","line":""},
{"lineNum":" 5383","line":"        var info = dl_phdr_info{","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 5384","line":"            .dlpi_addr = base_address,"},
{"lineNum":" 5385","line":"            .dlpi_name = \"/proc/self/exe\","},
{"lineNum":" 5386","line":"            .dlpi_phdr = phdrs.ptr,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 5387","line":"            .dlpi_phnum = ehdr.e_phnum,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 5388","line":"        };"},
{"lineNum":" 5389","line":""},
{"lineNum":" 5390","line":"        return callback(&info, @sizeOf(dl_phdr_info), context);","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":" 5391","line":"    }"},
{"lineNum":" 5392","line":""},
{"lineNum":" 5393","line":"    // Last return value from the callback function."},
{"lineNum":" 5394","line":"    while (it.next()) |entry| {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":" 5395","line":"        var dlpi_phdr: [*]elf.Phdr = undefined;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 5396","line":"        var dlpi_phnum: u16 = undefined;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 5397","line":""},
{"lineNum":" 5398","line":"        if (entry.l_addr != 0) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 5399","line":"            const elf_header = @as(*elf.Ehdr, @ptrFromInt(entry.l_addr));","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":" 5400","line":"            dlpi_phdr = @as([*]elf.Phdr, @ptrFromInt(entry.l_addr + elf_header.e_phoff));","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":" 5401","line":"            dlpi_phnum = elf_header.e_phnum;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 5402","line":"        } else {"},
{"lineNum":" 5403","line":"            // This is the running ELF image"},
{"lineNum":" 5404","line":"            dlpi_phdr = @as([*]elf.Phdr, @ptrFromInt(elf_base + ehdr.e_phoff));","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":" 5405","line":"            dlpi_phnum = ehdr.e_phnum;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 5406","line":"        }"},
{"lineNum":" 5407","line":""},
{"lineNum":" 5408","line":"        var info = dl_phdr_info{"},
{"lineNum":" 5409","line":"            .dlpi_addr = entry.l_addr,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 5410","line":"            .dlpi_name = entry.l_name,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 5411","line":"            .dlpi_phdr = dlpi_phdr,"},
{"lineNum":" 5412","line":"            .dlpi_phnum = dlpi_phnum,"},
{"lineNum":" 5413","line":"        };"},
{"lineNum":" 5414","line":""},
{"lineNum":" 5415","line":"        try callback(&info, @sizeOf(dl_phdr_info), context);","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":" 5416","line":"    }"},
{"lineNum":" 5417","line":"}"},
{"lineNum":" 5418","line":""},
{"lineNum":" 5419","line":"pub const ClockGetTimeError = error{UnsupportedClock} || UnexpectedError;"},
{"lineNum":" 5420","line":""},
{"lineNum":" 5421","line":"/// TODO: change this to return the timespec as a return value"},
{"lineNum":" 5422","line":"/// TODO: look into making clk_id an enum"},
{"lineNum":" 5423","line":"pub fn clock_gettime(clk_id: i32, tp: *timespec) ClockGetTimeError!void {","class":"lineCov","hits":"1","order":"403","possible_hits":"1",},
{"lineNum":" 5424","line":"    if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 5425","line":"        var ts: timestamp_t = undefined;"},
{"lineNum":" 5426","line":"        switch (system.clock_time_get(@as(u32, @bitCast(clk_id)), 1, &ts)) {"},
{"lineNum":" 5427","line":"            .SUCCESS => {"},
{"lineNum":" 5428","line":"                tp.* = .{"},
{"lineNum":" 5429","line":"                    .tv_sec = @as(i64, @intCast(ts / std.time.ns_per_s)),"},
{"lineNum":" 5430","line":"                    .tv_nsec = @as(isize, @intCast(ts % std.time.ns_per_s)),"},
{"lineNum":" 5431","line":"                };"},
{"lineNum":" 5432","line":"            },"},
{"lineNum":" 5433","line":"            .INVAL => return error.UnsupportedClock,"},
{"lineNum":" 5434","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 5435","line":"        }"},
{"lineNum":" 5436","line":"        return;"},
{"lineNum":" 5437","line":"    }"},
{"lineNum":" 5438","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 5439","line":"        if (clk_id == CLOCK.REALTIME) {"},
{"lineNum":" 5440","line":"            var ft: windows.FILETIME = undefined;"},
{"lineNum":" 5441","line":"            windows.kernel32.GetSystemTimeAsFileTime(&ft);"},
{"lineNum":" 5442","line":"            // FileTime has a granularity of 100 nanoseconds and uses the NTFS/Windows epoch."},
{"lineNum":" 5443","line":"            const ft64 = (@as(u64, ft.dwHighDateTime) << 32) | ft.dwLowDateTime;"},
{"lineNum":" 5444","line":"            const ft_per_s = std.time.ns_per_s / 100;"},
{"lineNum":" 5445","line":"            tp.* = .{"},
{"lineNum":" 5446","line":"                .tv_sec = @as(i64, @intCast(ft64 / ft_per_s)) + std.time.epoch.windows,"},
{"lineNum":" 5447","line":"                .tv_nsec = @as(c_long, @intCast(ft64 % ft_per_s)) * 100,"},
{"lineNum":" 5448","line":"            };"},
{"lineNum":" 5449","line":"            return;"},
{"lineNum":" 5450","line":"        } else {"},
{"lineNum":" 5451","line":"            // TODO POSIX implementation of CLOCK.MONOTONIC on Windows."},
{"lineNum":" 5452","line":"            return error.UnsupportedClock;"},
{"lineNum":" 5453","line":"        }"},
{"lineNum":" 5454","line":"    }"},
{"lineNum":" 5455","line":""},
{"lineNum":" 5456","line":"    switch (errno(system.clock_gettime(clk_id, tp))) {","class":"lineCov","hits":"1","order":"404","possible_hits":"1",},
{"lineNum":" 5457","line":"        .SUCCESS => return,","class":"lineCov","hits":"1","order":"477","possible_hits":"1",},
{"lineNum":" 5458","line":"        .FAULT => unreachable,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 5459","line":"        .INVAL => return error.UnsupportedClock,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 5460","line":"        else => |err| return unexpectedErrno(err),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 5461","line":"    }"},
{"lineNum":" 5462","line":"}"},
{"lineNum":" 5463","line":""},
{"lineNum":" 5464","line":"pub fn clock_getres(clk_id: i32, res: *timespec) ClockGetTimeError!void {"},
{"lineNum":" 5465","line":"    if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 5466","line":"        var ts: timestamp_t = undefined;"},
{"lineNum":" 5467","line":"        switch (system.clock_res_get(@as(u32, @bitCast(clk_id)), &ts)) {"},
{"lineNum":" 5468","line":"            .SUCCESS => res.* = .{"},
{"lineNum":" 5469","line":"                .tv_sec = @as(i64, @intCast(ts / std.time.ns_per_s)),"},
{"lineNum":" 5470","line":"                .tv_nsec = @as(isize, @intCast(ts % std.time.ns_per_s)),"},
{"lineNum":" 5471","line":"            },"},
{"lineNum":" 5472","line":"            .INVAL => return error.UnsupportedClock,"},
{"lineNum":" 5473","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 5474","line":"        }"},
{"lineNum":" 5475","line":"        return;"},
{"lineNum":" 5476","line":"    }"},
{"lineNum":" 5477","line":""},
{"lineNum":" 5478","line":"    switch (errno(system.clock_getres(clk_id, res))) {"},
{"lineNum":" 5479","line":"        .SUCCESS => return,"},
{"lineNum":" 5480","line":"        .FAULT => unreachable,"},
{"lineNum":" 5481","line":"        .INVAL => return error.UnsupportedClock,"},
{"lineNum":" 5482","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 5483","line":"    }"},
{"lineNum":" 5484","line":"}"},
{"lineNum":" 5485","line":""},
{"lineNum":" 5486","line":"pub const SchedGetAffinityError = error{PermissionDenied} || UnexpectedError;"},
{"lineNum":" 5487","line":""},
{"lineNum":" 5488","line":"pub fn sched_getaffinity(pid: pid_t) SchedGetAffinityError!cpu_set_t {"},
{"lineNum":" 5489","line":"    var set: cpu_set_t = undefined;"},
{"lineNum":" 5490","line":"    switch (errno(system.sched_getaffinity(pid, @sizeOf(cpu_set_t), &set))) {"},
{"lineNum":" 5491","line":"        .SUCCESS => return set,"},
{"lineNum":" 5492","line":"        .FAULT => unreachable,"},
{"lineNum":" 5493","line":"        .INVAL => unreachable,"},
{"lineNum":" 5494","line":"        .SRCH => unreachable,"},
{"lineNum":" 5495","line":"        .PERM => return error.PermissionDenied,"},
{"lineNum":" 5496","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 5497","line":"    }"},
{"lineNum":" 5498","line":"}"},
{"lineNum":" 5499","line":""},
{"lineNum":" 5500","line":"/// Used to convert a slice to a null terminated slice on the stack."},
{"lineNum":" 5501","line":"/// TODO https://github.com/ziglang/zig/issues/287"},
{"lineNum":" 5502","line":"pub fn toPosixPath(file_path: []const u8) ![MAX_PATH_BYTES - 1:0]u8 {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 5503","line":"    if (std.debug.runtime_safety) assert(std.mem.indexOfScalar(u8, file_path, 0) == null);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 5504","line":"    var path_with_null: [MAX_PATH_BYTES - 1:0]u8 = undefined;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 5505","line":"    // >= rather than > to make room for the null byte"},
{"lineNum":" 5506","line":"    if (file_path.len >= MAX_PATH_BYTES) return error.NameTooLong;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 5507","line":"    @memcpy(path_with_null[0..file_path.len], file_path);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":" 5508","line":"    path_with_null[file_path.len] = 0;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":" 5509","line":"    return path_with_null;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 5510","line":"}"},
{"lineNum":" 5511","line":""},
{"lineNum":" 5512","line":"/// Whether or not error.Unexpected will print its value and a stack trace."},
{"lineNum":" 5513","line":"/// if this happens the fix is to add the error code to the corresponding"},
{"lineNum":" 5514","line":"/// switch expression, possibly introduce a new error in the error set, and"},
{"lineNum":" 5515","line":"/// send a patch to Zig."},
{"lineNum":" 5516","line":"pub const unexpected_error_tracing = builtin.zig_backend == .stage2_llvm and builtin.mode == .Debug;"},
{"lineNum":" 5517","line":""},
{"lineNum":" 5518","line":"pub const UnexpectedError = error{"},
{"lineNum":" 5519","line":"    /// The Operating System returned an undocumented error code."},
{"lineNum":" 5520","line":"    /// This error is in theory not possible, but it would be better"},
{"lineNum":" 5521","line":"    /// to handle this error than to invoke undefined behavior."},
{"lineNum":" 5522","line":"    Unexpected,"},
{"lineNum":" 5523","line":"};"},
{"lineNum":" 5524","line":""},
{"lineNum":" 5525","line":"/// Call this when you made a syscall or something that sets errno"},
{"lineNum":" 5526","line":"/// and you get an unexpected error."},
{"lineNum":" 5527","line":"pub fn unexpectedErrno(err: E) UnexpectedError {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 5528","line":"    if (unexpected_error_tracing) {"},
{"lineNum":" 5529","line":"        std.debug.print(\"unexpected errno: {d}\\n\", .{@intFromEnum(err)});","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 5530","line":"        std.debug.dumpCurrentStackTrace(null);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 5531","line":"    }"},
{"lineNum":" 5532","line":"    return error.Unexpected;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 5533","line":"}"},
{"lineNum":" 5534","line":""},
{"lineNum":" 5535","line":"pub const SigaltstackError = error{"},
{"lineNum":" 5536","line":"    /// The supplied stack size was less than MINSIGSTKSZ."},
{"lineNum":" 5537","line":"    SizeTooSmall,"},
{"lineNum":" 5538","line":""},
{"lineNum":" 5539","line":"    /// Attempted to change the signal stack while it was active."},
{"lineNum":" 5540","line":"    PermissionDenied,"},
{"lineNum":" 5541","line":"} || UnexpectedError;"},
{"lineNum":" 5542","line":""},
{"lineNum":" 5543","line":"pub fn sigaltstack(ss: ?*stack_t, old_ss: ?*stack_t) SigaltstackError!void {"},
{"lineNum":" 5544","line":"    switch (errno(system.sigaltstack(ss, old_ss))) {"},
{"lineNum":" 5545","line":"        .SUCCESS => return,"},
{"lineNum":" 5546","line":"        .FAULT => unreachable,"},
{"lineNum":" 5547","line":"        .INVAL => unreachable,"},
{"lineNum":" 5548","line":"        .NOMEM => return error.SizeTooSmall,"},
{"lineNum":" 5549","line":"        .PERM => return error.PermissionDenied,"},
{"lineNum":" 5550","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 5551","line":"    }"},
{"lineNum":" 5552","line":"}"},
{"lineNum":" 5553","line":""},
{"lineNum":" 5554","line":"/// Examine and change a signal action."},
{"lineNum":" 5555","line":"pub fn sigaction(sig: u6, noalias act: ?*const Sigaction, noalias oact: ?*Sigaction) error{OperationNotSupported}!void {","class":"lineCov","hits":"1","order":"131","possible_hits":"1",},
{"lineNum":" 5556","line":"    switch (errno(system.sigaction(sig, act, oact))) {","class":"lineCov","hits":"1","order":"132","possible_hits":"1",},
{"lineNum":" 5557","line":"        .SUCCESS => return,","class":"lineCov","hits":"1","order":"151","possible_hits":"1",},
{"lineNum":" 5558","line":"        .INVAL, .NOSYS => return error.OperationNotSupported,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 5559","line":"        else => unreachable,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 5560","line":"    }"},
{"lineNum":" 5561","line":"}"},
{"lineNum":" 5562","line":""},
{"lineNum":" 5563","line":"/// Sets the thread signal mask."},
{"lineNum":" 5564","line":"pub fn sigprocmask(flags: u32, noalias set: ?*const sigset_t, noalias oldset: ?*sigset_t) void {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 5565","line":"    switch (errno(system.sigprocmask(@bitCast(flags), set, oldset))) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 5566","line":"        .SUCCESS => return,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 5567","line":"        .FAULT => unreachable,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 5568","line":"        .INVAL => unreachable,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 5569","line":"        else => unreachable,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 5570","line":"    }"},
{"lineNum":" 5571","line":"}"},
{"lineNum":" 5572","line":""},
{"lineNum":" 5573","line":"pub const FutimensError = error{"},
{"lineNum":" 5574","line":"    /// times is NULL, or both tv_nsec values are UTIME_NOW, and either:"},
{"lineNum":" 5575","line":"    /// *  the effective user ID of the caller does not match the  owner"},
{"lineNum":" 5576","line":"    ///    of  the  file,  the  caller does not have write access to the"},
{"lineNum":" 5577","line":"    ///    file, and the caller is not privileged (Linux: does not  have"},
{"lineNum":" 5578","line":"    ///    either  the  CAP_FOWNER  or the CAP_DAC_OVERRIDE capability);"},
{"lineNum":" 5579","line":"    ///    or,"},
{"lineNum":" 5580","line":"    /// *  the file is marked immutable (see chattr(1))."},
{"lineNum":" 5581","line":"    AccessDenied,"},
{"lineNum":" 5582","line":""},
{"lineNum":" 5583","line":"    /// The caller attempted to change one or both timestamps to a value"},
{"lineNum":" 5584","line":"    /// other than the current time, or to change one of the  timestamps"},
{"lineNum":" 5585","line":"    /// to the current time while leaving the other timestamp unchanged,"},
{"lineNum":" 5586","line":"    /// (i.e., times is not NULL, neither tv_nsec  field  is  UTIME_NOW,"},
{"lineNum":" 5587","line":"    /// and neither tv_nsec field is UTIME_OMIT) and either:"},
{"lineNum":" 5588","line":"    /// *  the  caller\'s  effective  user ID does not match the owner of"},
{"lineNum":" 5589","line":"    ///    file, and the caller is not privileged (Linux: does not  have"},
{"lineNum":" 5590","line":"    ///    the CAP_FOWNER capability); or,"},
{"lineNum":" 5591","line":"    /// *  the file is marked append-only or immutable (see chattr(1))."},
{"lineNum":" 5592","line":"    PermissionDenied,"},
{"lineNum":" 5593","line":""},
{"lineNum":" 5594","line":"    ReadOnlyFileSystem,"},
{"lineNum":" 5595","line":"} || UnexpectedError;"},
{"lineNum":" 5596","line":""},
{"lineNum":" 5597","line":"pub fn futimens(fd: fd_t, times: *const [2]timespec) FutimensError!void {"},
{"lineNum":" 5598","line":"    if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":" 5599","line":"        // TODO WASI encodes `wasi.fstflags` to signify magic values"},
{"lineNum":" 5600","line":"        // similar to UTIME_NOW and UTIME_OMIT. Currently, we ignore"},
{"lineNum":" 5601","line":"        // this here, but we should really handle it somehow."},
{"lineNum":" 5602","line":"        const atim = times[0].toTimestamp();"},
{"lineNum":" 5603","line":"        const mtim = times[1].toTimestamp();"},
{"lineNum":" 5604","line":"        switch (wasi.fd_filestat_set_times(fd, atim, mtim, wasi.FILESTAT_SET_ATIM | wasi.FILESTAT_SET_MTIM)) {"},
{"lineNum":" 5605","line":"            .SUCCESS => return,"},
{"lineNum":" 5606","line":"            .ACCES => return error.AccessDenied,"},
{"lineNum":" 5607","line":"            .PERM => return error.PermissionDenied,"},
{"lineNum":" 5608","line":"            .BADF => unreachable, // always a race condition"},
{"lineNum":" 5609","line":"            .FAULT => unreachable,"},
{"lineNum":" 5610","line":"            .INVAL => unreachable,"},
{"lineNum":" 5611","line":"            .ROFS => return error.ReadOnlyFileSystem,"},
{"lineNum":" 5612","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 5613","line":"        }"},
{"lineNum":" 5614","line":"    }"},
{"lineNum":" 5615","line":""},
{"lineNum":" 5616","line":"    switch (errno(system.futimens(fd, times))) {"},
{"lineNum":" 5617","line":"        .SUCCESS => return,"},
{"lineNum":" 5618","line":"        .ACCES => return error.AccessDenied,"},
{"lineNum":" 5619","line":"        .PERM => return error.PermissionDenied,"},
{"lineNum":" 5620","line":"        .BADF => unreachable, // always a race condition"},
{"lineNum":" 5621","line":"        .FAULT => unreachable,"},
{"lineNum":" 5622","line":"        .INVAL => unreachable,"},
{"lineNum":" 5623","line":"        .ROFS => return error.ReadOnlyFileSystem,"},
{"lineNum":" 5624","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 5625","line":"    }"},
{"lineNum":" 5626","line":"}"},
{"lineNum":" 5627","line":""},
{"lineNum":" 5628","line":"pub const GetHostNameError = error{PermissionDenied} || UnexpectedError;"},
{"lineNum":" 5629","line":""},
{"lineNum":" 5630","line":"pub fn gethostname(name_buffer: *[HOST_NAME_MAX]u8) GetHostNameError![]u8 {"},
{"lineNum":" 5631","line":"    if (builtin.link_libc) {"},
{"lineNum":" 5632","line":"        switch (errno(system.gethostname(name_buffer, name_buffer.len))) {"},
{"lineNum":" 5633","line":"            .SUCCESS => return mem.sliceTo(name_buffer, 0),"},
{"lineNum":" 5634","line":"            .FAULT => unreachable,"},
{"lineNum":" 5635","line":"            .NAMETOOLONG => unreachable, // HOST_NAME_MAX prevents this"},
{"lineNum":" 5636","line":"            .PERM => return error.PermissionDenied,"},
{"lineNum":" 5637","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 5638","line":"        }"},
{"lineNum":" 5639","line":"    }"},
{"lineNum":" 5640","line":"    if (builtin.os.tag == .linux) {"},
{"lineNum":" 5641","line":"        const uts = uname();"},
{"lineNum":" 5642","line":"        const hostname = mem.sliceTo(&uts.nodename, 0);"},
{"lineNum":" 5643","line":"        const result = name_buffer[0..hostname.len];"},
{"lineNum":" 5644","line":"        @memcpy(result, hostname);"},
{"lineNum":" 5645","line":"        return result;"},
{"lineNum":" 5646","line":"    }"},
{"lineNum":" 5647","line":""},
{"lineNum":" 5648","line":"    @compileError(\"TODO implement gethostname for this OS\");"},
{"lineNum":" 5649","line":"}"},
{"lineNum":" 5650","line":""},
{"lineNum":" 5651","line":"pub fn uname() utsname {"},
{"lineNum":" 5652","line":"    var uts: utsname = undefined;"},
{"lineNum":" 5653","line":"    switch (errno(system.uname(&uts))) {"},
{"lineNum":" 5654","line":"        .SUCCESS => return uts,"},
{"lineNum":" 5655","line":"        .FAULT => unreachable,"},
{"lineNum":" 5656","line":"        else => unreachable,"},
{"lineNum":" 5657","line":"    }"},
{"lineNum":" 5658","line":"}"},
{"lineNum":" 5659","line":""},
{"lineNum":" 5660","line":"pub fn res_mkquery("},
{"lineNum":" 5661","line":"    op: u4,"},
{"lineNum":" 5662","line":"    dname: []const u8,"},
{"lineNum":" 5663","line":"    class: u8,"},
{"lineNum":" 5664","line":"    ty: u8,"},
{"lineNum":" 5665","line":"    data: []const u8,"},
{"lineNum":" 5666","line":"    newrr: ?[*]const u8,"},
{"lineNum":" 5667","line":"    buf: []u8,"},
{"lineNum":" 5668","line":") usize {"},
{"lineNum":" 5669","line":"    _ = data;"},
{"lineNum":" 5670","line":"    _ = newrr;"},
{"lineNum":" 5671","line":"    // This implementation is ported from musl libc."},
{"lineNum":" 5672","line":"    // A more idiomatic \"ziggy\" implementation would be welcome."},
{"lineNum":" 5673","line":"    var name = dname;"},
{"lineNum":" 5674","line":"    if (mem.endsWith(u8, name, \".\")) name.len -= 1;"},
{"lineNum":" 5675","line":"    assert(name.len <= 253);"},
{"lineNum":" 5676","line":"    const n = 17 + name.len + @intFromBool(name.len != 0);"},
{"lineNum":" 5677","line":""},
{"lineNum":" 5678","line":"    // Construct query template - ID will be filled later"},
{"lineNum":" 5679","line":"    var q: [280]u8 = undefined;"},
{"lineNum":" 5680","line":"    @memset(q[0..n], 0);"},
{"lineNum":" 5681","line":"    q[2] = @as(u8, op) * 8 + 1;"},
{"lineNum":" 5682","line":"    q[5] = 1;"},
{"lineNum":" 5683","line":"    @memcpy(q[13..][0..name.len], name);"},
{"lineNum":" 5684","line":"    var i: usize = 13;"},
{"lineNum":" 5685","line":"    var j: usize = undefined;"},
{"lineNum":" 5686","line":"    while (q[i] != 0) : (i = j + 1) {"},
{"lineNum":" 5687","line":"        j = i;"},
{"lineNum":" 5688","line":"        while (q[j] != 0 and q[j] != \'.\') : (j += 1) {}"},
{"lineNum":" 5689","line":"        // TODO determine the circumstances for this and whether or"},
{"lineNum":" 5690","line":"        // not this should be an error."},
{"lineNum":" 5691","line":"        if (j - i - 1 > 62) unreachable;"},
{"lineNum":" 5692","line":"        q[i - 1] = @as(u8, @intCast(j - i));"},
{"lineNum":" 5693","line":"    }"},
{"lineNum":" 5694","line":"    q[i + 1] = ty;"},
{"lineNum":" 5695","line":"    q[i + 3] = class;"},
{"lineNum":" 5696","line":""},
{"lineNum":" 5697","line":"    // Make a reasonably unpredictable id"},
{"lineNum":" 5698","line":"    var ts: timespec = undefined;"},
{"lineNum":" 5699","line":"    clock_gettime(CLOCK.REALTIME, &ts) catch {};"},
{"lineNum":" 5700","line":"    const UInt = std.meta.Int(.unsigned, @bitSizeOf(@TypeOf(ts.tv_nsec)));"},
{"lineNum":" 5701","line":"    const unsec = @as(UInt, @bitCast(ts.tv_nsec));"},
{"lineNum":" 5702","line":"    const id = @as(u32, @truncate(unsec + unsec / 65536));"},
{"lineNum":" 5703","line":"    q[0] = @as(u8, @truncate(id / 256));"},
{"lineNum":" 5704","line":"    q[1] = @as(u8, @truncate(id));"},
{"lineNum":" 5705","line":""},
{"lineNum":" 5706","line":"    @memcpy(buf[0..n], q[0..n]);"},
{"lineNum":" 5707","line":"    return n;"},
{"lineNum":" 5708","line":"}"},
{"lineNum":" 5709","line":""},
{"lineNum":" 5710","line":"pub const SendError = error{"},
{"lineNum":" 5711","line":"    /// (For UNIX domain sockets, which are identified by pathname) Write permission is  denied"},
{"lineNum":" 5712","line":"    /// on  the destination socket file, or search permission is denied for one of the"},
{"lineNum":" 5713","line":"    /// directories the path prefix.  (See path_resolution(7).)"},
{"lineNum":" 5714","line":"    /// (For UDP sockets) An attempt was made to send to a network/broadcast address as  though"},
{"lineNum":" 5715","line":"    /// it was a unicast address."},
{"lineNum":" 5716","line":"    AccessDenied,"},
{"lineNum":" 5717","line":""},
{"lineNum":" 5718","line":"    /// The socket is marked nonblocking and the requested operation would block, and"},
{"lineNum":" 5719","line":"    /// there is no global event loop configured."},
{"lineNum":" 5720","line":"    /// It\'s also possible to get this error under the following condition:"},
{"lineNum":" 5721","line":"    /// (Internet  domain datagram sockets) The socket referred to by sockfd had not previously"},
{"lineNum":" 5722","line":"    /// been bound to an address and, upon attempting to bind it to an ephemeral port,  it  was"},
{"lineNum":" 5723","line":"    /// determined that all port numbers in the ephemeral port range are currently in use.  See"},
{"lineNum":" 5724","line":"    /// the discussion of /proc/sys/net/ipv4/ip_local_port_range in ip(7)."},
{"lineNum":" 5725","line":"    WouldBlock,"},
{"lineNum":" 5726","line":""},
{"lineNum":" 5727","line":"    /// Another Fast Open is already in progress."},
{"lineNum":" 5728","line":"    FastOpenAlreadyInProgress,"},
{"lineNum":" 5729","line":""},
{"lineNum":" 5730","line":"    /// Connection reset by peer."},
{"lineNum":" 5731","line":"    ConnectionResetByPeer,"},
{"lineNum":" 5732","line":""},
{"lineNum":" 5733","line":"    /// The  socket  type requires that message be sent atomically, and the size of the message"},
{"lineNum":" 5734","line":"    /// to be sent made this impossible. The message is not transmitted."},
{"lineNum":" 5735","line":"    MessageTooBig,"},
{"lineNum":" 5736","line":""},
{"lineNum":" 5737","line":"    /// The output queue for a network interface was full.  This generally indicates  that  the"},
{"lineNum":" 5738","line":"    /// interface  has  stopped sending, but may be caused by transient congestion.  (Normally,"},
{"lineNum":" 5739","line":"    /// this does not occur in Linux.  Packets are just silently dropped when  a  device  queue"},
{"lineNum":" 5740","line":"    /// overflows.)"},
{"lineNum":" 5741","line":"    /// This is also caused when there is not enough kernel memory available."},
{"lineNum":" 5742","line":"    SystemResources,"},
{"lineNum":" 5743","line":""},
{"lineNum":" 5744","line":"    /// The  local  end  has been shut down on a connection oriented socket.  In this case, the"},
{"lineNum":" 5745","line":"    /// process will also receive a SIGPIPE unless MSG.NOSIGNAL is set."},
{"lineNum":" 5746","line":"    BrokenPipe,"},
{"lineNum":" 5747","line":""},
{"lineNum":" 5748","line":"    FileDescriptorNotASocket,"},
{"lineNum":" 5749","line":""},
{"lineNum":" 5750","line":"    /// Network is unreachable."},
{"lineNum":" 5751","line":"    NetworkUnreachable,"},
{"lineNum":" 5752","line":""},
{"lineNum":" 5753","line":"    /// The local network interface used to reach the destination is down."},
{"lineNum":" 5754","line":"    NetworkSubsystemFailed,"},
{"lineNum":" 5755","line":"} || UnexpectedError;"},
{"lineNum":" 5756","line":""},
{"lineNum":" 5757","line":"pub const SendMsgError = SendError || error{"},
{"lineNum":" 5758","line":"    /// The passed address didn\'t have the correct address family in its sa_family field."},
{"lineNum":" 5759","line":"    AddressFamilyNotSupported,"},
{"lineNum":" 5760","line":""},
{"lineNum":" 5761","line":"    /// Returned when socket is AF.UNIX and the given path has a symlink loop."},
{"lineNum":" 5762","line":"    SymLinkLoop,"},
{"lineNum":" 5763","line":""},
{"lineNum":" 5764","line":"    /// Returned when socket is AF.UNIX and the given path length exceeds `MAX_PATH_BYTES` bytes."},
{"lineNum":" 5765","line":"    NameTooLong,"},
{"lineNum":" 5766","line":""},
{"lineNum":" 5767","line":"    /// Returned when socket is AF.UNIX and the given path does not point to an existing file."},
{"lineNum":" 5768","line":"    FileNotFound,"},
{"lineNum":" 5769","line":"    NotDir,"},
{"lineNum":" 5770","line":""},
{"lineNum":" 5771","line":"    /// The socket is not connected (connection-oriented sockets only)."},
{"lineNum":" 5772","line":"    SocketNotConnected,"},
{"lineNum":" 5773","line":"    AddressNotAvailable,"},
{"lineNum":" 5774","line":"};"},
{"lineNum":" 5775","line":""},
{"lineNum":" 5776","line":"pub fn sendmsg("},
{"lineNum":" 5777","line":"    /// The file descriptor of the sending socket."},
{"lineNum":" 5778","line":"    sockfd: socket_t,"},
{"lineNum":" 5779","line":"    /// Message header and iovecs"},
{"lineNum":" 5780","line":"    msg: *const msghdr_const,"},
{"lineNum":" 5781","line":"    flags: u32,"},
{"lineNum":" 5782","line":") SendMsgError!usize {"},
{"lineNum":" 5783","line":"    while (true) {"},
{"lineNum":" 5784","line":"        const rc = system.sendmsg(sockfd, msg, flags);"},
{"lineNum":" 5785","line":"        if (builtin.os.tag == .windows) {"},
{"lineNum":" 5786","line":"            if (rc == windows.ws2_32.SOCKET_ERROR) {"},
{"lineNum":" 5787","line":"                switch (windows.ws2_32.WSAGetLastError()) {"},
{"lineNum":" 5788","line":"                    .WSAEACCES => return error.AccessDenied,"},
{"lineNum":" 5789","line":"                    .WSAEADDRNOTAVAIL => return error.AddressNotAvailable,"},
{"lineNum":" 5790","line":"                    .WSAECONNRESET => return error.ConnectionResetByPeer,"},
{"lineNum":" 5791","line":"                    .WSAEMSGSIZE => return error.MessageTooBig,"},
{"lineNum":" 5792","line":"                    .WSAENOBUFS => return error.SystemResources,"},
{"lineNum":" 5793","line":"                    .WSAENOTSOCK => return error.FileDescriptorNotASocket,"},
{"lineNum":" 5794","line":"                    .WSAEAFNOSUPPORT => return error.AddressFamilyNotSupported,"},
{"lineNum":" 5795","line":"                    .WSAEDESTADDRREQ => unreachable, // A destination address is required."},
{"lineNum":" 5796","line":"                    .WSAEFAULT => unreachable, // The lpBuffers, lpTo, lpOverlapped, lpNumberOfBytesSent, or lpCompletionRoutine parameters are not part of the user address space, or the lpTo parameter is too small."},
{"lineNum":" 5797","line":"                    .WSAEHOSTUNREACH => return error.NetworkUnreachable,"},
{"lineNum":" 5798","line":"                    // TODO: WSAEINPROGRESS, WSAEINTR"},
{"lineNum":" 5799","line":"                    .WSAEINVAL => unreachable,"},
{"lineNum":" 5800","line":"                    .WSAENETDOWN => return error.NetworkSubsystemFailed,"},
{"lineNum":" 5801","line":"                    .WSAENETRESET => return error.ConnectionResetByPeer,"},
{"lineNum":" 5802","line":"                    .WSAENETUNREACH => return error.NetworkUnreachable,"},
{"lineNum":" 5803","line":"                    .WSAENOTCONN => return error.SocketNotConnected,"},
{"lineNum":" 5804","line":"                    .WSAESHUTDOWN => unreachable, // The socket has been shut down; it is not possible to WSASendTo on a socket after shutdown has been invoked with how set to SD_SEND or SD_BOTH."},
{"lineNum":" 5805","line":"                    .WSAEWOULDBLOCK => return error.WouldBlock,"},
{"lineNum":" 5806","line":"                    .WSANOTINITIALISED => unreachable, // A successful WSAStartup call must occur before using this function."},
{"lineNum":" 5807","line":"                    else => |err| return windows.unexpectedWSAError(err),"},
{"lineNum":" 5808","line":"                }"},
{"lineNum":" 5809","line":"            } else {"},
{"lineNum":" 5810","line":"                return @as(usize, @intCast(rc));"},
{"lineNum":" 5811","line":"            }"},
{"lineNum":" 5812","line":"        } else {"},
{"lineNum":" 5813","line":"            switch (errno(rc)) {"},
{"lineNum":" 5814","line":"                .SUCCESS => return @as(usize, @intCast(rc)),"},
{"lineNum":" 5815","line":""},
{"lineNum":" 5816","line":"                .ACCES => return error.AccessDenied,"},
{"lineNum":" 5817","line":"                .AGAIN => return error.WouldBlock,"},
{"lineNum":" 5818","line":"                .ALREADY => return error.FastOpenAlreadyInProgress,"},
{"lineNum":" 5819","line":"                .BADF => unreachable, // always a race condition"},
{"lineNum":" 5820","line":"                .CONNRESET => return error.ConnectionResetByPeer,"},
{"lineNum":" 5821","line":"                .DESTADDRREQ => unreachable, // The socket is not connection-mode, and no peer address is set."},
{"lineNum":" 5822","line":"                .FAULT => unreachable, // An invalid user space address was specified for an argument."},
{"lineNum":" 5823","line":"                .INTR => continue,"},
{"lineNum":" 5824","line":"                .INVAL => unreachable, // Invalid argument passed."},
{"lineNum":" 5825","line":"                .ISCONN => unreachable, // connection-mode socket was connected already but a recipient was specified"},
{"lineNum":" 5826","line":"                .MSGSIZE => return error.MessageTooBig,"},
{"lineNum":" 5827","line":"                .NOBUFS => return error.SystemResources,"},
{"lineNum":" 5828","line":"                .NOMEM => return error.SystemResources,"},
{"lineNum":" 5829","line":"                .NOTSOCK => unreachable, // The file descriptor sockfd does not refer to a socket."},
{"lineNum":" 5830","line":"                .OPNOTSUPP => unreachable, // Some bit in the flags argument is inappropriate for the socket type."},
{"lineNum":" 5831","line":"                .PIPE => return error.BrokenPipe,"},
{"lineNum":" 5832","line":"                .AFNOSUPPORT => return error.AddressFamilyNotSupported,"},
{"lineNum":" 5833","line":"                .LOOP => return error.SymLinkLoop,"},
{"lineNum":" 5834","line":"                .NAMETOOLONG => return error.NameTooLong,"},
{"lineNum":" 5835","line":"                .NOENT => return error.FileNotFound,"},
{"lineNum":" 5836","line":"                .NOTDIR => return error.NotDir,"},
{"lineNum":" 5837","line":"                .HOSTUNREACH => return error.NetworkUnreachable,"},
{"lineNum":" 5838","line":"                .NETUNREACH => return error.NetworkUnreachable,"},
{"lineNum":" 5839","line":"                .NOTCONN => return error.SocketNotConnected,"},
{"lineNum":" 5840","line":"                .NETDOWN => return error.NetworkSubsystemFailed,"},
{"lineNum":" 5841","line":"                else => |err| return unexpectedErrno(err),"},
{"lineNum":" 5842","line":"            }"},
{"lineNum":" 5843","line":"        }"},
{"lineNum":" 5844","line":"    }"},
{"lineNum":" 5845","line":"}"},
{"lineNum":" 5846","line":""},
{"lineNum":" 5847","line":"pub const SendToError = SendMsgError || error{"},
{"lineNum":" 5848","line":"    /// The destination address is not reachable by the bound address."},
{"lineNum":" 5849","line":"    UnreachableAddress,"},
{"lineNum":" 5850","line":"};"},
{"lineNum":" 5851","line":""},
{"lineNum":" 5852","line":"/// Transmit a message to another socket."},
{"lineNum":" 5853","line":"///"},
{"lineNum":" 5854","line":"/// The `sendto` call may be used only when the socket is in a connected state (so that the intended"},
{"lineNum":" 5855","line":"/// recipient  is  known). The  following call"},
{"lineNum":" 5856","line":"///"},
{"lineNum":" 5857","line":"///     send(sockfd, buf, len, flags);"},
{"lineNum":" 5858","line":"///"},
{"lineNum":" 5859","line":"/// is equivalent to"},
{"lineNum":" 5860","line":"///"},
{"lineNum":" 5861","line":"///     sendto(sockfd, buf, len, flags, NULL, 0);"},
{"lineNum":" 5862","line":"///"},
{"lineNum":" 5863","line":"/// If  sendto()  is used on a connection-mode (`SOCK.STREAM`, `SOCK.SEQPACKET`) socket, the arguments"},
{"lineNum":" 5864","line":"/// `dest_addr` and `addrlen` are asserted to be `null` and `0` respectively, and asserted"},
{"lineNum":" 5865","line":"/// that the socket was actually connected."},
{"lineNum":" 5866","line":"/// Otherwise, the address of the target is given by `dest_addr` with `addrlen` specifying  its  size."},
{"lineNum":" 5867","line":"///"},
{"lineNum":" 5868","line":"/// If the message is too long to pass atomically through the underlying protocol,"},
{"lineNum":" 5869","line":"/// `SendError.MessageTooBig` is returned, and the message is not transmitted."},
{"lineNum":" 5870","line":"///"},
{"lineNum":" 5871","line":"/// There is no  indication  of  failure  to  deliver."},
{"lineNum":" 5872","line":"///"},
{"lineNum":" 5873","line":"/// When the message does not fit into the send buffer of  the  socket,  `sendto`  normally  blocks,"},
{"lineNum":" 5874","line":"/// unless  the socket has been placed in nonblocking I/O mode.  In nonblocking mode it would fail"},
{"lineNum":" 5875","line":"/// with `SendError.WouldBlock`.  The `select` call may be used  to  determine when it is"},
{"lineNum":" 5876","line":"/// possible to send more data."},
{"lineNum":" 5877","line":"pub fn sendto("},
{"lineNum":" 5878","line":"    /// The file descriptor of the sending socket."},
{"lineNum":" 5879","line":"    sockfd: socket_t,"},
{"lineNum":" 5880","line":"    /// Message to send."},
{"lineNum":" 5881","line":"    buf: []const u8,"},
{"lineNum":" 5882","line":"    flags: u32,"},
{"lineNum":" 5883","line":"    dest_addr: ?*const sockaddr,"},
{"lineNum":" 5884","line":"    addrlen: socklen_t,"},
{"lineNum":" 5885","line":") SendToError!usize {"},
{"lineNum":" 5886","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 5887","line":"        switch (windows.sendto(sockfd, buf.ptr, buf.len, flags, dest_addr, addrlen)) {"},
{"lineNum":" 5888","line":"            windows.ws2_32.SOCKET_ERROR => switch (windows.ws2_32.WSAGetLastError()) {"},
{"lineNum":" 5889","line":"                .WSAEACCES => return error.AccessDenied,"},
{"lineNum":" 5890","line":"                .WSAEADDRNOTAVAIL => return error.AddressNotAvailable,"},
{"lineNum":" 5891","line":"                .WSAECONNRESET => return error.ConnectionResetByPeer,"},
{"lineNum":" 5892","line":"                .WSAEMSGSIZE => return error.MessageTooBig,"},
{"lineNum":" 5893","line":"                .WSAENOBUFS => return error.SystemResources,"},
{"lineNum":" 5894","line":"                .WSAENOTSOCK => return error.FileDescriptorNotASocket,"},
{"lineNum":" 5895","line":"                .WSAEAFNOSUPPORT => return error.AddressFamilyNotSupported,"},
{"lineNum":" 5896","line":"                .WSAEDESTADDRREQ => unreachable, // A destination address is required."},
{"lineNum":" 5897","line":"                .WSAEFAULT => unreachable, // The lpBuffers, lpTo, lpOverlapped, lpNumberOfBytesSent, or lpCompletionRoutine parameters are not part of the user address space, or the lpTo parameter is too small."},
{"lineNum":" 5898","line":"                .WSAEHOSTUNREACH => return error.NetworkUnreachable,"},
{"lineNum":" 5899","line":"                // TODO: WSAEINPROGRESS, WSAEINTR"},
{"lineNum":" 5900","line":"                .WSAEINVAL => unreachable,"},
{"lineNum":" 5901","line":"                .WSAENETDOWN => return error.NetworkSubsystemFailed,"},
{"lineNum":" 5902","line":"                .WSAENETRESET => return error.ConnectionResetByPeer,"},
{"lineNum":" 5903","line":"                .WSAENETUNREACH => return error.NetworkUnreachable,"},
{"lineNum":" 5904","line":"                .WSAENOTCONN => return error.SocketNotConnected,"},
{"lineNum":" 5905","line":"                .WSAESHUTDOWN => unreachable, // The socket has been shut down; it is not possible to WSASendTo on a socket after shutdown has been invoked with how set to SD_SEND or SD_BOTH."},
{"lineNum":" 5906","line":"                .WSAEWOULDBLOCK => return error.WouldBlock,"},
{"lineNum":" 5907","line":"                .WSANOTINITIALISED => unreachable, // A successful WSAStartup call must occur before using this function."},
{"lineNum":" 5908","line":"                else => |err| return windows.unexpectedWSAError(err),"},
{"lineNum":" 5909","line":"            },"},
{"lineNum":" 5910","line":"            else => |rc| return @as(usize, @intCast(rc)),"},
{"lineNum":" 5911","line":"        }"},
{"lineNum":" 5912","line":"    }"},
{"lineNum":" 5913","line":"    while (true) {"},
{"lineNum":" 5914","line":"        const rc = system.sendto(sockfd, buf.ptr, buf.len, flags, dest_addr, addrlen);"},
{"lineNum":" 5915","line":"        switch (errno(rc)) {"},
{"lineNum":" 5916","line":"            .SUCCESS => return @as(usize, @intCast(rc)),"},
{"lineNum":" 5917","line":""},
{"lineNum":" 5918","line":"            .ACCES => return error.AccessDenied,"},
{"lineNum":" 5919","line":"            .AGAIN => return error.WouldBlock,"},
{"lineNum":" 5920","line":"            .ALREADY => return error.FastOpenAlreadyInProgress,"},
{"lineNum":" 5921","line":"            .BADF => unreachable, // always a race condition"},
{"lineNum":" 5922","line":"            .CONNRESET => return error.ConnectionResetByPeer,"},
{"lineNum":" 5923","line":"            .DESTADDRREQ => unreachable, // The socket is not connection-mode, and no peer address is set."},
{"lineNum":" 5924","line":"            .FAULT => unreachable, // An invalid user space address was specified for an argument."},
{"lineNum":" 5925","line":"            .INTR => continue,"},
{"lineNum":" 5926","line":"            .INVAL => return error.UnreachableAddress,"},
{"lineNum":" 5927","line":"            .ISCONN => unreachable, // connection-mode socket was connected already but a recipient was specified"},
{"lineNum":" 5928","line":"            .MSGSIZE => return error.MessageTooBig,"},
{"lineNum":" 5929","line":"            .NOBUFS => return error.SystemResources,"},
{"lineNum":" 5930","line":"            .NOMEM => return error.SystemResources,"},
{"lineNum":" 5931","line":"            .NOTSOCK => unreachable, // The file descriptor sockfd does not refer to a socket."},
{"lineNum":" 5932","line":"            .OPNOTSUPP => unreachable, // Some bit in the flags argument is inappropriate for the socket type."},
{"lineNum":" 5933","line":"            .PIPE => return error.BrokenPipe,"},
{"lineNum":" 5934","line":"            .AFNOSUPPORT => return error.AddressFamilyNotSupported,"},
{"lineNum":" 5935","line":"            .LOOP => return error.SymLinkLoop,"},
{"lineNum":" 5936","line":"            .NAMETOOLONG => return error.NameTooLong,"},
{"lineNum":" 5937","line":"            .NOENT => return error.FileNotFound,"},
{"lineNum":" 5938","line":"            .NOTDIR => return error.NotDir,"},
{"lineNum":" 5939","line":"            .HOSTUNREACH => return error.NetworkUnreachable,"},
{"lineNum":" 5940","line":"            .NETUNREACH => return error.NetworkUnreachable,"},
{"lineNum":" 5941","line":"            .NOTCONN => return error.SocketNotConnected,"},
{"lineNum":" 5942","line":"            .NETDOWN => return error.NetworkSubsystemFailed,"},
{"lineNum":" 5943","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 5944","line":"        }"},
{"lineNum":" 5945","line":"    }"},
{"lineNum":" 5946","line":"}"},
{"lineNum":" 5947","line":""},
{"lineNum":" 5948","line":"/// Transmit a message to another socket."},
{"lineNum":" 5949","line":"///"},
{"lineNum":" 5950","line":"/// The `send` call may be used only when the socket is in a connected state (so that the intended"},
{"lineNum":" 5951","line":"/// recipient  is  known).   The  only  difference  between `send` and `write` is the presence of"},
{"lineNum":" 5952","line":"/// flags.  With a zero flags argument, `send` is equivalent to  `write`.   Also,  the  following"},
{"lineNum":" 5953","line":"/// call"},
{"lineNum":" 5954","line":"///"},
{"lineNum":" 5955","line":"///     send(sockfd, buf, len, flags);"},
{"lineNum":" 5956","line":"///"},
{"lineNum":" 5957","line":"/// is equivalent to"},
{"lineNum":" 5958","line":"///"},
{"lineNum":" 5959","line":"///     sendto(sockfd, buf, len, flags, NULL, 0);"},
{"lineNum":" 5960","line":"///"},
{"lineNum":" 5961","line":"/// There is no  indication  of  failure  to  deliver."},
{"lineNum":" 5962","line":"///"},
{"lineNum":" 5963","line":"/// When the message does not fit into the send buffer of  the  socket,  `send`  normally  blocks,"},
{"lineNum":" 5964","line":"/// unless  the socket has been placed in nonblocking I/O mode.  In nonblocking mode it would fail"},
{"lineNum":" 5965","line":"/// with `SendError.WouldBlock`.  The `select` call may be used  to  determine when it is"},
{"lineNum":" 5966","line":"/// possible to send more data."},
{"lineNum":" 5967","line":"pub fn send("},
{"lineNum":" 5968","line":"    /// The file descriptor of the sending socket."},
{"lineNum":" 5969","line":"    sockfd: socket_t,"},
{"lineNum":" 5970","line":"    buf: []const u8,"},
{"lineNum":" 5971","line":"    flags: u32,"},
{"lineNum":" 5972","line":") SendError!usize {"},
{"lineNum":" 5973","line":"    return sendto(sockfd, buf, flags, null, 0) catch |err| switch (err) {"},
{"lineNum":" 5974","line":"        error.AddressFamilyNotSupported => unreachable,"},
{"lineNum":" 5975","line":"        error.SymLinkLoop => unreachable,"},
{"lineNum":" 5976","line":"        error.NameTooLong => unreachable,"},
{"lineNum":" 5977","line":"        error.FileNotFound => unreachable,"},
{"lineNum":" 5978","line":"        error.NotDir => unreachable,"},
{"lineNum":" 5979","line":"        error.NetworkUnreachable => unreachable,"},
{"lineNum":" 5980","line":"        error.AddressNotAvailable => unreachable,"},
{"lineNum":" 5981","line":"        error.SocketNotConnected => unreachable,"},
{"lineNum":" 5982","line":"        error.UnreachableAddress => unreachable,"},
{"lineNum":" 5983","line":"        else => |e| return e,"},
{"lineNum":" 5984","line":"    };"},
{"lineNum":" 5985","line":"}"},
{"lineNum":" 5986","line":""},
{"lineNum":" 5987","line":"pub const SendFileError = PReadError || WriteError || SendError;"},
{"lineNum":" 5988","line":""},
{"lineNum":" 5989","line":"fn count_iovec_bytes(iovs: []const iovec_const) usize {"},
{"lineNum":" 5990","line":"    var count: usize = 0;"},
{"lineNum":" 5991","line":"    for (iovs) |iov| {"},
{"lineNum":" 5992","line":"        count += iov.iov_len;"},
{"lineNum":" 5993","line":"    }"},
{"lineNum":" 5994","line":"    return count;"},
{"lineNum":" 5995","line":"}"},
{"lineNum":" 5996","line":""},
{"lineNum":" 5997","line":"/// Transfer data between file descriptors, with optional headers and trailers."},
{"lineNum":" 5998","line":"/// Returns the number of bytes written, which can be zero."},
{"lineNum":" 5999","line":"///"},
{"lineNum":" 6000","line":"/// The `sendfile` call copies `in_len` bytes from one file descriptor to another. When possible,"},
{"lineNum":" 6001","line":"/// this is done within the operating system kernel, which can provide better performance"},
{"lineNum":" 6002","line":"/// characteristics than transferring data from kernel to user space and back, such as with"},
{"lineNum":" 6003","line":"/// `read` and `write` calls. When `in_len` is `0`, it means to copy until the end of the input file has been"},
{"lineNum":" 6004","line":"/// reached. Note, however, that partial writes are still possible in this case."},
{"lineNum":" 6005","line":"///"},
{"lineNum":" 6006","line":"/// `in_fd` must be a file descriptor opened for reading, and `out_fd` must be a file descriptor"},
{"lineNum":" 6007","line":"/// opened for writing. They may be any kind of file descriptor; however, if `in_fd` is not a regular"},
{"lineNum":" 6008","line":"/// file system file, it may cause this function to fall back to calling `read` and `write`, in which case"},
{"lineNum":" 6009","line":"/// atomicity guarantees no longer apply."},
{"lineNum":" 6010","line":"///"},
{"lineNum":" 6011","line":"/// Copying begins reading at `in_offset`. The input file descriptor seek position is ignored and not updated."},
{"lineNum":" 6012","line":"/// If the output file descriptor has a seek position, it is updated as bytes are written. When"},
{"lineNum":" 6013","line":"/// `in_offset` is past the end of the input file, it successfully reads 0 bytes."},
{"lineNum":" 6014","line":"///"},
{"lineNum":" 6015","line":"/// `flags` has different meanings per operating system; refer to the respective man pages."},
{"lineNum":" 6016","line":"///"},
{"lineNum":" 6017","line":"/// These systems support atomically sending everything, including headers and trailers:"},
{"lineNum":" 6018","line":"/// * macOS"},
{"lineNum":" 6019","line":"/// * FreeBSD"},
{"lineNum":" 6020","line":"///"},
{"lineNum":" 6021","line":"/// These systems support in-kernel data copying, but headers and trailers are not sent atomically:"},
{"lineNum":" 6022","line":"/// * Linux"},
{"lineNum":" 6023","line":"///"},
{"lineNum":" 6024","line":"/// Other systems fall back to calling `read` / `write`."},
{"lineNum":" 6025","line":"///"},
{"lineNum":" 6026","line":"/// Linux has a limit on how many bytes may be transferred in one `sendfile` call, which is `0x7ffff000`"},
{"lineNum":" 6027","line":"/// on both 64-bit and 32-bit systems. This is due to using a signed C int as the return value, as"},
{"lineNum":" 6028","line":"/// well as stuffing the errno codes into the last `4096` values. This is noted on the `sendfile` man page."},
{"lineNum":" 6029","line":"/// The limit on Darwin is `0x7fffffff`, trying to write more than that returns EINVAL."},
{"lineNum":" 6030","line":"/// The corresponding POSIX limit on this is `math.maxInt(isize)`."},
{"lineNum":" 6031","line":"pub fn sendfile("},
{"lineNum":" 6032","line":"    out_fd: fd_t,"},
{"lineNum":" 6033","line":"    in_fd: fd_t,"},
{"lineNum":" 6034","line":"    in_offset: u64,"},
{"lineNum":" 6035","line":"    in_len: u64,"},
{"lineNum":" 6036","line":"    headers: []const iovec_const,"},
{"lineNum":" 6037","line":"    trailers: []const iovec_const,"},
{"lineNum":" 6038","line":"    flags: u32,"},
{"lineNum":" 6039","line":") SendFileError!usize {"},
{"lineNum":" 6040","line":"    var header_done = false;"},
{"lineNum":" 6041","line":"    var total_written: usize = 0;"},
{"lineNum":" 6042","line":""},
{"lineNum":" 6043","line":"    // Prevents EOVERFLOW."},
{"lineNum":" 6044","line":"    const size_t = std.meta.Int(.unsigned, @typeInfo(usize).Int.bits - 1);"},
{"lineNum":" 6045","line":"    const max_count = switch (builtin.os.tag) {"},
{"lineNum":" 6046","line":"        .linux => 0x7ffff000,"},
{"lineNum":" 6047","line":"        .macos, .ios, .watchos, .tvos => math.maxInt(i32),"},
{"lineNum":" 6048","line":"        else => math.maxInt(size_t),"},
{"lineNum":" 6049","line":"    };"},
{"lineNum":" 6050","line":""},
{"lineNum":" 6051","line":"    switch (builtin.os.tag) {"},
{"lineNum":" 6052","line":"        .linux => sf: {"},
{"lineNum":" 6053","line":"            // sendfile() first appeared in Linux 2.2, glibc 2.1."},
{"lineNum":" 6054","line":"            const call_sf = comptime if (builtin.link_libc)"},
{"lineNum":" 6055","line":"                std.c.versionCheck(.{ .major = 2, .minor = 1, .patch = 0 }).ok"},
{"lineNum":" 6056","line":"            else"},
{"lineNum":" 6057","line":"                builtin.os.version_range.linux.range.max.order(.{ .major = 2, .minor = 2, .patch = 0 }) != .lt;"},
{"lineNum":" 6058","line":"            if (!call_sf) break :sf;"},
{"lineNum":" 6059","line":""},
{"lineNum":" 6060","line":"            if (headers.len != 0) {"},
{"lineNum":" 6061","line":"                const amt = try writev(out_fd, headers);"},
{"lineNum":" 6062","line":"                total_written += amt;"},
{"lineNum":" 6063","line":"                if (amt < count_iovec_bytes(headers)) return total_written;"},
{"lineNum":" 6064","line":"                header_done = true;"},
{"lineNum":" 6065","line":"            }"},
{"lineNum":" 6066","line":""},
{"lineNum":" 6067","line":"            // Here we match BSD behavior, making a zero count value send as many bytes as possible."},
{"lineNum":" 6068","line":"            const adjusted_count_tmp = if (in_len == 0) max_count else @min(in_len, @as(size_t, max_count));"},
{"lineNum":" 6069","line":"            // TODO we should not need this cast; improve return type of @min"},
{"lineNum":" 6070","line":"            const adjusted_count = @as(usize, @intCast(adjusted_count_tmp));"},
{"lineNum":" 6071","line":""},
{"lineNum":" 6072","line":"            const sendfile_sym = if (lfs64_abi) system.sendfile64 else system.sendfile;"},
{"lineNum":" 6073","line":""},
{"lineNum":" 6074","line":"            while (true) {"},
{"lineNum":" 6075","line":"                var offset: off_t = @as(off_t, @bitCast(in_offset));"},
{"lineNum":" 6076","line":"                const rc = sendfile_sym(out_fd, in_fd, &offset, adjusted_count);"},
{"lineNum":" 6077","line":"                switch (errno(rc)) {"},
{"lineNum":" 6078","line":"                    .SUCCESS => {"},
{"lineNum":" 6079","line":"                        const amt = @as(usize, @bitCast(rc));"},
{"lineNum":" 6080","line":"                        total_written += amt;"},
{"lineNum":" 6081","line":"                        if (in_len == 0 and amt == 0) {"},
{"lineNum":" 6082","line":"                            // We have detected EOF from `in_fd`."},
{"lineNum":" 6083","line":"                            break;"},
{"lineNum":" 6084","line":"                        } else if (amt < in_len) {"},
{"lineNum":" 6085","line":"                            return total_written;"},
{"lineNum":" 6086","line":"                        } else {"},
{"lineNum":" 6087","line":"                            break;"},
{"lineNum":" 6088","line":"                        }"},
{"lineNum":" 6089","line":"                    },"},
{"lineNum":" 6090","line":""},
{"lineNum":" 6091","line":"                    .BADF => unreachable, // Always a race condition."},
{"lineNum":" 6092","line":"                    .FAULT => unreachable, // Segmentation fault."},
{"lineNum":" 6093","line":"                    .OVERFLOW => unreachable, // We avoid passing too large of a `count`."},
{"lineNum":" 6094","line":"                    .NOTCONN => return error.BrokenPipe, // `out_fd` is an unconnected socket"},
{"lineNum":" 6095","line":""},
{"lineNum":" 6096","line":"                    .INVAL, .NOSYS => {"},
{"lineNum":" 6097","line":"                        // EINVAL could be any of the following situations:"},
{"lineNum":" 6098","line":"                        // * Descriptor is not valid or locked"},
{"lineNum":" 6099","line":"                        // * an mmap(2)-like operation is  not  available  for in_fd"},
{"lineNum":" 6100","line":"                        // * count is negative"},
{"lineNum":" 6101","line":"                        // * out_fd has the O.APPEND flag set"},
{"lineNum":" 6102","line":"                        // Because of the \"mmap(2)-like operation\" possibility, we fall back to doing read/write"},
{"lineNum":" 6103","line":"                        // manually, the same as ENOSYS."},
{"lineNum":" 6104","line":"                        break :sf;"},
{"lineNum":" 6105","line":"                    },"},
{"lineNum":" 6106","line":"                    .AGAIN => if (std.event.Loop.instance) |loop| {"},
{"lineNum":" 6107","line":"                        loop.waitUntilFdWritable(out_fd);"},
{"lineNum":" 6108","line":"                        continue;"},
{"lineNum":" 6109","line":"                    } else {"},
{"lineNum":" 6110","line":"                        return error.WouldBlock;"},
{"lineNum":" 6111","line":"                    },"},
{"lineNum":" 6112","line":"                    .IO => return error.InputOutput,"},
{"lineNum":" 6113","line":"                    .PIPE => return error.BrokenPipe,"},
{"lineNum":" 6114","line":"                    .NOMEM => return error.SystemResources,"},
{"lineNum":" 6115","line":"                    .NXIO => return error.Unseekable,"},
{"lineNum":" 6116","line":"                    .SPIPE => return error.Unseekable,"},
{"lineNum":" 6117","line":"                    else => |err| {"},
{"lineNum":" 6118","line":"                        unexpectedErrno(err) catch {};"},
{"lineNum":" 6119","line":"                        break :sf;"},
{"lineNum":" 6120","line":"                    },"},
{"lineNum":" 6121","line":"                }"},
{"lineNum":" 6122","line":"            }"},
{"lineNum":" 6123","line":""},
{"lineNum":" 6124","line":"            if (trailers.len != 0) {"},
{"lineNum":" 6125","line":"                total_written += try writev(out_fd, trailers);"},
{"lineNum":" 6126","line":"            }"},
{"lineNum":" 6127","line":""},
{"lineNum":" 6128","line":"            return total_written;"},
{"lineNum":" 6129","line":"        },"},
{"lineNum":" 6130","line":"        .freebsd => sf: {"},
{"lineNum":" 6131","line":"            var hdtr_data: std.c.sf_hdtr = undefined;"},
{"lineNum":" 6132","line":"            var hdtr: ?*std.c.sf_hdtr = null;"},
{"lineNum":" 6133","line":"            if (headers.len != 0 or trailers.len != 0) {"},
{"lineNum":" 6134","line":"                // Here we carefully avoid `@intCast` by returning partial writes when"},
{"lineNum":" 6135","line":"                // too many io vectors are provided."},
{"lineNum":" 6136","line":"                const hdr_cnt = math.cast(u31, headers.len) orelse math.maxInt(u31);"},
{"lineNum":" 6137","line":"                if (headers.len > hdr_cnt) return writev(out_fd, headers);"},
{"lineNum":" 6138","line":""},
{"lineNum":" 6139","line":"                const trl_cnt = math.cast(u31, trailers.len) orelse math.maxInt(u31);"},
{"lineNum":" 6140","line":""},
{"lineNum":" 6141","line":"                hdtr_data = std.c.sf_hdtr{"},
{"lineNum":" 6142","line":"                    .headers = headers.ptr,"},
{"lineNum":" 6143","line":"                    .hdr_cnt = hdr_cnt,"},
{"lineNum":" 6144","line":"                    .trailers = trailers.ptr,"},
{"lineNum":" 6145","line":"                    .trl_cnt = trl_cnt,"},
{"lineNum":" 6146","line":"                };"},
{"lineNum":" 6147","line":"                hdtr = &hdtr_data;"},
{"lineNum":" 6148","line":"            }"},
{"lineNum":" 6149","line":""},
{"lineNum":" 6150","line":"            const adjusted_count = @min(in_len, max_count);"},
{"lineNum":" 6151","line":""},
{"lineNum":" 6152","line":"            while (true) {"},
{"lineNum":" 6153","line":"                var sbytes: off_t = undefined;"},
{"lineNum":" 6154","line":"                const offset = @as(off_t, @bitCast(in_offset));"},
{"lineNum":" 6155","line":"                const err = errno(system.sendfile(in_fd, out_fd, offset, adjusted_count, hdtr, &sbytes, flags));"},
{"lineNum":" 6156","line":"                const amt = @as(usize, @bitCast(sbytes));"},
{"lineNum":" 6157","line":"                switch (err) {"},
{"lineNum":" 6158","line":"                    .SUCCESS => return amt,"},
{"lineNum":" 6159","line":""},
{"lineNum":" 6160","line":"                    .BADF => unreachable, // Always a race condition."},
{"lineNum":" 6161","line":"                    .FAULT => unreachable, // Segmentation fault."},
{"lineNum":" 6162","line":"                    .NOTCONN => return error.BrokenPipe, // `out_fd` is an unconnected socket"},
{"lineNum":" 6163","line":""},
{"lineNum":" 6164","line":"                    .INVAL, .OPNOTSUPP, .NOTSOCK, .NOSYS => {"},
{"lineNum":" 6165","line":"                        // EINVAL could be any of the following situations:"},
{"lineNum":" 6166","line":"                        // * The fd argument is not a regular file."},
{"lineNum":" 6167","line":"                        // * The s argument is not a SOCK.STREAM type socket."},
{"lineNum":" 6168","line":"                        // * The offset argument is negative."},
{"lineNum":" 6169","line":"                        // Because of some of these possibilities, we fall back to doing read/write"},
{"lineNum":" 6170","line":"                        // manually, the same as ENOSYS."},
{"lineNum":" 6171","line":"                        break :sf;"},
{"lineNum":" 6172","line":"                    },"},
{"lineNum":" 6173","line":""},
{"lineNum":" 6174","line":"                    .INTR => if (amt != 0) return amt else continue,"},
{"lineNum":" 6175","line":""},
{"lineNum":" 6176","line":"                    .AGAIN => if (amt != 0) {"},
{"lineNum":" 6177","line":"                        return amt;"},
{"lineNum":" 6178","line":"                    } else if (std.event.Loop.instance) |loop| {"},
{"lineNum":" 6179","line":"                        loop.waitUntilFdWritable(out_fd);"},
{"lineNum":" 6180","line":"                        continue;"},
{"lineNum":" 6181","line":"                    } else {"},
{"lineNum":" 6182","line":"                        return error.WouldBlock;"},
{"lineNum":" 6183","line":"                    },"},
{"lineNum":" 6184","line":""},
{"lineNum":" 6185","line":"                    .BUSY => if (amt != 0) {"},
{"lineNum":" 6186","line":"                        return amt;"},
{"lineNum":" 6187","line":"                    } else if (std.event.Loop.instance) |loop| {"},
{"lineNum":" 6188","line":"                        loop.waitUntilFdReadable(in_fd);"},
{"lineNum":" 6189","line":"                        continue;"},
{"lineNum":" 6190","line":"                    } else {"},
{"lineNum":" 6191","line":"                        return error.WouldBlock;"},
{"lineNum":" 6192","line":"                    },"},
{"lineNum":" 6193","line":""},
{"lineNum":" 6194","line":"                    .IO => return error.InputOutput,"},
{"lineNum":" 6195","line":"                    .NOBUFS => return error.SystemResources,"},
{"lineNum":" 6196","line":"                    .PIPE => return error.BrokenPipe,"},
{"lineNum":" 6197","line":""},
{"lineNum":" 6198","line":"                    else => {"},
{"lineNum":" 6199","line":"                        unexpectedErrno(err) catch {};"},
{"lineNum":" 6200","line":"                        if (amt != 0) {"},
{"lineNum":" 6201","line":"                            return amt;"},
{"lineNum":" 6202","line":"                        } else {"},
{"lineNum":" 6203","line":"                            break :sf;"},
{"lineNum":" 6204","line":"                        }"},
{"lineNum":" 6205","line":"                    },"},
{"lineNum":" 6206","line":"                }"},
{"lineNum":" 6207","line":"            }"},
{"lineNum":" 6208","line":"        },"},
{"lineNum":" 6209","line":"        .macos, .ios, .tvos, .watchos => sf: {"},
{"lineNum":" 6210","line":"            var hdtr_data: std.c.sf_hdtr = undefined;"},
{"lineNum":" 6211","line":"            var hdtr: ?*std.c.sf_hdtr = null;"},
{"lineNum":" 6212","line":"            if (headers.len != 0 or trailers.len != 0) {"},
{"lineNum":" 6213","line":"                // Here we carefully avoid `@intCast` by returning partial writes when"},
{"lineNum":" 6214","line":"                // too many io vectors are provided."},
{"lineNum":" 6215","line":"                const hdr_cnt = math.cast(u31, headers.len) orelse math.maxInt(u31);"},
{"lineNum":" 6216","line":"                if (headers.len > hdr_cnt) return writev(out_fd, headers);"},
{"lineNum":" 6217","line":""},
{"lineNum":" 6218","line":"                const trl_cnt = math.cast(u31, trailers.len) orelse math.maxInt(u31);"},
{"lineNum":" 6219","line":""},
{"lineNum":" 6220","line":"                hdtr_data = std.c.sf_hdtr{"},
{"lineNum":" 6221","line":"                    .headers = headers.ptr,"},
{"lineNum":" 6222","line":"                    .hdr_cnt = hdr_cnt,"},
{"lineNum":" 6223","line":"                    .trailers = trailers.ptr,"},
{"lineNum":" 6224","line":"                    .trl_cnt = trl_cnt,"},
{"lineNum":" 6225","line":"                };"},
{"lineNum":" 6226","line":"                hdtr = &hdtr_data;"},
{"lineNum":" 6227","line":"            }"},
{"lineNum":" 6228","line":""},
{"lineNum":" 6229","line":"            const adjusted_count_temporary = @min(in_len, @as(u63, max_count));"},
{"lineNum":" 6230","line":"            // TODO we should not need this int cast; improve the return type of `@min`"},
{"lineNum":" 6231","line":"            const adjusted_count = @as(u63, @intCast(adjusted_count_temporary));"},
{"lineNum":" 6232","line":""},
{"lineNum":" 6233","line":"            while (true) {"},
{"lineNum":" 6234","line":"                var sbytes: off_t = adjusted_count;"},
{"lineNum":" 6235","line":"                const signed_offset = @as(i64, @bitCast(in_offset));"},
{"lineNum":" 6236","line":"                const err = errno(system.sendfile(in_fd, out_fd, signed_offset, &sbytes, hdtr, flags));"},
{"lineNum":" 6237","line":"                const amt = @as(usize, @bitCast(sbytes));"},
{"lineNum":" 6238","line":"                switch (err) {"},
{"lineNum":" 6239","line":"                    .SUCCESS => return amt,"},
{"lineNum":" 6240","line":""},
{"lineNum":" 6241","line":"                    .BADF => unreachable, // Always a race condition."},
{"lineNum":" 6242","line":"                    .FAULT => unreachable, // Segmentation fault."},
{"lineNum":" 6243","line":"                    .INVAL => unreachable,"},
{"lineNum":" 6244","line":"                    .NOTCONN => return error.BrokenPipe, // `out_fd` is an unconnected socket"},
{"lineNum":" 6245","line":""},
{"lineNum":" 6246","line":"                    .OPNOTSUPP, .NOTSOCK, .NOSYS => break :sf,"},
{"lineNum":" 6247","line":""},
{"lineNum":" 6248","line":"                    .INTR => if (amt != 0) return amt else continue,"},
{"lineNum":" 6249","line":""},
{"lineNum":" 6250","line":"                    .AGAIN => if (amt != 0) {"},
{"lineNum":" 6251","line":"                        return amt;"},
{"lineNum":" 6252","line":"                    } else if (std.event.Loop.instance) |loop| {"},
{"lineNum":" 6253","line":"                        loop.waitUntilFdWritable(out_fd);"},
{"lineNum":" 6254","line":"                        continue;"},
{"lineNum":" 6255","line":"                    } else {"},
{"lineNum":" 6256","line":"                        return error.WouldBlock;"},
{"lineNum":" 6257","line":"                    },"},
{"lineNum":" 6258","line":""},
{"lineNum":" 6259","line":"                    .IO => return error.InputOutput,"},
{"lineNum":" 6260","line":"                    .PIPE => return error.BrokenPipe,"},
{"lineNum":" 6261","line":""},
{"lineNum":" 6262","line":"                    else => {"},
{"lineNum":" 6263","line":"                        unexpectedErrno(err) catch {};"},
{"lineNum":" 6264","line":"                        if (amt != 0) {"},
{"lineNum":" 6265","line":"                            return amt;"},
{"lineNum":" 6266","line":"                        } else {"},
{"lineNum":" 6267","line":"                            break :sf;"},
{"lineNum":" 6268","line":"                        }"},
{"lineNum":" 6269","line":"                    },"},
{"lineNum":" 6270","line":"                }"},
{"lineNum":" 6271","line":"            }"},
{"lineNum":" 6272","line":"        },"},
{"lineNum":" 6273","line":"        else => {}, // fall back to read/write"},
{"lineNum":" 6274","line":"    }"},
{"lineNum":" 6275","line":""},
{"lineNum":" 6276","line":"    if (headers.len != 0 and !header_done) {"},
{"lineNum":" 6277","line":"        const amt = try writev(out_fd, headers);"},
{"lineNum":" 6278","line":"        total_written += amt;"},
{"lineNum":" 6279","line":"        if (amt < count_iovec_bytes(headers)) return total_written;"},
{"lineNum":" 6280","line":"    }"},
{"lineNum":" 6281","line":""},
{"lineNum":" 6282","line":"    rw: {"},
{"lineNum":" 6283","line":"        var buf: [8 * 4096]u8 = undefined;"},
{"lineNum":" 6284","line":"        // Here we match BSD behavior, making a zero count value send as many bytes as possible."},
{"lineNum":" 6285","line":"        const adjusted_count_tmp = if (in_len == 0) buf.len else @min(buf.len, in_len);"},
{"lineNum":" 6286","line":"        // TODO we should not need this cast; improve return type of @min"},
{"lineNum":" 6287","line":"        const adjusted_count = @as(usize, @intCast(adjusted_count_tmp));"},
{"lineNum":" 6288","line":"        const amt_read = try pread(in_fd, buf[0..adjusted_count], in_offset);"},
{"lineNum":" 6289","line":"        if (amt_read == 0) {"},
{"lineNum":" 6290","line":"            if (in_len == 0) {"},
{"lineNum":" 6291","line":"                // We have detected EOF from `in_fd`."},
{"lineNum":" 6292","line":"                break :rw;"},
{"lineNum":" 6293","line":"            } else {"},
{"lineNum":" 6294","line":"                return total_written;"},
{"lineNum":" 6295","line":"            }"},
{"lineNum":" 6296","line":"        }"},
{"lineNum":" 6297","line":"        const amt_written = try write(out_fd, buf[0..amt_read]);"},
{"lineNum":" 6298","line":"        total_written += amt_written;"},
{"lineNum":" 6299","line":"        if (amt_written < in_len or in_len == 0) return total_written;"},
{"lineNum":" 6300","line":"    }"},
{"lineNum":" 6301","line":""},
{"lineNum":" 6302","line":"    if (trailers.len != 0) {"},
{"lineNum":" 6303","line":"        total_written += try writev(out_fd, trailers);"},
{"lineNum":" 6304","line":"    }"},
{"lineNum":" 6305","line":""},
{"lineNum":" 6306","line":"    return total_written;"},
{"lineNum":" 6307","line":"}"},
{"lineNum":" 6308","line":""},
{"lineNum":" 6309","line":"pub const CopyFileRangeError = error{"},
{"lineNum":" 6310","line":"    FileTooBig,"},
{"lineNum":" 6311","line":"    InputOutput,"},
{"lineNum":" 6312","line":"    /// `fd_in` is not open for reading; or `fd_out` is not open  for  writing;"},
{"lineNum":" 6313","line":"    /// or the  `O.APPEND`  flag  is  set  for `fd_out`."},
{"lineNum":" 6314","line":"    FilesOpenedWithWrongFlags,"},
{"lineNum":" 6315","line":"    IsDir,"},
{"lineNum":" 6316","line":"    OutOfMemory,"},
{"lineNum":" 6317","line":"    NoSpaceLeft,"},
{"lineNum":" 6318","line":"    Unseekable,"},
{"lineNum":" 6319","line":"    PermissionDenied,"},
{"lineNum":" 6320","line":"    SwapFile,"},
{"lineNum":" 6321","line":"    CorruptedData,"},
{"lineNum":" 6322","line":"} || PReadError || PWriteError || UnexpectedError;"},
{"lineNum":" 6323","line":""},
{"lineNum":" 6324","line":"var has_copy_file_range_syscall = std.atomic.Atomic(bool).init(true);"},
{"lineNum":" 6325","line":""},
{"lineNum":" 6326","line":"/// Transfer data between file descriptors at specified offsets."},
{"lineNum":" 6327","line":"/// Returns the number of bytes written, which can less than requested."},
{"lineNum":" 6328","line":"///"},
{"lineNum":" 6329","line":"/// The `copy_file_range` call copies `len` bytes from one file descriptor to another. When possible,"},
{"lineNum":" 6330","line":"/// this is done within the operating system kernel, which can provide better performance"},
{"lineNum":" 6331","line":"/// characteristics than transferring data from kernel to user space and back, such as with"},
{"lineNum":" 6332","line":"/// `pread` and `pwrite` calls."},
{"lineNum":" 6333","line":"///"},
{"lineNum":" 6334","line":"/// `fd_in` must be a file descriptor opened for reading, and `fd_out` must be a file descriptor"},
{"lineNum":" 6335","line":"/// opened for writing. They may be any kind of file descriptor; however, if `fd_in` is not a regular"},
{"lineNum":" 6336","line":"/// file system file, it may cause this function to fall back to calling `pread` and `pwrite`, in which case"},
{"lineNum":" 6337","line":"/// atomicity guarantees no longer apply."},
{"lineNum":" 6338","line":"///"},
{"lineNum":" 6339","line":"/// If `fd_in` and `fd_out` are the same, source and target ranges must not overlap."},
{"lineNum":" 6340","line":"/// The file descriptor seek positions are ignored and not updated."},
{"lineNum":" 6341","line":"/// When `off_in` is past the end of the input file, it successfully reads 0 bytes."},
{"lineNum":" 6342","line":"///"},
{"lineNum":" 6343","line":"/// `flags` has different meanings per operating system; refer to the respective man pages."},
{"lineNum":" 6344","line":"///"},
{"lineNum":" 6345","line":"/// These systems support in-kernel data copying:"},
{"lineNum":" 6346","line":"/// * Linux 4.5 (cross-filesystem 5.3)"},
{"lineNum":" 6347","line":"/// * FreeBSD 13.0"},
{"lineNum":" 6348","line":"///"},
{"lineNum":" 6349","line":"/// Other systems fall back to calling `pread` / `pwrite`."},
{"lineNum":" 6350","line":"///"},
{"lineNum":" 6351","line":"/// Maximum offsets on Linux and FreeBSD are `math.maxInt(i64)`."},
{"lineNum":" 6352","line":"pub fn copy_file_range(fd_in: fd_t, off_in: u64, fd_out: fd_t, off_out: u64, len: usize, flags: u32) CopyFileRangeError!usize {"},
{"lineNum":" 6353","line":"    if ((comptime builtin.os.isAtLeast(.freebsd, .{ .major = 13, .minor = 0, .patch = 0 }) orelse false) or"},
{"lineNum":" 6354","line":"        ((comptime builtin.os.isAtLeast(.linux, .{ .major = 4, .minor = 5, .patch = 0 }) orelse false and"},
{"lineNum":" 6355","line":"        std.c.versionCheck(.{ .major = 2, .minor = 27, .patch = 0 }).ok) and"},
{"lineNum":" 6356","line":"        has_copy_file_range_syscall.load(.Monotonic)))"},
{"lineNum":" 6357","line":"    {"},
{"lineNum":" 6358","line":"        var off_in_copy = @as(i64, @bitCast(off_in));"},
{"lineNum":" 6359","line":"        var off_out_copy = @as(i64, @bitCast(off_out));"},
{"lineNum":" 6360","line":""},
{"lineNum":" 6361","line":"        while (true) {"},
{"lineNum":" 6362","line":"            const rc = system.copy_file_range(fd_in, &off_in_copy, fd_out, &off_out_copy, len, flags);"},
{"lineNum":" 6363","line":"            if (builtin.os.tag == .freebsd) {"},
{"lineNum":" 6364","line":"                switch (system.getErrno(rc)) {"},
{"lineNum":" 6365","line":"                    .SUCCESS => return @as(usize, @intCast(rc)),"},
{"lineNum":" 6366","line":"                    .BADF => return error.FilesOpenedWithWrongFlags,"},
{"lineNum":" 6367","line":"                    .FBIG => return error.FileTooBig,"},
{"lineNum":" 6368","line":"                    .IO => return error.InputOutput,"},
{"lineNum":" 6369","line":"                    .ISDIR => return error.IsDir,"},
{"lineNum":" 6370","line":"                    .NOSPC => return error.NoSpaceLeft,"},
{"lineNum":" 6371","line":"                    .INVAL => break, // these may not be regular files, try fallback"},
{"lineNum":" 6372","line":"                    .INTEGRITY => return error.CorruptedData,"},
{"lineNum":" 6373","line":"                    .INTR => continue,"},
{"lineNum":" 6374","line":"                    else => |err| return unexpectedErrno(err),"},
{"lineNum":" 6375","line":"                }"},
{"lineNum":" 6376","line":"            } else { // assume linux"},
{"lineNum":" 6377","line":"                switch (system.getErrno(rc)) {"},
{"lineNum":" 6378","line":"                    .SUCCESS => return @as(usize, @intCast(rc)),"},
{"lineNum":" 6379","line":"                    .BADF => return error.FilesOpenedWithWrongFlags,"},
{"lineNum":" 6380","line":"                    .FBIG => return error.FileTooBig,"},
{"lineNum":" 6381","line":"                    .IO => return error.InputOutput,"},
{"lineNum":" 6382","line":"                    .ISDIR => return error.IsDir,"},
{"lineNum":" 6383","line":"                    .NOSPC => return error.NoSpaceLeft,"},
{"lineNum":" 6384","line":"                    .INVAL => break, // these may not be regular files, try fallback"},
{"lineNum":" 6385","line":"                    .NOMEM => return error.OutOfMemory,"},
{"lineNum":" 6386","line":"                    .OVERFLOW => return error.Unseekable,"},
{"lineNum":" 6387","line":"                    .PERM => return error.PermissionDenied,"},
{"lineNum":" 6388","line":"                    .TXTBSY => return error.SwapFile,"},
{"lineNum":" 6389","line":"                    .XDEV => break, // support for cross-filesystem copy added in Linux 5.3, use fallback"},
{"lineNum":" 6390","line":"                    .NOSYS => { // syscall added in Linux 4.5, use fallback"},
{"lineNum":" 6391","line":"                        has_copy_file_range_syscall.store(false, .Monotonic);"},
{"lineNum":" 6392","line":"                        break;"},
{"lineNum":" 6393","line":"                    },"},
{"lineNum":" 6394","line":"                    else => |err| return unexpectedErrno(err),"},
{"lineNum":" 6395","line":"                }"},
{"lineNum":" 6396","line":"            }"},
{"lineNum":" 6397","line":"        }"},
{"lineNum":" 6398","line":"    }"},
{"lineNum":" 6399","line":""},
{"lineNum":" 6400","line":"    var buf: [8 * 4096]u8 = undefined;"},
{"lineNum":" 6401","line":"    const adjusted_count = @min(buf.len, len);"},
{"lineNum":" 6402","line":"    const amt_read = try pread(fd_in, buf[0..adjusted_count], off_in);"},
{"lineNum":" 6403","line":"    // TODO without @as the line below fails to compile for wasm32-wasi:"},
{"lineNum":" 6404","line":"    // error: integer value 0 cannot be coerced to type \'os.PWriteError!usize\'"},
{"lineNum":" 6405","line":"    if (amt_read == 0) return @as(usize, 0);"},
{"lineNum":" 6406","line":"    return pwrite(fd_out, buf[0..amt_read], off_out);"},
{"lineNum":" 6407","line":"}"},
{"lineNum":" 6408","line":""},
{"lineNum":" 6409","line":"pub const PollError = error{"},
{"lineNum":" 6410","line":"    /// The network subsystem has failed."},
{"lineNum":" 6411","line":"    NetworkSubsystemFailed,"},
{"lineNum":" 6412","line":""},
{"lineNum":" 6413","line":"    /// The kernel had no space to allocate file descriptor tables."},
{"lineNum":" 6414","line":"    SystemResources,"},
{"lineNum":" 6415","line":"} || UnexpectedError;"},
{"lineNum":" 6416","line":""},
{"lineNum":" 6417","line":"pub fn poll(fds: []pollfd, timeout: i32) PollError!usize {"},
{"lineNum":" 6418","line":"    while (true) {"},
{"lineNum":" 6419","line":"        const fds_count = math.cast(nfds_t, fds.len) orelse return error.SystemResources;"},
{"lineNum":" 6420","line":"        const rc = system.poll(fds.ptr, fds_count, timeout);"},
{"lineNum":" 6421","line":"        if (builtin.os.tag == .windows) {"},
{"lineNum":" 6422","line":"            if (rc == windows.ws2_32.SOCKET_ERROR) {"},
{"lineNum":" 6423","line":"                switch (windows.ws2_32.WSAGetLastError()) {"},
{"lineNum":" 6424","line":"                    .WSANOTINITIALISED => unreachable,"},
{"lineNum":" 6425","line":"                    .WSAENETDOWN => return error.NetworkSubsystemFailed,"},
{"lineNum":" 6426","line":"                    .WSAENOBUFS => return error.SystemResources,"},
{"lineNum":" 6427","line":"                    // TODO: handle more errors"},
{"lineNum":" 6428","line":"                    else => |err| return windows.unexpectedWSAError(err),"},
{"lineNum":" 6429","line":"                }"},
{"lineNum":" 6430","line":"            } else {"},
{"lineNum":" 6431","line":"                return @as(usize, @intCast(rc));"},
{"lineNum":" 6432","line":"            }"},
{"lineNum":" 6433","line":"        } else {"},
{"lineNum":" 6434","line":"            switch (errno(rc)) {"},
{"lineNum":" 6435","line":"                .SUCCESS => return @as(usize, @intCast(rc)),"},
{"lineNum":" 6436","line":"                .FAULT => unreachable,"},
{"lineNum":" 6437","line":"                .INTR => continue,"},
{"lineNum":" 6438","line":"                .INVAL => unreachable,"},
{"lineNum":" 6439","line":"                .NOMEM => return error.SystemResources,"},
{"lineNum":" 6440","line":"                else => |err| return unexpectedErrno(err),"},
{"lineNum":" 6441","line":"            }"},
{"lineNum":" 6442","line":"        }"},
{"lineNum":" 6443","line":"        unreachable;"},
{"lineNum":" 6444","line":"    }"},
{"lineNum":" 6445","line":"}"},
{"lineNum":" 6446","line":""},
{"lineNum":" 6447","line":"pub const PPollError = error{"},
{"lineNum":" 6448","line":"    /// The operation was interrupted by a delivery of a signal before it could complete."},
{"lineNum":" 6449","line":"    SignalInterrupt,"},
{"lineNum":" 6450","line":""},
{"lineNum":" 6451","line":"    /// The kernel had no space to allocate file descriptor tables."},
{"lineNum":" 6452","line":"    SystemResources,"},
{"lineNum":" 6453","line":"} || UnexpectedError;"},
{"lineNum":" 6454","line":""},
{"lineNum":" 6455","line":"pub fn ppoll(fds: []pollfd, timeout: ?*const timespec, mask: ?*const sigset_t) PPollError!usize {"},
{"lineNum":" 6456","line":"    var ts: timespec = undefined;"},
{"lineNum":" 6457","line":"    var ts_ptr: ?*timespec = null;"},
{"lineNum":" 6458","line":"    if (timeout) |timeout_ns| {"},
{"lineNum":" 6459","line":"        ts_ptr = &ts;"},
{"lineNum":" 6460","line":"        ts = timeout_ns.*;"},
{"lineNum":" 6461","line":"    }"},
{"lineNum":" 6462","line":"    const fds_count = math.cast(nfds_t, fds.len) orelse return error.SystemResources;"},
{"lineNum":" 6463","line":"    const rc = system.ppoll(fds.ptr, fds_count, ts_ptr, mask);"},
{"lineNum":" 6464","line":"    switch (errno(rc)) {"},
{"lineNum":" 6465","line":"        .SUCCESS => return @as(usize, @intCast(rc)),"},
{"lineNum":" 6466","line":"        .FAULT => unreachable,"},
{"lineNum":" 6467","line":"        .INTR => return error.SignalInterrupt,"},
{"lineNum":" 6468","line":"        .INVAL => unreachable,"},
{"lineNum":" 6469","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 6470","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 6471","line":"    }"},
{"lineNum":" 6472","line":"}"},
{"lineNum":" 6473","line":""},
{"lineNum":" 6474","line":"pub const RecvFromError = error{"},
{"lineNum":" 6475","line":"    /// The socket is marked nonblocking and the requested operation would block, and"},
{"lineNum":" 6476","line":"    /// there is no global event loop configured."},
{"lineNum":" 6477","line":"    WouldBlock,"},
{"lineNum":" 6478","line":""},
{"lineNum":" 6479","line":"    /// A remote host refused to allow the network connection, typically because it is not"},
{"lineNum":" 6480","line":"    /// running the requested service."},
{"lineNum":" 6481","line":"    ConnectionRefused,"},
{"lineNum":" 6482","line":""},
{"lineNum":" 6483","line":"    /// Could not allocate kernel memory."},
{"lineNum":" 6484","line":"    SystemResources,"},
{"lineNum":" 6485","line":""},
{"lineNum":" 6486","line":"    ConnectionResetByPeer,"},
{"lineNum":" 6487","line":""},
{"lineNum":" 6488","line":"    /// The socket has not been bound."},
{"lineNum":" 6489","line":"    SocketNotBound,"},
{"lineNum":" 6490","line":""},
{"lineNum":" 6491","line":"    /// The UDP message was too big for the buffer and part of it has been discarded"},
{"lineNum":" 6492","line":"    MessageTooBig,"},
{"lineNum":" 6493","line":""},
{"lineNum":" 6494","line":"    /// The network subsystem has failed."},
{"lineNum":" 6495","line":"    NetworkSubsystemFailed,"},
{"lineNum":" 6496","line":""},
{"lineNum":" 6497","line":"    /// The socket is not connected (connection-oriented sockets only)."},
{"lineNum":" 6498","line":"    SocketNotConnected,"},
{"lineNum":" 6499","line":"} || UnexpectedError;"},
{"lineNum":" 6500","line":""},
{"lineNum":" 6501","line":"pub fn recv(sock: socket_t, buf: []u8, flags: u32) RecvFromError!usize {"},
{"lineNum":" 6502","line":"    return recvfrom(sock, buf, flags, null, null);"},
{"lineNum":" 6503","line":"}"},
{"lineNum":" 6504","line":""},
{"lineNum":" 6505","line":"/// If `sockfd` is opened in non blocking mode, the function will"},
{"lineNum":" 6506","line":"/// return error.WouldBlock when EAGAIN is received."},
{"lineNum":" 6507","line":"pub fn recvfrom("},
{"lineNum":" 6508","line":"    sockfd: socket_t,"},
{"lineNum":" 6509","line":"    buf: []u8,"},
{"lineNum":" 6510","line":"    flags: u32,"},
{"lineNum":" 6511","line":"    src_addr: ?*sockaddr,"},
{"lineNum":" 6512","line":"    addrlen: ?*socklen_t,"},
{"lineNum":" 6513","line":") RecvFromError!usize {"},
{"lineNum":" 6514","line":"    while (true) {"},
{"lineNum":" 6515","line":"        const rc = system.recvfrom(sockfd, buf.ptr, buf.len, flags, src_addr, addrlen);"},
{"lineNum":" 6516","line":"        if (builtin.os.tag == .windows) {"},
{"lineNum":" 6517","line":"            if (rc == windows.ws2_32.SOCKET_ERROR) {"},
{"lineNum":" 6518","line":"                switch (windows.ws2_32.WSAGetLastError()) {"},
{"lineNum":" 6519","line":"                    .WSANOTINITIALISED => unreachable,"},
{"lineNum":" 6520","line":"                    .WSAECONNRESET => return error.ConnectionResetByPeer,"},
{"lineNum":" 6521","line":"                    .WSAEINVAL => return error.SocketNotBound,"},
{"lineNum":" 6522","line":"                    .WSAEMSGSIZE => return error.MessageTooBig,"},
{"lineNum":" 6523","line":"                    .WSAENETDOWN => return error.NetworkSubsystemFailed,"},
{"lineNum":" 6524","line":"                    .WSAENOTCONN => return error.SocketNotConnected,"},
{"lineNum":" 6525","line":"                    .WSAEWOULDBLOCK => return error.WouldBlock,"},
{"lineNum":" 6526","line":"                    // TODO: handle more errors"},
{"lineNum":" 6527","line":"                    else => |err| return windows.unexpectedWSAError(err),"},
{"lineNum":" 6528","line":"                }"},
{"lineNum":" 6529","line":"            } else {"},
{"lineNum":" 6530","line":"                return @as(usize, @intCast(rc));"},
{"lineNum":" 6531","line":"            }"},
{"lineNum":" 6532","line":"        } else {"},
{"lineNum":" 6533","line":"            switch (errno(rc)) {"},
{"lineNum":" 6534","line":"                .SUCCESS => return @as(usize, @intCast(rc)),"},
{"lineNum":" 6535","line":"                .BADF => unreachable, // always a race condition"},
{"lineNum":" 6536","line":"                .FAULT => unreachable,"},
{"lineNum":" 6537","line":"                .INVAL => unreachable,"},
{"lineNum":" 6538","line":"                .NOTCONN => return error.SocketNotConnected,"},
{"lineNum":" 6539","line":"                .NOTSOCK => unreachable,"},
{"lineNum":" 6540","line":"                .INTR => continue,"},
{"lineNum":" 6541","line":"                .AGAIN => return error.WouldBlock,"},
{"lineNum":" 6542","line":"                .NOMEM => return error.SystemResources,"},
{"lineNum":" 6543","line":"                .CONNREFUSED => return error.ConnectionRefused,"},
{"lineNum":" 6544","line":"                .CONNRESET => return error.ConnectionResetByPeer,"},
{"lineNum":" 6545","line":"                else => |err| return unexpectedErrno(err),"},
{"lineNum":" 6546","line":"            }"},
{"lineNum":" 6547","line":"        }"},
{"lineNum":" 6548","line":"    }"},
{"lineNum":" 6549","line":"}"},
{"lineNum":" 6550","line":""},
{"lineNum":" 6551","line":"pub const DnExpandError = error{InvalidDnsPacket};"},
{"lineNum":" 6552","line":""},
{"lineNum":" 6553","line":"pub fn dn_expand("},
{"lineNum":" 6554","line":"    msg: []const u8,"},
{"lineNum":" 6555","line":"    comp_dn: []const u8,"},
{"lineNum":" 6556","line":"    exp_dn: []u8,"},
{"lineNum":" 6557","line":") DnExpandError!usize {"},
{"lineNum":" 6558","line":"    // This implementation is ported from musl libc."},
{"lineNum":" 6559","line":"    // A more idiomatic \"ziggy\" implementation would be welcome."},
{"lineNum":" 6560","line":"    var p = comp_dn.ptr;"},
{"lineNum":" 6561","line":"    var len: usize = std.math.maxInt(usize);"},
{"lineNum":" 6562","line":"    const end = msg.ptr + msg.len;"},
{"lineNum":" 6563","line":"    if (p == end or exp_dn.len == 0) return error.InvalidDnsPacket;"},
{"lineNum":" 6564","line":"    var dest = exp_dn.ptr;"},
{"lineNum":" 6565","line":"    const dend = dest + @min(exp_dn.len, 254);"},
{"lineNum":" 6566","line":"    // detect reference loop using an iteration counter"},
{"lineNum":" 6567","line":"    var i: usize = 0;"},
{"lineNum":" 6568","line":"    while (i < msg.len) : (i += 2) {"},
{"lineNum":" 6569","line":"        // loop invariants: p<end, dest<dend"},
{"lineNum":" 6570","line":"        if ((p[0] & 0xc0) != 0) {"},
{"lineNum":" 6571","line":"            if (p + 1 == end) return error.InvalidDnsPacket;"},
{"lineNum":" 6572","line":"            var j = ((p[0] & @as(usize, 0x3f)) << 8) | p[1];"},
{"lineNum":" 6573","line":"            if (len == std.math.maxInt(usize)) len = @intFromPtr(p) + 2 - @intFromPtr(comp_dn.ptr);"},
{"lineNum":" 6574","line":"            if (j >= msg.len) return error.InvalidDnsPacket;"},
{"lineNum":" 6575","line":"            p = msg.ptr + j;"},
{"lineNum":" 6576","line":"        } else if (p[0] != 0) {"},
{"lineNum":" 6577","line":"            if (dest != exp_dn.ptr) {"},
{"lineNum":" 6578","line":"                dest[0] = \'.\';"},
{"lineNum":" 6579","line":"                dest += 1;"},
{"lineNum":" 6580","line":"            }"},
{"lineNum":" 6581","line":"            var j = p[0];"},
{"lineNum":" 6582","line":"            p += 1;"},
{"lineNum":" 6583","line":"            if (j >= @intFromPtr(end) - @intFromPtr(p) or j >= @intFromPtr(dend) - @intFromPtr(dest)) {"},
{"lineNum":" 6584","line":"                return error.InvalidDnsPacket;"},
{"lineNum":" 6585","line":"            }"},
{"lineNum":" 6586","line":"            while (j != 0) {"},
{"lineNum":" 6587","line":"                j -= 1;"},
{"lineNum":" 6588","line":"                dest[0] = p[0];"},
{"lineNum":" 6589","line":"                dest += 1;"},
{"lineNum":" 6590","line":"                p += 1;"},
{"lineNum":" 6591","line":"            }"},
{"lineNum":" 6592","line":"        } else {"},
{"lineNum":" 6593","line":"            dest[0] = 0;"},
{"lineNum":" 6594","line":"            if (len == std.math.maxInt(usize)) len = @intFromPtr(p) + 1 - @intFromPtr(comp_dn.ptr);"},
{"lineNum":" 6595","line":"            return len;"},
{"lineNum":" 6596","line":"        }"},
{"lineNum":" 6597","line":"    }"},
{"lineNum":" 6598","line":"    return error.InvalidDnsPacket;"},
{"lineNum":" 6599","line":"}"},
{"lineNum":" 6600","line":""},
{"lineNum":" 6601","line":"pub const SetSockOptError = error{"},
{"lineNum":" 6602","line":"    /// The socket is already connected, and a specified option cannot be set while the socket is connected."},
{"lineNum":" 6603","line":"    AlreadyConnected,"},
{"lineNum":" 6604","line":""},
{"lineNum":" 6605","line":"    /// The option is not supported by the protocol."},
{"lineNum":" 6606","line":"    InvalidProtocolOption,"},
{"lineNum":" 6607","line":""},
{"lineNum":" 6608","line":"    /// The send and receive timeout values are too big to fit into the timeout fields in the socket structure."},
{"lineNum":" 6609","line":"    TimeoutTooBig,"},
{"lineNum":" 6610","line":""},
{"lineNum":" 6611","line":"    /// Insufficient resources are available in the system to complete the call."},
{"lineNum":" 6612","line":"    SystemResources,"},
{"lineNum":" 6613","line":""},
{"lineNum":" 6614","line":"    // Setting the socket option requires more elevated permissions."},
{"lineNum":" 6615","line":"    PermissionDenied,"},
{"lineNum":" 6616","line":""},
{"lineNum":" 6617","line":"    NetworkSubsystemFailed,"},
{"lineNum":" 6618","line":"    FileDescriptorNotASocket,"},
{"lineNum":" 6619","line":"    SocketNotBound,"},
{"lineNum":" 6620","line":"    NoDevice,"},
{"lineNum":" 6621","line":"} || UnexpectedError;"},
{"lineNum":" 6622","line":""},
{"lineNum":" 6623","line":"/// Set a socket\'s options."},
{"lineNum":" 6624","line":"pub fn setsockopt(fd: socket_t, level: u32, optname: u32, opt: []const u8) SetSockOptError!void {"},
{"lineNum":" 6625","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 6626","line":"        const rc = windows.ws2_32.setsockopt(fd, @as(i32, @intCast(level)), @as(i32, @intCast(optname)), opt.ptr, @as(i32, @intCast(opt.len)));"},
{"lineNum":" 6627","line":"        if (rc == windows.ws2_32.SOCKET_ERROR) {"},
{"lineNum":" 6628","line":"            switch (windows.ws2_32.WSAGetLastError()) {"},
{"lineNum":" 6629","line":"                .WSANOTINITIALISED => unreachable,"},
{"lineNum":" 6630","line":"                .WSAENETDOWN => return error.NetworkSubsystemFailed,"},
{"lineNum":" 6631","line":"                .WSAEFAULT => unreachable,"},
{"lineNum":" 6632","line":"                .WSAENOTSOCK => return error.FileDescriptorNotASocket,"},
{"lineNum":" 6633","line":"                .WSAEINVAL => return error.SocketNotBound,"},
{"lineNum":" 6634","line":"                else => |err| return windows.unexpectedWSAError(err),"},
{"lineNum":" 6635","line":"            }"},
{"lineNum":" 6636","line":"        }"},
{"lineNum":" 6637","line":"        return;"},
{"lineNum":" 6638","line":"    } else {"},
{"lineNum":" 6639","line":"        switch (errno(system.setsockopt(fd, level, optname, opt.ptr, @as(socklen_t, @intCast(opt.len))))) {"},
{"lineNum":" 6640","line":"            .SUCCESS => {},"},
{"lineNum":" 6641","line":"            .BADF => unreachable, // always a race condition"},
{"lineNum":" 6642","line":"            .NOTSOCK => unreachable, // always a race condition"},
{"lineNum":" 6643","line":"            .INVAL => unreachable,"},
{"lineNum":" 6644","line":"            .FAULT => unreachable,"},
{"lineNum":" 6645","line":"            .DOM => return error.TimeoutTooBig,"},
{"lineNum":" 6646","line":"            .ISCONN => return error.AlreadyConnected,"},
{"lineNum":" 6647","line":"            .NOPROTOOPT => return error.InvalidProtocolOption,"},
{"lineNum":" 6648","line":"            .NOMEM => return error.SystemResources,"},
{"lineNum":" 6649","line":"            .NOBUFS => return error.SystemResources,"},
{"lineNum":" 6650","line":"            .PERM => return error.PermissionDenied,"},
{"lineNum":" 6651","line":"            .NODEV => return error.NoDevice,"},
{"lineNum":" 6652","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 6653","line":"        }"},
{"lineNum":" 6654","line":"    }"},
{"lineNum":" 6655","line":"}"},
{"lineNum":" 6656","line":""},
{"lineNum":" 6657","line":"pub const MemFdCreateError = error{"},
{"lineNum":" 6658","line":"    SystemFdQuotaExceeded,"},
{"lineNum":" 6659","line":"    ProcessFdQuotaExceeded,"},
{"lineNum":" 6660","line":"    OutOfMemory,"},
{"lineNum":" 6661","line":""},
{"lineNum":" 6662","line":"    /// memfd_create is available in Linux 3.17 and later. This error is returned"},
{"lineNum":" 6663","line":"    /// for older kernel versions."},
{"lineNum":" 6664","line":"    SystemOutdated,"},
{"lineNum":" 6665","line":"} || UnexpectedError;"},
{"lineNum":" 6666","line":""},
{"lineNum":" 6667","line":"pub fn memfd_createZ(name: [*:0]const u8, flags: u32) MemFdCreateError!fd_t {"},
{"lineNum":" 6668","line":"    switch (builtin.os.tag) {"},
{"lineNum":" 6669","line":"        .linux => {"},
{"lineNum":" 6670","line":"            // memfd_create is available only in glibc versions starting with 2.27."},
{"lineNum":" 6671","line":"            const use_c = std.c.versionCheck(.{ .major = 2, .minor = 27, .patch = 0 }).ok;"},
{"lineNum":" 6672","line":"            const sys = if (use_c) std.c else linux;"},
{"lineNum":" 6673","line":"            const getErrno = if (use_c) std.c.getErrno else linux.getErrno;"},
{"lineNum":" 6674","line":"            const rc = sys.memfd_create(name, flags);"},
{"lineNum":" 6675","line":"            switch (getErrno(rc)) {"},
{"lineNum":" 6676","line":"                .SUCCESS => return @as(fd_t, @intCast(rc)),"},
{"lineNum":" 6677","line":"                .FAULT => unreachable, // name has invalid memory"},
{"lineNum":" 6678","line":"                .INVAL => unreachable, // name/flags are faulty"},
{"lineNum":" 6679","line":"                .NFILE => return error.SystemFdQuotaExceeded,"},
{"lineNum":" 6680","line":"                .MFILE => return error.ProcessFdQuotaExceeded,"},
{"lineNum":" 6681","line":"                .NOMEM => return error.OutOfMemory,"},
{"lineNum":" 6682","line":"                .NOSYS => return error.SystemOutdated,"},
{"lineNum":" 6683","line":"                else => |err| return unexpectedErrno(err),"},
{"lineNum":" 6684","line":"            }"},
{"lineNum":" 6685","line":"        },"},
{"lineNum":" 6686","line":"        .freebsd => {"},
{"lineNum":" 6687","line":"            if (comptime builtin.os.version_range.semver.max.order(.{ .major = 13, .minor = 0, .patch = 0 }) == .lt)"},
{"lineNum":" 6688","line":"                @compileError(\"memfd_create is unavailable on FreeBSD < 13.0\");"},
{"lineNum":" 6689","line":"            const rc = system.memfd_create(name, flags);"},
{"lineNum":" 6690","line":"            switch (errno(rc)) {"},
{"lineNum":" 6691","line":"                .SUCCESS => return rc,"},
{"lineNum":" 6692","line":"                .BADF => unreachable, // name argument NULL"},
{"lineNum":" 6693","line":"                .INVAL => unreachable, // name too long or invalid/unsupported flags."},
{"lineNum":" 6694","line":"                .MFILE => return error.ProcessFdQuotaExceeded,"},
{"lineNum":" 6695","line":"                .NFILE => return error.SystemFdQuotaExceeded,"},
{"lineNum":" 6696","line":"                .NOSYS => return error.SystemOutdated,"},
{"lineNum":" 6697","line":"                else => |err| return unexpectedErrno(err),"},
{"lineNum":" 6698","line":"            }"},
{"lineNum":" 6699","line":"        },"},
{"lineNum":" 6700","line":"        else => @compileError(\"target OS does not support memfd_create()\"),"},
{"lineNum":" 6701","line":"    }"},
{"lineNum":" 6702","line":"}"},
{"lineNum":" 6703","line":""},
{"lineNum":" 6704","line":"pub const MFD_NAME_PREFIX = \"memfd:\";"},
{"lineNum":" 6705","line":"pub const MFD_MAX_NAME_LEN = NAME_MAX - MFD_NAME_PREFIX.len;"},
{"lineNum":" 6706","line":"fn toMemFdPath(name: []const u8) ![MFD_MAX_NAME_LEN:0]u8 {"},
{"lineNum":" 6707","line":"    var path_with_null: [MFD_MAX_NAME_LEN:0]u8 = undefined;"},
{"lineNum":" 6708","line":"    // >= rather than > to make room for the null byte"},
{"lineNum":" 6709","line":"    if (name.len >= MFD_MAX_NAME_LEN) return error.NameTooLong;"},
{"lineNum":" 6710","line":"    @memcpy(path_with_null[0..name.len], name);"},
{"lineNum":" 6711","line":"    path_with_null[name.len] = 0;"},
{"lineNum":" 6712","line":"    return path_with_null;"},
{"lineNum":" 6713","line":"}"},
{"lineNum":" 6714","line":""},
{"lineNum":" 6715","line":"pub fn memfd_create(name: []const u8, flags: u32) !fd_t {"},
{"lineNum":" 6716","line":"    const name_t = try toMemFdPath(name);"},
{"lineNum":" 6717","line":"    return memfd_createZ(&name_t, flags);"},
{"lineNum":" 6718","line":"}"},
{"lineNum":" 6719","line":""},
{"lineNum":" 6720","line":"pub fn getrusage(who: i32) rusage {"},
{"lineNum":" 6721","line":"    var result: rusage = undefined;"},
{"lineNum":" 6722","line":"    const rc = system.getrusage(who, &result);"},
{"lineNum":" 6723","line":"    switch (errno(rc)) {"},
{"lineNum":" 6724","line":"        .SUCCESS => return result,"},
{"lineNum":" 6725","line":"        .INVAL => unreachable,"},
{"lineNum":" 6726","line":"        .FAULT => unreachable,"},
{"lineNum":" 6727","line":"        else => unreachable,"},
{"lineNum":" 6728","line":"    }"},
{"lineNum":" 6729","line":"}"},
{"lineNum":" 6730","line":""},
{"lineNum":" 6731","line":"pub const TIOCError = error{NotATerminal};"},
{"lineNum":" 6732","line":""},
{"lineNum":" 6733","line":"pub const TermiosGetError = TIOCError || UnexpectedError;"},
{"lineNum":" 6734","line":""},
{"lineNum":" 6735","line":"pub fn tcgetattr(handle: fd_t) TermiosGetError!termios {"},
{"lineNum":" 6736","line":"    while (true) {"},
{"lineNum":" 6737","line":"        var term: termios = undefined;"},
{"lineNum":" 6738","line":"        switch (errno(system.tcgetattr(handle, &term))) {"},
{"lineNum":" 6739","line":"            .SUCCESS => return term,"},
{"lineNum":" 6740","line":"            .INTR => continue,"},
{"lineNum":" 6741","line":"            .BADF => unreachable,"},
{"lineNum":" 6742","line":"            .NOTTY => return error.NotATerminal,"},
{"lineNum":" 6743","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 6744","line":"        }"},
{"lineNum":" 6745","line":"    }"},
{"lineNum":" 6746","line":"}"},
{"lineNum":" 6747","line":""},
{"lineNum":" 6748","line":"pub const TermiosSetError = TermiosGetError || error{ProcessOrphaned};"},
{"lineNum":" 6749","line":""},
{"lineNum":" 6750","line":"pub fn tcsetattr(handle: fd_t, optional_action: TCSA, termios_p: termios) TermiosSetError!void {"},
{"lineNum":" 6751","line":"    while (true) {"},
{"lineNum":" 6752","line":"        switch (errno(system.tcsetattr(handle, optional_action, &termios_p))) {"},
{"lineNum":" 6753","line":"            .SUCCESS => return,"},
{"lineNum":" 6754","line":"            .BADF => unreachable,"},
{"lineNum":" 6755","line":"            .INTR => continue,"},
{"lineNum":" 6756","line":"            .INVAL => unreachable,"},
{"lineNum":" 6757","line":"            .NOTTY => return error.NotATerminal,"},
{"lineNum":" 6758","line":"            .IO => return error.ProcessOrphaned,"},
{"lineNum":" 6759","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 6760","line":"        }"},
{"lineNum":" 6761","line":"    }"},
{"lineNum":" 6762","line":"}"},
{"lineNum":" 6763","line":""},
{"lineNum":" 6764","line":"pub const TermioGetPgrpError = TIOCError || UnexpectedError;"},
{"lineNum":" 6765","line":""},
{"lineNum":" 6766","line":"/// Returns the process group ID for the TTY associated with the given handle."},
{"lineNum":" 6767","line":"pub fn tcgetpgrp(handle: fd_t) TermioGetPgrpError!pid_t {"},
{"lineNum":" 6768","line":"    while (true) {"},
{"lineNum":" 6769","line":"        var pgrp: pid_t = undefined;"},
{"lineNum":" 6770","line":"        switch (errno(system.tcgetpgrp(handle, &pgrp))) {"},
{"lineNum":" 6771","line":"            .SUCCESS => return pgrp,"},
{"lineNum":" 6772","line":"            .BADF => unreachable,"},
{"lineNum":" 6773","line":"            .INVAL => unreachable,"},
{"lineNum":" 6774","line":"            .INTR => continue,"},
{"lineNum":" 6775","line":"            .NOTTY => return error.NotATerminal,"},
{"lineNum":" 6776","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 6777","line":"        }"},
{"lineNum":" 6778","line":"    }"},
{"lineNum":" 6779","line":"}"},
{"lineNum":" 6780","line":""},
{"lineNum":" 6781","line":"pub const TermioSetPgrpError = TermioGetPgrpError || error{NotAPgrpMember};"},
{"lineNum":" 6782","line":""},
{"lineNum":" 6783","line":"/// Sets the controlling process group ID for given TTY."},
{"lineNum":" 6784","line":"/// handle must be valid fd_t to a TTY associated with calling process."},
{"lineNum":" 6785","line":"/// pgrp must be a valid process group, and the calling process must be a member"},
{"lineNum":" 6786","line":"/// of that group."},
{"lineNum":" 6787","line":"pub fn tcsetpgrp(handle: fd_t, pgrp: pid_t) TermioSetPgrpError!void {"},
{"lineNum":" 6788","line":"    while (true) {"},
{"lineNum":" 6789","line":"        switch (errno(system.tcsetpgrp(handle, &pgrp))) {"},
{"lineNum":" 6790","line":"            .SUCCESS => return,"},
{"lineNum":" 6791","line":"            .BADF => unreachable,"},
{"lineNum":" 6792","line":"            .INVAL => unreachable,"},
{"lineNum":" 6793","line":"            .INTR => continue,"},
{"lineNum":" 6794","line":"            .NOTTY => return error.NotATerminal,"},
{"lineNum":" 6795","line":"            .PERM => return TermioSetPgrpError.NotAPgrpMember,"},
{"lineNum":" 6796","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 6797","line":"        }"},
{"lineNum":" 6798","line":"    }"},
{"lineNum":" 6799","line":"}"},
{"lineNum":" 6800","line":""},
{"lineNum":" 6801","line":"pub const IoCtl_SIOCGIFINDEX_Error = error{"},
{"lineNum":" 6802","line":"    FileSystem,"},
{"lineNum":" 6803","line":"    InterfaceNotFound,"},
{"lineNum":" 6804","line":"} || UnexpectedError;"},
{"lineNum":" 6805","line":""},
{"lineNum":" 6806","line":"pub fn ioctl_SIOCGIFINDEX(fd: fd_t, ifr: *ifreq) IoCtl_SIOCGIFINDEX_Error!void {"},
{"lineNum":" 6807","line":"    while (true) {"},
{"lineNum":" 6808","line":"        switch (errno(system.ioctl(fd, SIOCGIFINDEX, @intFromPtr(ifr)))) {"},
{"lineNum":" 6809","line":"            .SUCCESS => return,"},
{"lineNum":" 6810","line":"            .INVAL => unreachable, // Bad parameters."},
{"lineNum":" 6811","line":"            .NOTTY => unreachable,"},
{"lineNum":" 6812","line":"            .NXIO => unreachable,"},
{"lineNum":" 6813","line":"            .BADF => unreachable, // Always a race condition."},
{"lineNum":" 6814","line":"            .FAULT => unreachable, // Bad pointer parameter."},
{"lineNum":" 6815","line":"            .INTR => continue,"},
{"lineNum":" 6816","line":"            .IO => return error.FileSystem,"},
{"lineNum":" 6817","line":"            .NODEV => return error.InterfaceNotFound,"},
{"lineNum":" 6818","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 6819","line":"        }"},
{"lineNum":" 6820","line":"    }"},
{"lineNum":" 6821","line":"}"},
{"lineNum":" 6822","line":""},
{"lineNum":" 6823","line":"pub fn signalfd(fd: fd_t, mask: *const sigset_t, flags: u32) !fd_t {"},
{"lineNum":" 6824","line":"    const rc = system.signalfd(fd, mask, flags);"},
{"lineNum":" 6825","line":"    switch (errno(rc)) {"},
{"lineNum":" 6826","line":"        .SUCCESS => return @as(fd_t, @intCast(rc)),"},
{"lineNum":" 6827","line":"        .BADF, .INVAL => unreachable,"},
{"lineNum":" 6828","line":"        .NFILE => return error.SystemFdQuotaExceeded,"},
{"lineNum":" 6829","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 6830","line":"        .MFILE => return error.ProcessResources,"},
{"lineNum":" 6831","line":"        .NODEV => return error.InodeMountFail,"},
{"lineNum":" 6832","line":"        .NOSYS => return error.SystemOutdated,"},
{"lineNum":" 6833","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 6834","line":"    }"},
{"lineNum":" 6835","line":"}"},
{"lineNum":" 6836","line":""},
{"lineNum":" 6837","line":"pub const SyncError = error{"},
{"lineNum":" 6838","line":"    InputOutput,"},
{"lineNum":" 6839","line":"    NoSpaceLeft,"},
{"lineNum":" 6840","line":"    DiskQuota,"},
{"lineNum":" 6841","line":"    AccessDenied,"},
{"lineNum":" 6842","line":"} || UnexpectedError;"},
{"lineNum":" 6843","line":""},
{"lineNum":" 6844","line":"/// Write all pending file contents and metadata modifications to all filesystems."},
{"lineNum":" 6845","line":"pub fn sync() void {"},
{"lineNum":" 6846","line":"    system.sync();"},
{"lineNum":" 6847","line":"}"},
{"lineNum":" 6848","line":""},
{"lineNum":" 6849","line":"/// Write all pending file contents and metadata modifications to the filesystem which contains the specified file."},
{"lineNum":" 6850","line":"pub fn syncfs(fd: fd_t) SyncError!void {"},
{"lineNum":" 6851","line":"    const rc = system.syncfs(fd);"},
{"lineNum":" 6852","line":"    switch (errno(rc)) {"},
{"lineNum":" 6853","line":"        .SUCCESS => return,"},
{"lineNum":" 6854","line":"        .BADF, .INVAL, .ROFS => unreachable,"},
{"lineNum":" 6855","line":"        .IO => return error.InputOutput,"},
{"lineNum":" 6856","line":"        .NOSPC => return error.NoSpaceLeft,"},
{"lineNum":" 6857","line":"        .DQUOT => return error.DiskQuota,"},
{"lineNum":" 6858","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 6859","line":"    }"},
{"lineNum":" 6860","line":"}"},
{"lineNum":" 6861","line":""},
{"lineNum":" 6862","line":"/// Write all pending file contents and metadata modifications for the specified file descriptor to the underlying filesystem."},
{"lineNum":" 6863","line":"pub fn fsync(fd: fd_t) SyncError!void {"},
{"lineNum":" 6864","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 6865","line":"        if (windows.kernel32.FlushFileBuffers(fd) != 0)"},
{"lineNum":" 6866","line":"            return;"},
{"lineNum":" 6867","line":"        switch (windows.kernel32.GetLastError()) {"},
{"lineNum":" 6868","line":"            .SUCCESS => return,"},
{"lineNum":" 6869","line":"            .INVALID_HANDLE => unreachable,"},
{"lineNum":" 6870","line":"            .ACCESS_DENIED => return error.AccessDenied, // a sync was performed but the system couldn\'t update the access time"},
{"lineNum":" 6871","line":"            .UNEXP_NET_ERR => return error.InputOutput,"},
{"lineNum":" 6872","line":"            else => return error.InputOutput,"},
{"lineNum":" 6873","line":"        }"},
{"lineNum":" 6874","line":"    }"},
{"lineNum":" 6875","line":"    const rc = system.fsync(fd);"},
{"lineNum":" 6876","line":"    switch (errno(rc)) {"},
{"lineNum":" 6877","line":"        .SUCCESS => return,"},
{"lineNum":" 6878","line":"        .BADF, .INVAL, .ROFS => unreachable,"},
{"lineNum":" 6879","line":"        .IO => return error.InputOutput,"},
{"lineNum":" 6880","line":"        .NOSPC => return error.NoSpaceLeft,"},
{"lineNum":" 6881","line":"        .DQUOT => return error.DiskQuota,"},
{"lineNum":" 6882","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 6883","line":"    }"},
{"lineNum":" 6884","line":"}"},
{"lineNum":" 6885","line":""},
{"lineNum":" 6886","line":"/// Write all pending file contents for the specified file descriptor to the underlying filesystem, but not necessarily the metadata."},
{"lineNum":" 6887","line":"pub fn fdatasync(fd: fd_t) SyncError!void {"},
{"lineNum":" 6888","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":" 6889","line":"        return fsync(fd) catch |err| switch (err) {"},
{"lineNum":" 6890","line":"            SyncError.AccessDenied => return, // fdatasync doesn\'t promise that the access time was synced"},
{"lineNum":" 6891","line":"            else => return err,"},
{"lineNum":" 6892","line":"        };"},
{"lineNum":" 6893","line":"    }"},
{"lineNum":" 6894","line":"    const rc = system.fdatasync(fd);"},
{"lineNum":" 6895","line":"    switch (errno(rc)) {"},
{"lineNum":" 6896","line":"        .SUCCESS => return,"},
{"lineNum":" 6897","line":"        .BADF, .INVAL, .ROFS => unreachable,"},
{"lineNum":" 6898","line":"        .IO => return error.InputOutput,"},
{"lineNum":" 6899","line":"        .NOSPC => return error.NoSpaceLeft,"},
{"lineNum":" 6900","line":"        .DQUOT => return error.DiskQuota,"},
{"lineNum":" 6901","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 6902","line":"    }"},
{"lineNum":" 6903","line":"}"},
{"lineNum":" 6904","line":""},
{"lineNum":" 6905","line":"pub const PrctlError = error{"},
{"lineNum":" 6906","line":"    /// Can only occur with PR_SET_SECCOMP/SECCOMP_MODE_FILTER or"},
{"lineNum":" 6907","line":"    /// PR_SET_MM/PR_SET_MM_EXE_FILE"},
{"lineNum":" 6908","line":"    AccessDenied,"},
{"lineNum":" 6909","line":"    /// Can only occur with PR_SET_MM/PR_SET_MM_EXE_FILE"},
{"lineNum":" 6910","line":"    InvalidFileDescriptor,"},
{"lineNum":" 6911","line":"    InvalidAddress,"},
{"lineNum":" 6912","line":"    /// Can only occur with PR_SET_SPECULATION_CTRL, PR_MPX_ENABLE_MANAGEMENT,"},
{"lineNum":" 6913","line":"    /// or PR_MPX_DISABLE_MANAGEMENT"},
{"lineNum":" 6914","line":"    UnsupportedFeature,"},
{"lineNum":" 6915","line":"    /// Can only occur with PR_SET_FP_MODE"},
{"lineNum":" 6916","line":"    OperationNotSupported,"},
{"lineNum":" 6917","line":"    PermissionDenied,"},
{"lineNum":" 6918","line":"} || UnexpectedError;"},
{"lineNum":" 6919","line":""},
{"lineNum":" 6920","line":"pub fn prctl(option: PR, args: anytype) PrctlError!u31 {"},
{"lineNum":" 6921","line":"    if (@typeInfo(@TypeOf(args)) != .Struct)"},
{"lineNum":" 6922","line":"        @compileError(\"Expected tuple or struct argument, found \" ++ @typeName(@TypeOf(args)));"},
{"lineNum":" 6923","line":"    if (args.len > 4)"},
{"lineNum":" 6924","line":"        @compileError(\"prctl takes a maximum of 4 optional arguments\");"},
{"lineNum":" 6925","line":""},
{"lineNum":" 6926","line":"    var buf: [4]usize = undefined;"},
{"lineNum":" 6927","line":"    {"},
{"lineNum":" 6928","line":"        comptime var i = 0;"},
{"lineNum":" 6929","line":"        inline while (i < args.len) : (i += 1) buf[i] = args[i];"},
{"lineNum":" 6930","line":"    }"},
{"lineNum":" 6931","line":""},
{"lineNum":" 6932","line":"    const rc = system.prctl(@intFromEnum(option), buf[0], buf[1], buf[2], buf[3]);"},
{"lineNum":" 6933","line":"    switch (errno(rc)) {"},
{"lineNum":" 6934","line":"        .SUCCESS => return @as(u31, @intCast(rc)),"},
{"lineNum":" 6935","line":"        .ACCES => return error.AccessDenied,"},
{"lineNum":" 6936","line":"        .BADF => return error.InvalidFileDescriptor,"},
{"lineNum":" 6937","line":"        .FAULT => return error.InvalidAddress,"},
{"lineNum":" 6938","line":"        .INVAL => unreachable,"},
{"lineNum":" 6939","line":"        .NODEV, .NXIO => return error.UnsupportedFeature,"},
{"lineNum":" 6940","line":"        .OPNOTSUPP => return error.OperationNotSupported,"},
{"lineNum":" 6941","line":"        .PERM, .BUSY => return error.PermissionDenied,"},
{"lineNum":" 6942","line":"        .RANGE => unreachable,"},
{"lineNum":" 6943","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 6944","line":"    }"},
{"lineNum":" 6945","line":"}"},
{"lineNum":" 6946","line":""},
{"lineNum":" 6947","line":"pub const GetrlimitError = UnexpectedError;"},
{"lineNum":" 6948","line":""},
{"lineNum":" 6949","line":"pub fn getrlimit(resource: rlimit_resource) GetrlimitError!rlimit {","class":"lineCov","hits":"1","order":"102","possible_hits":"1",},
{"lineNum":" 6950","line":"    const getrlimit_sym = if (lfs64_abi) system.getrlimit64 else system.getrlimit;"},
{"lineNum":" 6951","line":""},
{"lineNum":" 6952","line":"    var limits: rlimit = undefined;","class":"lineCov","hits":"1","order":"103","possible_hits":"1",},
{"lineNum":" 6953","line":"    switch (errno(getrlimit_sym(resource, &limits))) {","class":"lineCov","hits":"1","order":"104","possible_hits":"1",},
{"lineNum":" 6954","line":"        .SUCCESS => return limits,","class":"lineCov","hits":"1","order":"115","possible_hits":"1",},
{"lineNum":" 6955","line":"        .FAULT => unreachable, // bogus pointer","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 6956","line":"        .INVAL => unreachable,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 6957","line":"        else => |err| return unexpectedErrno(err),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 6958","line":"    }"},
{"lineNum":" 6959","line":"}"},
{"lineNum":" 6960","line":""},
{"lineNum":" 6961","line":"pub const SetrlimitError = error{ PermissionDenied, LimitTooBig } || UnexpectedError;"},
{"lineNum":" 6962","line":""},
{"lineNum":" 6963","line":"pub fn setrlimit(resource: rlimit_resource, limits: rlimit) SetrlimitError!void {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 6964","line":"    const setrlimit_sym = if (lfs64_abi) system.setrlimit64 else system.setrlimit;"},
{"lineNum":" 6965","line":""},
{"lineNum":" 6966","line":"    switch (errno(setrlimit_sym(resource, &limits))) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 6967","line":"        .SUCCESS => return,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 6968","line":"        .FAULT => unreachable, // bogus pointer","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 6969","line":"        .INVAL => return error.LimitTooBig, // this could also mean \"invalid resource\", but that would be unreachable","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 6970","line":"        .PERM => return error.PermissionDenied,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":" 6971","line":"        else => |err| return unexpectedErrno(err),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":" 6972","line":"    }"},
{"lineNum":" 6973","line":"}"},
{"lineNum":" 6974","line":""},
{"lineNum":" 6975","line":"pub const MincoreError = error{"},
{"lineNum":" 6976","line":"    /// A kernel resource was temporarily unavailable."},
{"lineNum":" 6977","line":"    SystemResources,"},
{"lineNum":" 6978","line":"    /// vec points to an invalid address."},
{"lineNum":" 6979","line":"    InvalidAddress,"},
{"lineNum":" 6980","line":"    /// addr is not page-aligned."},
{"lineNum":" 6981","line":"    InvalidSyscall,"},
{"lineNum":" 6982","line":"    /// One of the following:"},
{"lineNum":" 6983","line":"    /// * length is greater than user space TASK_SIZE - addr"},
{"lineNum":" 6984","line":"    /// * addr + length contains unmapped memory"},
{"lineNum":" 6985","line":"    OutOfMemory,"},
{"lineNum":" 6986","line":"    /// The mincore syscall is not available on this version and configuration"},
{"lineNum":" 6987","line":"    /// of this UNIX-like kernel."},
{"lineNum":" 6988","line":"    MincoreUnavailable,"},
{"lineNum":" 6989","line":"} || UnexpectedError;"},
{"lineNum":" 6990","line":""},
{"lineNum":" 6991","line":"/// Determine whether pages are resident in memory."},
{"lineNum":" 6992","line":"pub fn mincore(ptr: [*]align(mem.page_size) u8, length: usize, vec: [*]u8) MincoreError!void {"},
{"lineNum":" 6993","line":"    return switch (errno(system.mincore(ptr, length, vec))) {"},
{"lineNum":" 6994","line":"        .SUCCESS => {},"},
{"lineNum":" 6995","line":"        .AGAIN => error.SystemResources,"},
{"lineNum":" 6996","line":"        .FAULT => error.InvalidAddress,"},
{"lineNum":" 6997","line":"        .INVAL => error.InvalidSyscall,"},
{"lineNum":" 6998","line":"        .NOMEM => error.OutOfMemory,"},
{"lineNum":" 6999","line":"        .NOSYS => error.MincoreUnavailable,"},
{"lineNum":" 7000","line":"        else => |err| unexpectedErrno(err),"},
{"lineNum":" 7001","line":"    };"},
{"lineNum":" 7002","line":"}"},
{"lineNum":" 7003","line":""},
{"lineNum":" 7004","line":"pub const MadviseError = error{"},
{"lineNum":" 7005","line":"    /// advice is MADV.REMOVE, but the specified address range is not a shared writable mapping."},
{"lineNum":" 7006","line":"    AccessDenied,"},
{"lineNum":" 7007","line":"    /// advice is MADV.HWPOISON, but the caller does not have the CAP_SYS_ADMIN capability."},
{"lineNum":" 7008","line":"    PermissionDenied,"},
{"lineNum":" 7009","line":"    /// A kernel resource was temporarily unavailable."},
{"lineNum":" 7010","line":"    SystemResources,"},
{"lineNum":" 7011","line":"    /// One of the following:"},
{"lineNum":" 7012","line":"    /// * addr is not page-aligned or length is negative"},
{"lineNum":" 7013","line":"    /// * advice is not valid"},
{"lineNum":" 7014","line":"    /// * advice is MADV.DONTNEED or MADV.REMOVE and the specified address range"},
{"lineNum":" 7015","line":"    ///   includes locked, Huge TLB pages, or VM_PFNMAP pages."},
{"lineNum":" 7016","line":"    /// * advice is MADV.MERGEABLE or MADV.UNMERGEABLE, but the kernel was not"},
{"lineNum":" 7017","line":"    ///   configured with CONFIG_KSM."},
{"lineNum":" 7018","line":"    /// * advice is MADV.FREE or MADV.WIPEONFORK but the specified address range"},
{"lineNum":" 7019","line":"    ///   includes file, Huge TLB, MAP.SHARED, or VM_PFNMAP ranges."},
{"lineNum":" 7020","line":"    InvalidSyscall,"},
{"lineNum":" 7021","line":"    /// (for MADV.WILLNEED) Paging in this area would exceed the process\'s"},
{"lineNum":" 7022","line":"    /// maximum resident set size."},
{"lineNum":" 7023","line":"    WouldExceedMaximumResidentSetSize,"},
{"lineNum":" 7024","line":"    /// One of the following:"},
{"lineNum":" 7025","line":"    /// * (for MADV.WILLNEED) Not enough memory: paging in failed."},
{"lineNum":" 7026","line":"    /// * Addresses in the specified range are not currently mapped, or"},
{"lineNum":" 7027","line":"    ///   are outside the address space of the process."},
{"lineNum":" 7028","line":"    OutOfMemory,"},
{"lineNum":" 7029","line":"    /// The madvise syscall is not available on this version and configuration"},
{"lineNum":" 7030","line":"    /// of the Linux kernel."},
{"lineNum":" 7031","line":"    MadviseUnavailable,"},
{"lineNum":" 7032","line":"    /// The operating system returned an undocumented error code."},
{"lineNum":" 7033","line":"    Unexpected,"},
{"lineNum":" 7034","line":"};"},
{"lineNum":" 7035","line":""},
{"lineNum":" 7036","line":"/// Give advice about use of memory."},
{"lineNum":" 7037","line":"/// This syscall is optional and is sometimes configured to be disabled."},
{"lineNum":" 7038","line":"pub fn madvise(ptr: [*]align(mem.page_size) u8, length: usize, advice: u32) MadviseError!void {"},
{"lineNum":" 7039","line":"    switch (errno(system.madvise(ptr, length, advice))) {"},
{"lineNum":" 7040","line":"        .SUCCESS => return,"},
{"lineNum":" 7041","line":"        .ACCES => return error.AccessDenied,"},
{"lineNum":" 7042","line":"        .AGAIN => return error.SystemResources,"},
{"lineNum":" 7043","line":"        .BADF => unreachable, // The map exists, but the area maps something that isn\'t a file."},
{"lineNum":" 7044","line":"        .INVAL => return error.InvalidSyscall,"},
{"lineNum":" 7045","line":"        .IO => return error.WouldExceedMaximumResidentSetSize,"},
{"lineNum":" 7046","line":"        .NOMEM => return error.OutOfMemory,"},
{"lineNum":" 7047","line":"        .NOSYS => return error.MadviseUnavailable,"},
{"lineNum":" 7048","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 7049","line":"    }"},
{"lineNum":" 7050","line":"}"},
{"lineNum":" 7051","line":""},
{"lineNum":" 7052","line":"pub const PerfEventOpenError = error{"},
{"lineNum":" 7053","line":"    /// Returned if the perf_event_attr size value is too small (smaller"},
{"lineNum":" 7054","line":"    /// than PERF_ATTR_SIZE_VER0), too big (larger than the page  size),"},
{"lineNum":" 7055","line":"    /// or  larger  than the kernel supports and the extra bytes are not"},
{"lineNum":" 7056","line":"    /// zero.  When E2BIG is returned, the perf_event_attr size field is"},
{"lineNum":" 7057","line":"    /// overwritten by the kernel to be the size of the structure it was"},
{"lineNum":" 7058","line":"    /// expecting."},
{"lineNum":" 7059","line":"    TooBig,"},
{"lineNum":" 7060","line":"    /// Returned when the requested event requires CAP_SYS_ADMIN permis"},
{"lineNum":" 7061","line":"    /// sions  (or a more permissive perf_event paranoid setting).  Some"},
{"lineNum":" 7062","line":"    /// common cases where an unprivileged process  may  encounter  this"},
{"lineNum":" 7063","line":"    /// error:  attaching  to a process owned by a different user; moni"},
{"lineNum":" 7064","line":"    /// toring all processes on a given CPU (i.e.,  specifying  the  pid"},
{"lineNum":" 7065","line":"    /// argument  as  -1); and not setting exclude_kernel when the para"},
{"lineNum":" 7066","line":"    /// noid setting requires it."},
{"lineNum":" 7067","line":"    /// Also:"},
{"lineNum":" 7068","line":"    /// Returned on many (but not all) architectures when an unsupported"},
{"lineNum":" 7069","line":"    /// exclude_hv,  exclude_idle,  exclude_user, or exclude_kernel set"},
{"lineNum":" 7070","line":"    /// ting is specified."},
{"lineNum":" 7071","line":"    /// It can also happen, as with EACCES, when the requested event re"},
{"lineNum":" 7072","line":"    /// quires   CAP_SYS_ADMIN   permissions   (or   a  more  permissive"},
{"lineNum":" 7073","line":"    /// perf_event paranoid setting).  This includes  setting  a  break"},
{"lineNum":" 7074","line":"    /// point on a kernel address, and (since Linux 3.13) setting a ker"},
{"lineNum":" 7075","line":"    /// nel function-trace tracepoint."},
{"lineNum":" 7076","line":"    PermissionDenied,"},
{"lineNum":" 7077","line":"    /// Returned if another event already has exclusive  access  to  the"},
{"lineNum":" 7078","line":"    /// PMU."},
{"lineNum":" 7079","line":"    DeviceBusy,"},
{"lineNum":" 7080","line":"    /// Each  opened  event uses one file descriptor.  If a large number"},
{"lineNum":" 7081","line":"    /// of events are opened, the per-process limit  on  the  number  of"},
{"lineNum":" 7082","line":"    /// open file descriptors will be reached, and no more events can be"},
{"lineNum":" 7083","line":"    /// created."},
{"lineNum":" 7084","line":"    ProcessResources,"},
{"lineNum":" 7085","line":"    EventRequiresUnsupportedCpuFeature,"},
{"lineNum":" 7086","line":"    /// Returned if  you  try  to  add  more  breakpoint"},
{"lineNum":" 7087","line":"    /// events than supported by the hardware."},
{"lineNum":" 7088","line":"    TooManyBreakpoints,"},
{"lineNum":" 7089","line":"    /// Returned  if PERF_SAMPLE_STACK_USER is set in sample_type and it"},
{"lineNum":" 7090","line":"    /// is not supported by hardware."},
{"lineNum":" 7091","line":"    SampleStackNotSupported,"},
{"lineNum":" 7092","line":"    /// Returned if an event requiring a specific  hardware  feature  is"},
{"lineNum":" 7093","line":"    /// requested  but  there is no hardware support.  This includes re"},
{"lineNum":" 7094","line":"    /// questing low-skid events if not supported, branch tracing if  it"},
{"lineNum":" 7095","line":"    /// is not available, sampling if no PMU interrupt is available, and"},
{"lineNum":" 7096","line":"    /// branch stacks for software events."},
{"lineNum":" 7097","line":"    EventNotSupported,"},
{"lineNum":" 7098","line":"    /// Returned  if  PERF_SAMPLE_CALLCHAIN  is   requested   and   sam"},
{"lineNum":" 7099","line":"    /// ple_max_stack   is   larger   than   the  maximum  specified  in"},
{"lineNum":" 7100","line":"    /// /proc/sys/kernel/perf_event_max_stack."},
{"lineNum":" 7101","line":"    SampleMaxStackOverflow,"},
{"lineNum":" 7102","line":"    /// Returned if attempting to attach to a process that does not  exist."},
{"lineNum":" 7103","line":"    ProcessNotFound,"},
{"lineNum":" 7104","line":"} || UnexpectedError;"},
{"lineNum":" 7105","line":""},
{"lineNum":" 7106","line":"pub fn perf_event_open("},
{"lineNum":" 7107","line":"    attr: *linux.perf_event_attr,"},
{"lineNum":" 7108","line":"    pid: pid_t,"},
{"lineNum":" 7109","line":"    cpu: i32,"},
{"lineNum":" 7110","line":"    group_fd: fd_t,"},
{"lineNum":" 7111","line":"    flags: usize,"},
{"lineNum":" 7112","line":") PerfEventOpenError!fd_t {"},
{"lineNum":" 7113","line":"    const rc = system.perf_event_open(attr, pid, cpu, group_fd, flags);"},
{"lineNum":" 7114","line":"    switch (errno(rc)) {"},
{"lineNum":" 7115","line":"        .SUCCESS => return @as(fd_t, @intCast(rc)),"},
{"lineNum":" 7116","line":"        .@\"2BIG\" => return error.TooBig,"},
{"lineNum":" 7117","line":"        .ACCES => return error.PermissionDenied,"},
{"lineNum":" 7118","line":"        .BADF => unreachable, // group_fd file descriptor is not valid."},
{"lineNum":" 7119","line":"        .BUSY => return error.DeviceBusy,"},
{"lineNum":" 7120","line":"        .FAULT => unreachable, // Segmentation fault."},
{"lineNum":" 7121","line":"        .INVAL => unreachable, // Bad attr settings."},
{"lineNum":" 7122","line":"        .INTR => unreachable, // Mixed perf and ftrace handling for a uprobe."},
{"lineNum":" 7123","line":"        .MFILE => return error.ProcessResources,"},
{"lineNum":" 7124","line":"        .NODEV => return error.EventRequiresUnsupportedCpuFeature,"},
{"lineNum":" 7125","line":"        .NOENT => unreachable, // Invalid type setting."},
{"lineNum":" 7126","line":"        .NOSPC => return error.TooManyBreakpoints,"},
{"lineNum":" 7127","line":"        .NOSYS => return error.SampleStackNotSupported,"},
{"lineNum":" 7128","line":"        .OPNOTSUPP => return error.EventNotSupported,"},
{"lineNum":" 7129","line":"        .OVERFLOW => return error.SampleMaxStackOverflow,"},
{"lineNum":" 7130","line":"        .PERM => return error.PermissionDenied,"},
{"lineNum":" 7131","line":"        .SRCH => return error.ProcessNotFound,"},
{"lineNum":" 7132","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 7133","line":"    }"},
{"lineNum":" 7134","line":"}"},
{"lineNum":" 7135","line":""},
{"lineNum":" 7136","line":"pub const TimerFdCreateError = error{"},
{"lineNum":" 7137","line":"    AccessDenied,"},
{"lineNum":" 7138","line":"    ProcessFdQuotaExceeded,"},
{"lineNum":" 7139","line":"    SystemFdQuotaExceeded,"},
{"lineNum":" 7140","line":"    NoDevice,"},
{"lineNum":" 7141","line":"    SystemResources,"},
{"lineNum":" 7142","line":"} || UnexpectedError;"},
{"lineNum":" 7143","line":""},
{"lineNum":" 7144","line":"pub const TimerFdGetError = error{InvalidHandle} || UnexpectedError;"},
{"lineNum":" 7145","line":"pub const TimerFdSetError = TimerFdGetError || error{Canceled};"},
{"lineNum":" 7146","line":""},
{"lineNum":" 7147","line":"pub fn timerfd_create(clokid: i32, flags: u32) TimerFdCreateError!fd_t {"},
{"lineNum":" 7148","line":"    var rc = linux.timerfd_create(clokid, flags);"},
{"lineNum":" 7149","line":"    return switch (errno(rc)) {"},
{"lineNum":" 7150","line":"        .SUCCESS => @as(fd_t, @intCast(rc)),"},
{"lineNum":" 7151","line":"        .INVAL => unreachable,"},
{"lineNum":" 7152","line":"        .MFILE => return error.ProcessFdQuotaExceeded,"},
{"lineNum":" 7153","line":"        .NFILE => return error.SystemFdQuotaExceeded,"},
{"lineNum":" 7154","line":"        .NODEV => return error.NoDevice,"},
{"lineNum":" 7155","line":"        .NOMEM => return error.SystemResources,"},
{"lineNum":" 7156","line":"        .PERM => return error.AccessDenied,"},
{"lineNum":" 7157","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 7158","line":"    };"},
{"lineNum":" 7159","line":"}"},
{"lineNum":" 7160","line":""},
{"lineNum":" 7161","line":"pub fn timerfd_settime(fd: i32, flags: u32, new_value: *const linux.itimerspec, old_value: ?*linux.itimerspec) TimerFdSetError!void {"},
{"lineNum":" 7162","line":"    var rc = linux.timerfd_settime(fd, flags, new_value, old_value);"},
{"lineNum":" 7163","line":"    return switch (errno(rc)) {"},
{"lineNum":" 7164","line":"        .SUCCESS => {},"},
{"lineNum":" 7165","line":"        .BADF => error.InvalidHandle,"},
{"lineNum":" 7166","line":"        .FAULT => unreachable,"},
{"lineNum":" 7167","line":"        .INVAL => unreachable,"},
{"lineNum":" 7168","line":"        .CANCELED => error.Canceled,"},
{"lineNum":" 7169","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 7170","line":"    };"},
{"lineNum":" 7171","line":"}"},
{"lineNum":" 7172","line":""},
{"lineNum":" 7173","line":"pub fn timerfd_gettime(fd: i32) TimerFdGetError!linux.itimerspec {"},
{"lineNum":" 7174","line":"    var curr_value: linux.itimerspec = undefined;"},
{"lineNum":" 7175","line":"    var rc = linux.timerfd_gettime(fd, &curr_value);"},
{"lineNum":" 7176","line":"    return switch (errno(rc)) {"},
{"lineNum":" 7177","line":"        .SUCCESS => return curr_value,"},
{"lineNum":" 7178","line":"        .BADF => error.InvalidHandle,"},
{"lineNum":" 7179","line":"        .FAULT => unreachable,"},
{"lineNum":" 7180","line":"        .INVAL => unreachable,"},
{"lineNum":" 7181","line":"        else => |err| return unexpectedErrno(err),"},
{"lineNum":" 7182","line":"    };"},
{"lineNum":" 7183","line":"}"},
{"lineNum":" 7184","line":""},
{"lineNum":" 7185","line":"pub const PtraceError = error{"},
{"lineNum":" 7186","line":"    DeviceBusy,"},
{"lineNum":" 7187","line":"    InputOutput,"},
{"lineNum":" 7188","line":"    Overflow,"},
{"lineNum":" 7189","line":"    ProcessNotFound,"},
{"lineNum":" 7190","line":"    PermissionDenied,"},
{"lineNum":" 7191","line":"} || UnexpectedError;"},
{"lineNum":" 7192","line":""},
{"lineNum":" 7193","line":"pub fn ptrace(request: u32, pid: pid_t, addr: usize, signal: usize) PtraceError!void {"},
{"lineNum":" 7194","line":"    if (builtin.os.tag == .windows or builtin.os.tag == .wasi)"},
{"lineNum":" 7195","line":"        @compileError(\"Unsupported OS\");"},
{"lineNum":" 7196","line":""},
{"lineNum":" 7197","line":"    return switch (builtin.os.tag) {"},
{"lineNum":" 7198","line":"        .linux => switch (errno(linux.ptrace(request, pid, addr, signal, 0))) {"},
{"lineNum":" 7199","line":"            .SUCCESS => {},"},
{"lineNum":" 7200","line":"            .SRCH => error.ProcessNotFound,"},
{"lineNum":" 7201","line":"            .FAULT => unreachable,"},
{"lineNum":" 7202","line":"            .INVAL => unreachable,"},
{"lineNum":" 7203","line":"            .IO => return error.InputOutput,"},
{"lineNum":" 7204","line":"            .PERM => error.PermissionDenied,"},
{"lineNum":" 7205","line":"            .BUSY => error.DeviceBusy,"},
{"lineNum":" 7206","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 7207","line":"        },"},
{"lineNum":" 7208","line":""},
{"lineNum":" 7209","line":"        .macos, .ios, .tvos, .watchos => switch (errno(darwin.ptrace("},
{"lineNum":" 7210","line":"            math.cast(i32, request) orelse return error.Overflow,"},
{"lineNum":" 7211","line":"            pid,"},
{"lineNum":" 7212","line":"            @as(?[*]u8, @ptrFromInt(addr)),"},
{"lineNum":" 7213","line":"            math.cast(i32, signal) orelse return error.Overflow,"},
{"lineNum":" 7214","line":"        ))) {"},
{"lineNum":" 7215","line":"            .SUCCESS => {},"},
{"lineNum":" 7216","line":"            .SRCH => error.ProcessNotFound,"},
{"lineNum":" 7217","line":"            .INVAL => unreachable,"},
{"lineNum":" 7218","line":"            .PERM => error.PermissionDenied,"},
{"lineNum":" 7219","line":"            .BUSY => error.DeviceBusy,"},
{"lineNum":" 7220","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 7221","line":"        },"},
{"lineNum":" 7222","line":""},
{"lineNum":" 7223","line":"        else => switch (errno(system.ptrace(request, pid, addr, signal))) {"},
{"lineNum":" 7224","line":"            .SUCCESS => {},"},
{"lineNum":" 7225","line":"            .SRCH => error.ProcessNotFound,"},
{"lineNum":" 7226","line":"            .INVAL => unreachable,"},
{"lineNum":" 7227","line":"            .PERM => error.PermissionDenied,"},
{"lineNum":" 7228","line":"            .BUSY => error.DeviceBusy,"},
{"lineNum":" 7229","line":"            else => |err| return unexpectedErrno(err),"},
{"lineNum":" 7230","line":"        },"},
{"lineNum":" 7231","line":"    };"},
{"lineNum":" 7232","line":"}"},
{"lineNum":" 7233","line":""},
{"lineNum":" 7234","line":"const lfs64_abi = builtin.os.tag == .linux and builtin.link_libc and builtin.abi.isGnu();"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test", "date" : "2024-04-26 16:14:49", "instrumented" : 276, "covered" : 48,};
var merged_data = [];
