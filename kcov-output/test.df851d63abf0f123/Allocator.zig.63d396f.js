var data = {lines:[
{"lineNum":"    1","line":"//! The standard memory allocation interface."},
{"lineNum":"    2","line":""},
{"lineNum":"    3","line":"const std = @import(\"../std.zig\");"},
{"lineNum":"    4","line":"const assert = std.debug.assert;"},
{"lineNum":"    5","line":"const math = std.math;"},
{"lineNum":"    6","line":"const mem = std.mem;"},
{"lineNum":"    7","line":"const Allocator = @This();"},
{"lineNum":"    8","line":"const builtin = @import(\"builtin\");"},
{"lineNum":"    9","line":""},
{"lineNum":"   10","line":"pub const Error = error{OutOfMemory};"},
{"lineNum":"   11","line":"pub const Log2Align = math.Log2Int(usize);"},
{"lineNum":"   12","line":""},
{"lineNum":"   13","line":"// The type erased pointer to the allocator implementation"},
{"lineNum":"   14","line":"ptr: *anyopaque,"},
{"lineNum":"   15","line":"vtable: *const VTable,"},
{"lineNum":"   16","line":""},
{"lineNum":"   17","line":"pub const VTable = struct {"},
{"lineNum":"   18","line":"    /// Attempt to allocate exactly `len` bytes aligned to `1 << ptr_align`."},
{"lineNum":"   19","line":"    ///"},
{"lineNum":"   20","line":"    /// `ret_addr` is optionally provided as the first return address of the"},
{"lineNum":"   21","line":"    /// allocation call stack. If the value is `0` it means no return address"},
{"lineNum":"   22","line":"    /// has been provided."},
{"lineNum":"   23","line":"    alloc: *const fn (ctx: *anyopaque, len: usize, ptr_align: u8, ret_addr: usize) ?[*]u8,"},
{"lineNum":"   24","line":""},
{"lineNum":"   25","line":"    /// Attempt to expand or shrink memory in place. `buf.len` must equal the"},
{"lineNum":"   26","line":"    /// length requested from the most recent successful call to `alloc` or"},
{"lineNum":"   27","line":"    /// `resize`. `buf_align` must equal the same value that was passed as the"},
{"lineNum":"   28","line":"    /// `ptr_align` parameter to the original `alloc` call."},
{"lineNum":"   29","line":"    ///"},
{"lineNum":"   30","line":"    /// A result of `true` indicates the resize was successful and the"},
{"lineNum":"   31","line":"    /// allocation now has the same address but a size of `new_len`. `false`"},
{"lineNum":"   32","line":"    /// indicates the resize could not be completed without moving the"},
{"lineNum":"   33","line":"    /// allocation to a different address."},
{"lineNum":"   34","line":"    ///"},
{"lineNum":"   35","line":"    /// `new_len` must be greater than zero."},
{"lineNum":"   36","line":"    ///"},
{"lineNum":"   37","line":"    /// `ret_addr` is optionally provided as the first return address of the"},
{"lineNum":"   38","line":"    /// allocation call stack. If the value is `0` it means no return address"},
{"lineNum":"   39","line":"    /// has been provided."},
{"lineNum":"   40","line":"    resize: *const fn (ctx: *anyopaque, buf: []u8, buf_align: u8, new_len: usize, ret_addr: usize) bool,"},
{"lineNum":"   41","line":""},
{"lineNum":"   42","line":"    /// Free and invalidate a buffer."},
{"lineNum":"   43","line":"    ///"},
{"lineNum":"   44","line":"    /// `buf.len` must equal the most recent length returned by `alloc` or"},
{"lineNum":"   45","line":"    /// given to a successful `resize` call."},
{"lineNum":"   46","line":"    ///"},
{"lineNum":"   47","line":"    /// `buf_align` must equal the same value that was passed as the"},
{"lineNum":"   48","line":"    /// `ptr_align` parameter to the original `alloc` call."},
{"lineNum":"   49","line":"    ///"},
{"lineNum":"   50","line":"    /// `ret_addr` is optionally provided as the first return address of the"},
{"lineNum":"   51","line":"    /// allocation call stack. If the value is `0` it means no return address"},
{"lineNum":"   52","line":"    /// has been provided."},
{"lineNum":"   53","line":"    free: *const fn (ctx: *anyopaque, buf: []u8, buf_align: u8, ret_addr: usize) void,"},
{"lineNum":"   54","line":"};"},
{"lineNum":"   55","line":""},
{"lineNum":"   56","line":"pub fn noResize("},
{"lineNum":"   57","line":"    self: *anyopaque,"},
{"lineNum":"   58","line":"    buf: []u8,"},
{"lineNum":"   59","line":"    log2_buf_align: u8,"},
{"lineNum":"   60","line":"    new_len: usize,"},
{"lineNum":"   61","line":"    ret_addr: usize,"},
{"lineNum":"   62","line":") bool {"},
{"lineNum":"   63","line":"    _ = self;"},
{"lineNum":"   64","line":"    _ = buf;"},
{"lineNum":"   65","line":"    _ = log2_buf_align;"},
{"lineNum":"   66","line":"    _ = new_len;"},
{"lineNum":"   67","line":"    _ = ret_addr;"},
{"lineNum":"   68","line":"    return false;"},
{"lineNum":"   69","line":"}"},
{"lineNum":"   70","line":""},
{"lineNum":"   71","line":"pub fn noFree("},
{"lineNum":"   72","line":"    self: *anyopaque,"},
{"lineNum":"   73","line":"    buf: []u8,"},
{"lineNum":"   74","line":"    log2_buf_align: u8,"},
{"lineNum":"   75","line":"    ret_addr: usize,"},
{"lineNum":"   76","line":") void {"},
{"lineNum":"   77","line":"    _ = self;"},
{"lineNum":"   78","line":"    _ = buf;"},
{"lineNum":"   79","line":"    _ = log2_buf_align;"},
{"lineNum":"   80","line":"    _ = ret_addr;"},
{"lineNum":"   81","line":"}"},
{"lineNum":"   82","line":""},
{"lineNum":"   83","line":"/// This function is not intended to be called except from within the"},
{"lineNum":"   84","line":"/// implementation of an Allocator"},
{"lineNum":"   85","line":"pub inline fn rawAlloc(self: Allocator, len: usize, ptr_align: u8, ret_addr: usize) ?[*]u8 {"},
{"lineNum":"   86","line":"    return self.vtable.alloc(self.ptr, len, ptr_align, ret_addr);","class":"linePartCov","hits":"10","order":"237","possible_hits":"16",},
{"lineNum":"   87","line":"}"},
{"lineNum":"   88","line":""},
{"lineNum":"   89","line":"/// This function is not intended to be called except from within the"},
{"lineNum":"   90","line":"/// implementation of an Allocator"},
{"lineNum":"   91","line":"pub inline fn rawResize(self: Allocator, buf: []u8, log2_buf_align: u8, new_len: usize, ret_addr: usize) bool {"},
{"lineNum":"   92","line":"    return self.vtable.resize(self.ptr, buf, log2_buf_align, new_len, ret_addr);","class":"linePartCov","hits":"6","order":"803","possible_hits":"21",},
{"lineNum":"   93","line":"}"},
{"lineNum":"   94","line":""},
{"lineNum":"   95","line":"/// This function is not intended to be called except from within the"},
{"lineNum":"   96","line":"/// implementation of an Allocator"},
{"lineNum":"   97","line":"pub inline fn rawFree(self: Allocator, buf: []u8, log2_buf_align: u8, ret_addr: usize) void {"},
{"lineNum":"   98","line":"    return self.vtable.free(self.ptr, buf, log2_buf_align, ret_addr);","class":"linePartCov","hits":"8","order":"322","possible_hits":"33",},
{"lineNum":"   99","line":"}"},
{"lineNum":"  100","line":""},
{"lineNum":"  101","line":"/// Returns a pointer to undefined memory."},
{"lineNum":"  102","line":"/// Call `destroy` with the result to free the memory."},
{"lineNum":"  103","line":"pub fn create(self: Allocator, comptime T: type) Error!*T {","class":"linePartCov","hits":"1","order":"1346","possible_hits":"7",},
{"lineNum":"  104","line":"    if (@sizeOf(T) == 0) return @as(*T, @ptrFromInt(math.maxInt(usize)));"},
{"lineNum":"  105","line":"    const ptr: *T = @ptrCast(try self.allocBytesWithAlignment(@alignOf(T), @sizeOf(T), @returnAddress()));","class":"linePartCov","hits":"1","order":"1347","possible_hits":"7",},
{"lineNum":"  106","line":"    return ptr;","class":"linePartCov","hits":"1","order":"1378","possible_hits":"7",},
{"lineNum":"  107","line":"}"},
{"lineNum":"  108","line":""},
{"lineNum":"  109","line":"/// `ptr` should be the return value of `create`, or otherwise"},
{"lineNum":"  110","line":"/// have the same address and alignment property."},
{"lineNum":"  111","line":"pub fn destroy(self: Allocator, ptr: anytype) void {","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  112","line":"    const info = @typeInfo(@TypeOf(ptr)).Pointer;"},
{"lineNum":"  113","line":"    if (info.size != .One) @compileError(\"ptr must be a single item pointer\");"},
{"lineNum":"  114","line":"    const T = info.child;"},
{"lineNum":"  115","line":"    if (@sizeOf(T) == 0) return;"},
{"lineNum":"  116","line":"    const non_const_ptr = @as([*]u8, @ptrCast(@constCast(ptr)));","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  117","line":"    self.rawFree(non_const_ptr[0..@sizeOf(T)], log2a(info.alignment), @returnAddress());","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  118","line":"}"},
{"lineNum":"  119","line":""},
{"lineNum":"  120","line":"/// Allocates an array of `n` items of type `T` and sets all the"},
{"lineNum":"  121","line":"/// items to `undefined`. Depending on the Allocator"},
{"lineNum":"  122","line":"/// implementation, it may be required to call `free` once the"},
{"lineNum":"  123","line":"/// memory is no longer needed, to avoid a resource leak. If the"},
{"lineNum":"  124","line":"/// `Allocator` implementation is unknown, then correct code will"},
{"lineNum":"  125","line":"/// call `free` when done."},
{"lineNum":"  126","line":"///"},
{"lineNum":"  127","line":"/// For allocating a single item, see `create`."},
{"lineNum":"  128","line":"pub fn alloc(self: Allocator, comptime T: type, n: usize) Error![]T {","class":"linePartCov","hits":"1","order":"1444","possible_hits":"4",},
{"lineNum":"  129","line":"    return self.allocAdvancedWithRetAddr(T, null, n, @returnAddress());","class":"linePartCov","hits":"3","order":"1445","possible_hits":"12",},
{"lineNum":"  130","line":"}"},
{"lineNum":"  131","line":""},
{"lineNum":"  132","line":"pub fn allocWithOptions("},
{"lineNum":"  133","line":"    self: Allocator,"},
{"lineNum":"  134","line":"    comptime Elem: type,"},
{"lineNum":"  135","line":"    n: usize,"},
{"lineNum":"  136","line":"    /// null means naturally aligned"},
{"lineNum":"  137","line":"    comptime optional_alignment: ?u29,"},
{"lineNum":"  138","line":"    comptime optional_sentinel: ?Elem,"},
{"lineNum":"  139","line":") Error!AllocWithOptionsPayload(Elem, optional_alignment, optional_sentinel) {"},
{"lineNum":"  140","line":"    return self.allocWithOptionsRetAddr(Elem, n, optional_alignment, optional_sentinel, @returnAddress());"},
{"lineNum":"  141","line":"}"},
{"lineNum":"  142","line":""},
{"lineNum":"  143","line":"pub fn allocWithOptionsRetAddr("},
{"lineNum":"  144","line":"    self: Allocator,"},
{"lineNum":"  145","line":"    comptime Elem: type,"},
{"lineNum":"  146","line":"    n: usize,"},
{"lineNum":"  147","line":"    /// null means naturally aligned"},
{"lineNum":"  148","line":"    comptime optional_alignment: ?u29,"},
{"lineNum":"  149","line":"    comptime optional_sentinel: ?Elem,"},
{"lineNum":"  150","line":"    return_address: usize,"},
{"lineNum":"  151","line":") Error!AllocWithOptionsPayload(Elem, optional_alignment, optional_sentinel) {"},
{"lineNum":"  152","line":"    if (optional_sentinel) |sentinel| {"},
{"lineNum":"  153","line":"        const ptr = try self.allocAdvancedWithRetAddr(Elem, optional_alignment, n + 1, return_address);"},
{"lineNum":"  154","line":"        ptr[n] = sentinel;"},
{"lineNum":"  155","line":"        return ptr[0..n :sentinel];"},
{"lineNum":"  156","line":"    } else {"},
{"lineNum":"  157","line":"        return self.allocAdvancedWithRetAddr(Elem, optional_alignment, n, return_address);"},
{"lineNum":"  158","line":"    }"},
{"lineNum":"  159","line":"}"},
{"lineNum":"  160","line":""},
{"lineNum":"  161","line":"fn AllocWithOptionsPayload(comptime Elem: type, comptime alignment: ?u29, comptime sentinel: ?Elem) type {"},
{"lineNum":"  162","line":"    if (sentinel) |s| {"},
{"lineNum":"  163","line":"        return [:s]align(alignment orelse @alignOf(Elem)) Elem;"},
{"lineNum":"  164","line":"    } else {"},
{"lineNum":"  165","line":"        return []align(alignment orelse @alignOf(Elem)) Elem;"},
{"lineNum":"  166","line":"    }"},
{"lineNum":"  167","line":"}"},
{"lineNum":"  168","line":""},
{"lineNum":"  169","line":"/// Allocates an array of `n + 1` items of type `T` and sets the first `n`"},
{"lineNum":"  170","line":"/// items to `undefined` and the last item to `sentinel`. Depending on the"},
{"lineNum":"  171","line":"/// Allocator implementation, it may be required to call `free` once the"},
{"lineNum":"  172","line":"/// memory is no longer needed, to avoid a resource leak. If the"},
{"lineNum":"  173","line":"/// `Allocator` implementation is unknown, then correct code will"},
{"lineNum":"  174","line":"/// call `free` when done."},
{"lineNum":"  175","line":"///"},
{"lineNum":"  176","line":"/// For allocating a single item, see `create`."},
{"lineNum":"  177","line":"pub fn allocSentinel("},
{"lineNum":"  178","line":"    self: Allocator,"},
{"lineNum":"  179","line":"    comptime Elem: type,"},
{"lineNum":"  180","line":"    n: usize,"},
{"lineNum":"  181","line":"    comptime sentinel: Elem,"},
{"lineNum":"  182","line":") Error![:sentinel]Elem {"},
{"lineNum":"  183","line":"    return self.allocWithOptionsRetAddr(Elem, n, null, sentinel, @returnAddress());"},
{"lineNum":"  184","line":"}"},
{"lineNum":"  185","line":""},
{"lineNum":"  186","line":"pub fn alignedAlloc("},
{"lineNum":"  187","line":"    self: Allocator,"},
{"lineNum":"  188","line":"    comptime T: type,"},
{"lineNum":"  189","line":"    /// null means naturally aligned"},
{"lineNum":"  190","line":"    comptime alignment: ?u29,"},
{"lineNum":"  191","line":"    n: usize,"},
{"lineNum":"  192","line":") Error![]align(alignment orelse @alignOf(T)) T {","class":"linePartCov","hits":"8","order":"219","possible_hits":"21",},
{"lineNum":"  193","line":"    return self.allocAdvancedWithRetAddr(T, alignment, n, @returnAddress());","class":"linePartCov","hits":"24","order":"220","possible_hits":"63",},
{"lineNum":"  194","line":"}"},
{"lineNum":"  195","line":""},
{"lineNum":"  196","line":"pub inline fn allocAdvancedWithRetAddr("},
{"lineNum":"  197","line":"    self: Allocator,"},
{"lineNum":"  198","line":"    comptime T: type,"},
{"lineNum":"  199","line":"    /// null means naturally aligned"},
{"lineNum":"  200","line":"    comptime alignment: ?u29,"},
{"lineNum":"  201","line":"    n: usize,"},
{"lineNum":"  202","line":"    return_address: usize,"},
{"lineNum":"  203","line":") Error![]align(alignment orelse @alignOf(T)) T {"},
{"lineNum":"  204","line":"    const a = alignment orelse @alignOf(T);","class":"linePartCov","hits":"2","order":"301","possible_hits":"4",},
{"lineNum":"  205","line":"    const ptr: [*]align(a) T = @ptrCast(try self.allocWithSizeAndAlignment(@sizeOf(T), a, n, return_address));","class":"linePartCov","hits":"9","order":"221","possible_hits":"52",},
{"lineNum":"  206","line":"    return ptr[0..n];","class":"linePartCov","hits":"9","order":"255","possible_hits":"26",},
{"lineNum":"  207","line":"}"},
{"lineNum":"  208","line":""},
{"lineNum":"  209","line":"fn allocWithSizeAndAlignment(self: Allocator, comptime size: usize, comptime alignment: u29, n: usize, return_address: usize) Error![*]align(alignment) u8 {","class":"linePartCov","hits":"7","order":"222","possible_hits":"17",},
{"lineNum":"  210","line":"    const byte_count = math.mul(usize, size, n) catch return Error.OutOfMemory;","class":"linePartCov","hits":"14","order":"223","possible_hits":"34",},
{"lineNum":"  211","line":"    return self.allocBytesWithAlignment(alignment, byte_count, return_address);","class":"linePartCov","hits":"14","order":"228","possible_hits":"34",},
{"lineNum":"  212","line":"}"},
{"lineNum":"  213","line":""},
{"lineNum":"  214","line":"fn allocBytesWithAlignment(self: Allocator, comptime alignment: u29, byte_count: usize, return_address: usize) Error![*]align(alignment) u8 {","class":"linePartCov","hits":"4","order":"229","possible_hits":"5",},
{"lineNum":"  215","line":"    // The Zig Allocator interface is not intended to solve alignments beyond"},
{"lineNum":"  216","line":"    // the minimum OS page size. For these use cases, the caller must use OS"},
{"lineNum":"  217","line":"    // APIs directly."},
{"lineNum":"  218","line":"    comptime assert(alignment <= mem.page_size);"},
{"lineNum":"  219","line":""},
{"lineNum":"  220","line":"    if (byte_count == 0) {","class":"linePartCov","hits":"4","order":"230","possible_hits":"5",},
{"lineNum":"  221","line":"        const ptr = comptime std.mem.alignBackward(usize, math.maxInt(usize), alignment);","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  222","line":"        return @as([*]align(alignment) u8, @ptrFromInt(ptr));","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"  223","line":"    }"},
{"lineNum":"  224","line":""},
{"lineNum":"  225","line":"    const byte_ptr = self.rawAlloc(byte_count, log2a(alignment), return_address) orelse return Error.OutOfMemory;","class":"linePartCov","hits":"8","order":"231","possible_hits":"15",},
{"lineNum":"  226","line":"    // TODO: https://github.com/ziglang/zig/issues/4298"},
{"lineNum":"  227","line":"    @memset(byte_ptr[0..byte_count], undefined);","class":"linePartCov","hits":"12","order":"253","possible_hits":"15",},
{"lineNum":"  228","line":"    return @as([*]align(alignment) u8, @alignCast(byte_ptr));","class":"linePartCov","hits":"7","order":"254","possible_hits":"9",},
{"lineNum":"  229","line":"}"},
{"lineNum":"  230","line":""},
{"lineNum":"  231","line":"/// Requests to modify the size of an allocation. It is guaranteed to not move"},
{"lineNum":"  232","line":"/// the pointer, however the allocator implementation may refuse the resize"},
{"lineNum":"  233","line":"/// request by returning `false`."},
{"lineNum":"  234","line":"pub fn resize(self: Allocator, old_mem: anytype, new_n: usize) bool {","class":"linePartCov","hits":"6","order":"214","possible_hits":"18",},
{"lineNum":"  235","line":"    const Slice = @typeInfo(@TypeOf(old_mem)).Pointer;"},
{"lineNum":"  236","line":"    const T = Slice.child;"},
{"lineNum":"  237","line":"    if (new_n == 0) {","class":"linePartCov","hits":"6","order":"215","possible_hits":"18",},
{"lineNum":"  238","line":"        self.free(old_mem);","class":"lineNoCov","hits":"0","possible_hits":"18",},
{"lineNum":"  239","line":"        return true;","class":"lineNoCov","hits":"0","possible_hits":"18",},
{"lineNum":"  240","line":"    }"},
{"lineNum":"  241","line":"    if (old_mem.len == 0) {","class":"linePartCov","hits":"6","order":"216","possible_hits":"18",},
{"lineNum":"  242","line":"        return false;","class":"linePartCov","hits":"6","order":"217","possible_hits":"18",},
{"lineNum":"  243","line":"    }"},
{"lineNum":"  244","line":"    const old_byte_slice = mem.sliceAsBytes(old_mem);","class":"linePartCov","hits":"5","order":"800","possible_hits":"18",},
{"lineNum":"  245","line":"    // I would like to use saturating multiplication here, but LLVM cannot lower it"},
{"lineNum":"  246","line":"    // on WebAssembly: https://github.com/ziglang/zig/issues/9660"},
{"lineNum":"  247","line":"    //const new_byte_count = new_n *| @sizeOf(T);"},
{"lineNum":"  248","line":"    const new_byte_count = math.mul(usize, @sizeOf(T), new_n) catch return false;","class":"linePartCov","hits":"15","order":"801","possible_hits":"54",},
{"lineNum":"  249","line":"    return self.rawResize(old_byte_slice, log2a(Slice.alignment), new_byte_count, @returnAddress());","class":"linePartCov","hits":"10","order":"802","possible_hits":"36",},
{"lineNum":"  250","line":"}"},
{"lineNum":"  251","line":""},
{"lineNum":"  252","line":"/// This function requests a new byte size for an existing allocation, which"},
{"lineNum":"  253","line":"/// can be larger, smaller, or the same size as the old memory allocation."},
{"lineNum":"  254","line":"/// If `new_n` is 0, this is the same as `free` and it always succeeds."},
{"lineNum":"  255","line":"pub fn realloc(self: Allocator, old_mem: anytype, new_n: usize) t: {"},
{"lineNum":"  256","line":"    const Slice = @typeInfo(@TypeOf(old_mem)).Pointer;"},
{"lineNum":"  257","line":"    break :t Error![]align(Slice.alignment) Slice.child;"},
{"lineNum":"  258","line":"} {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  259","line":"    return self.reallocAdvanced(old_mem, new_n, @returnAddress());","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  260","line":"}"},
{"lineNum":"  261","line":""},
{"lineNum":"  262","line":"pub fn reallocAdvanced("},
{"lineNum":"  263","line":"    self: Allocator,"},
{"lineNum":"  264","line":"    old_mem: anytype,"},
{"lineNum":"  265","line":"    new_n: usize,"},
{"lineNum":"  266","line":"    return_address: usize,"},
{"lineNum":"  267","line":") t: {"},
{"lineNum":"  268","line":"    const Slice = @typeInfo(@TypeOf(old_mem)).Pointer;"},
{"lineNum":"  269","line":"    break :t Error![]align(Slice.alignment) Slice.child;"},
{"lineNum":"  270","line":"} {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  271","line":"    const Slice = @typeInfo(@TypeOf(old_mem)).Pointer;"},
{"lineNum":"  272","line":"    const T = Slice.child;"},
{"lineNum":"  273","line":"    if (old_mem.len == 0) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  274","line":"        return self.allocAdvancedWithRetAddr(T, Slice.alignment, new_n, return_address);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  275","line":"    }"},
{"lineNum":"  276","line":"    if (new_n == 0) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  277","line":"        self.free(old_mem);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  278","line":"        const ptr = comptime std.mem.alignBackward(usize, math.maxInt(usize), Slice.alignment);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  279","line":"        return @as([*]align(Slice.alignment) T, @ptrFromInt(ptr))[0..0];","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  280","line":"    }"},
{"lineNum":"  281","line":""},
{"lineNum":"  282","line":"    const old_byte_slice = mem.sliceAsBytes(old_mem);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  283","line":"    const byte_count = math.mul(usize, @sizeOf(T), new_n) catch return Error.OutOfMemory;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  284","line":"    // Note: can\'t set shrunk memory to undefined as memory shouldn\'t be modified on realloc failure"},
{"lineNum":"  285","line":"    if (mem.isAligned(@intFromPtr(old_byte_slice.ptr), Slice.alignment)) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  286","line":"        if (self.rawResize(old_byte_slice, log2a(Slice.alignment), byte_count, return_address)) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  287","line":"            const new_bytes: []align(Slice.alignment) u8 = @alignCast(old_byte_slice.ptr[0..byte_count]);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  288","line":"            return mem.bytesAsSlice(T, new_bytes);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  289","line":"        }"},
{"lineNum":"  290","line":"    }"},
{"lineNum":"  291","line":""},
{"lineNum":"  292","line":"    const new_mem = self.rawAlloc(byte_count, log2a(Slice.alignment), return_address) orelse","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  293","line":"        return error.OutOfMemory;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  294","line":"    const copy_len = @min(byte_count, old_byte_slice.len);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  295","line":"    @memcpy(new_mem[0..copy_len], old_byte_slice[0..copy_len]);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  296","line":"    // TODO https://github.com/ziglang/zig/issues/4298"},
{"lineNum":"  297","line":"    @memset(old_byte_slice, undefined);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  298","line":"    self.rawFree(old_byte_slice, log2a(Slice.alignment), return_address);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  299","line":""},
{"lineNum":"  300","line":"    const new_bytes: []align(Slice.alignment) u8 = @alignCast(new_mem[0..byte_count]);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  301","line":"    return mem.bytesAsSlice(T, new_bytes);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  302","line":"}"},
{"lineNum":"  303","line":""},
{"lineNum":"  304","line":"/// Free an array allocated with `alloc`. To free a single item,"},
{"lineNum":"  305","line":"/// see `destroy`."},
{"lineNum":"  306","line":"pub fn free(self: Allocator, memory: anytype) void {","class":"linePartCov","hits":"8","order":"258","possible_hits":"25",},
{"lineNum":"  307","line":"    const Slice = @typeInfo(@TypeOf(memory)).Pointer;"},
{"lineNum":"  308","line":"    const bytes = mem.sliceAsBytes(memory);","class":"linePartCov","hits":"8","order":"259","possible_hits":"25",},
{"lineNum":"  309","line":"    const bytes_len = bytes.len + if (Slice.sentinel != null) @sizeOf(Slice.child) else 0;","class":"linePartCov","hits":"8","order":"263","possible_hits":"25",},
{"lineNum":"  310","line":"    if (bytes_len == 0) return;","class":"linePartCov","hits":"14","order":"264","possible_hits":"50",},
{"lineNum":"  311","line":"    const non_const_ptr = @constCast(bytes.ptr);","class":"linePartCov","hits":"7","order":"318","possible_hits":"25",},
{"lineNum":"  312","line":"    // TODO: https://github.com/ziglang/zig/issues/4298"},
{"lineNum":"  313","line":"    @memset(non_const_ptr[0..bytes_len], undefined);","class":"linePartCov","hits":"21","order":"319","possible_hits":"75",},
{"lineNum":"  314","line":"    self.rawFree(non_const_ptr[0..bytes_len], log2a(Slice.alignment), @returnAddress());","class":"linePartCov","hits":"21","order":"320","possible_hits":"75",},
{"lineNum":"  315","line":"}"},
{"lineNum":"  316","line":""},
{"lineNum":"  317","line":"/// Copies `m` to newly allocated memory. Caller owns the memory."},
{"lineNum":"  318","line":"pub fn dupe(allocator: Allocator, comptime T: type, m: []const T) ![]T {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  319","line":"    const new_buf = try allocator.alloc(T, m.len);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  320","line":"    @memcpy(new_buf, m);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  321","line":"    return new_buf;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  322","line":"}"},
{"lineNum":"  323","line":""},
{"lineNum":"  324","line":"/// Copies `m` to newly allocated memory, with a null-terminated element. Caller owns the memory."},
{"lineNum":"  325","line":"pub fn dupeZ(allocator: Allocator, comptime T: type, m: []const T) ![:0]T {"},
{"lineNum":"  326","line":"    const new_buf = try allocator.alloc(T, m.len + 1);"},
{"lineNum":"  327","line":"    @memcpy(new_buf[0..m.len], m);"},
{"lineNum":"  328","line":"    new_buf[m.len] = 0;"},
{"lineNum":"  329","line":"    return new_buf[0..m.len :0];"},
{"lineNum":"  330","line":"}"},
{"lineNum":"  331","line":""},
{"lineNum":"  332","line":"/// TODO replace callsites with `@log2` after this proposal is implemented:"},
{"lineNum":"  333","line":"/// https://github.com/ziglang/zig/issues/13642"},
{"lineNum":"  334","line":"inline fn log2a(x: anytype) switch (@typeInfo(@TypeOf(x))) {"},
{"lineNum":"  335","line":"    .Int => math.Log2Int(@TypeOf(x)),","class":"linePartCov","hits":"4","order":"232","possible_hits":"5",},
{"lineNum":"  336","line":"    .ComptimeInt => comptime_int,"},
{"lineNum":"  337","line":"    else => @compileError(\"int please\"),"},
{"lineNum":"  338","line":"} {"},
{"lineNum":"  339","line":"    switch (@typeInfo(@TypeOf(x))) {"},
{"lineNum":"  340","line":"        .Int => return math.log2_int(@TypeOf(x), x),","class":"linePartCov","hits":"4","order":"233","possible_hits":"5",},
{"lineNum":"  341","line":"        .ComptimeInt => return math.log2(x),","class":"linePartCov","hits":"12","order":"321","possible_hits":"51",},
{"lineNum":"  342","line":"        else => @compileError(\"bad\"),"},
{"lineNum":"  343","line":"    }"},
{"lineNum":"  344","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test", "date" : "2024-04-26 16:14:49", "instrumented" : 72, "covered" : 38,};
var merged_data = [];
