var data = {lines:[
{"lineNum":"    1","line":"const std = @import(\"std.zig\");"},
{"lineNum":"    2","line":"const mem = std.mem;"},
{"lineNum":"    3","line":""},
{"lineNum":"    4","line":"/// Comptime string map optimized for small sets of disparate string keys."},
{"lineNum":"    5","line":"/// Works by separating the keys by length at comptime and only checking strings of"},
{"lineNum":"    6","line":"/// equal length at runtime."},
{"lineNum":"    7","line":"///"},
{"lineNum":"    8","line":"/// `kvs_list` expects a list of `struct { []const u8, V }` (key-value pair) tuples."},
{"lineNum":"    9","line":"/// You can pass `struct { []const u8 }` (only keys) tuples if `V` is `void`."},
{"lineNum":"   10","line":"pub fn ComptimeStringMap(comptime V: type, comptime kvs_list: anytype) type {"},
{"lineNum":"   11","line":"    const precomputed = comptime blk: {"},
{"lineNum":"   12","line":"        @setEvalBranchQuota(1500);"},
{"lineNum":"   13","line":"        const KV = struct {"},
{"lineNum":"   14","line":"            key: []const u8,"},
{"lineNum":"   15","line":"            value: V,"},
{"lineNum":"   16","line":"        };"},
{"lineNum":"   17","line":"        var sorted_kvs: [kvs_list.len]KV = undefined;"},
{"lineNum":"   18","line":"        for (kvs_list, 0..) |kv, i| {"},
{"lineNum":"   19","line":"            if (V != void) {"},
{"lineNum":"   20","line":"                sorted_kvs[i] = .{ .key = kv.@\"0\", .value = kv.@\"1\" };"},
{"lineNum":"   21","line":"            } else {"},
{"lineNum":"   22","line":"                sorted_kvs[i] = .{ .key = kv.@\"0\", .value = {} };"},
{"lineNum":"   23","line":"            }"},
{"lineNum":"   24","line":"        }"},
{"lineNum":"   25","line":""},
{"lineNum":"   26","line":"        const SortContext = struct {"},
{"lineNum":"   27","line":"            kvs: []KV,"},
{"lineNum":"   28","line":""},
{"lineNum":"   29","line":"            pub fn lessThan(ctx: @This(), a: usize, b: usize) bool {"},
{"lineNum":"   30","line":"                return ctx.kvs[a].key.len < ctx.kvs[b].key.len;"},
{"lineNum":"   31","line":"            }"},
{"lineNum":"   32","line":""},
{"lineNum":"   33","line":"            pub fn swap(ctx: @This(), a: usize, b: usize) void {"},
{"lineNum":"   34","line":"                return std.mem.swap(KV, &ctx.kvs[a], &ctx.kvs[b]);"},
{"lineNum":"   35","line":"            }"},
{"lineNum":"   36","line":"        };"},
{"lineNum":"   37","line":"        mem.sortUnstableContext(0, sorted_kvs.len, SortContext{ .kvs = &sorted_kvs });"},
{"lineNum":"   38","line":""},
{"lineNum":"   39","line":"        const min_len = sorted_kvs[0].key.len;"},
{"lineNum":"   40","line":"        const max_len = sorted_kvs[sorted_kvs.len - 1].key.len;"},
{"lineNum":"   41","line":"        var len_indexes: [max_len + 1]usize = undefined;"},
{"lineNum":"   42","line":"        var len: usize = 0;"},
{"lineNum":"   43","line":"        var i: usize = 0;"},
{"lineNum":"   44","line":"        while (len <= max_len) : (len += 1) {"},
{"lineNum":"   45","line":"            // find the first keyword len == len"},
{"lineNum":"   46","line":"            while (len > sorted_kvs[i].key.len) {"},
{"lineNum":"   47","line":"                i += 1;"},
{"lineNum":"   48","line":"            }"},
{"lineNum":"   49","line":"            len_indexes[len] = i;"},
{"lineNum":"   50","line":"        }"},
{"lineNum":"   51","line":"        break :blk .{"},
{"lineNum":"   52","line":"            .min_len = min_len,"},
{"lineNum":"   53","line":"            .max_len = max_len,"},
{"lineNum":"   54","line":"            .sorted_kvs = sorted_kvs,"},
{"lineNum":"   55","line":"            .len_indexes = len_indexes,"},
{"lineNum":"   56","line":"        };"},
{"lineNum":"   57","line":"    };"},
{"lineNum":"   58","line":""},
{"lineNum":"   59","line":"    return struct {"},
{"lineNum":"   60","line":"        /// Array of `struct { key: []const u8, value: V }` where `value` is `void{}` if `V` is `void`."},
{"lineNum":"   61","line":"        /// Sorted by `key` length."},
{"lineNum":"   62","line":"        pub const kvs = precomputed.sorted_kvs;"},
{"lineNum":"   63","line":""},
{"lineNum":"   64","line":"        /// Checks if the map has a value for the key."},
{"lineNum":"   65","line":"        pub fn has(str: []const u8) bool {"},
{"lineNum":"   66","line":"            return get(str) != null;"},
{"lineNum":"   67","line":"        }"},
{"lineNum":"   68","line":""},
{"lineNum":"   69","line":"        /// Returns the value for the key if any, else null."},
{"lineNum":"   70","line":"        pub fn get(str: []const u8) ?V {","class":"lineCov","hits":"1","order":"740","possible_hits":"1",},
{"lineNum":"   71","line":"            if (str.len < precomputed.min_len or str.len > precomputed.max_len)","class":"lineCov","hits":"2","order":"741","possible_hits":"2",},
{"lineNum":"   72","line":"                return null;","class":"lineCov","hits":"1","order":"1814","possible_hits":"1",},
{"lineNum":"   73","line":""},
{"lineNum":"   74","line":"            var i = precomputed.len_indexes[str.len];","class":"lineCov","hits":"2","order":"742","possible_hits":"2",},
{"lineNum":"   75","line":"            while (true) {"},
{"lineNum":"   76","line":"                const kv = precomputed.sorted_kvs[i];","class":"lineCov","hits":"2","order":"743","possible_hits":"2",},
{"lineNum":"   77","line":"                if (kv.key.len != str.len)","class":"lineCov","hits":"1","order":"744","possible_hits":"1",},
{"lineNum":"   78","line":"                    return null;","class":"lineCov","hits":"1","order":"782","possible_hits":"1",},
{"lineNum":"   79","line":"                if (mem.eql(u8, kv.key, str))","class":"lineCov","hits":"1","order":"745","possible_hits":"1",},
{"lineNum":"   80","line":"                    return kv.value;","class":"lineCov","hits":"1","order":"746","possible_hits":"1",},
{"lineNum":"   81","line":"                i += 1;","class":"linePartCov","hits":"1","order":"779","possible_hits":"2",},
{"lineNum":"   82","line":"                if (i >= precomputed.sorted_kvs.len)","class":"lineCov","hits":"1","order":"780","possible_hits":"1",},
{"lineNum":"   83","line":"                    return null;","class":"lineCov","hits":"1","order":"781","possible_hits":"1",},
{"lineNum":"   84","line":"            }"},
{"lineNum":"   85","line":"        }"},
{"lineNum":"   86","line":"    };"},
{"lineNum":"   87","line":"}"},
{"lineNum":"   88","line":""},
{"lineNum":"   89","line":"const TestEnum = enum {"},
{"lineNum":"   90","line":"    A,"},
{"lineNum":"   91","line":"    B,"},
{"lineNum":"   92","line":"    C,"},
{"lineNum":"   93","line":"    D,"},
{"lineNum":"   94","line":"    E,"},
{"lineNum":"   95","line":"};"},
{"lineNum":"   96","line":""},
{"lineNum":"   97","line":"test \"ComptimeStringMap list literal of list literals\" {"},
{"lineNum":"   98","line":"    const map = ComptimeStringMap(TestEnum, .{"},
{"lineNum":"   99","line":"        .{ \"these\", .D },"},
{"lineNum":"  100","line":"        .{ \"have\", .A },"},
{"lineNum":"  101","line":"        .{ \"nothing\", .B },"},
{"lineNum":"  102","line":"        .{ \"incommon\", .C },"},
{"lineNum":"  103","line":"        .{ \"samelen\", .E },"},
{"lineNum":"  104","line":"    });"},
{"lineNum":"  105","line":""},
{"lineNum":"  106","line":"    try testMap(map);"},
{"lineNum":"  107","line":"}"},
{"lineNum":"  108","line":""},
{"lineNum":"  109","line":"test \"ComptimeStringMap array of structs\" {"},
{"lineNum":"  110","line":"    const KV = struct { []const u8, TestEnum };"},
{"lineNum":"  111","line":"    const map = ComptimeStringMap(TestEnum, [_]KV{"},
{"lineNum":"  112","line":"        .{ \"these\", .D },"},
{"lineNum":"  113","line":"        .{ \"have\", .A },"},
{"lineNum":"  114","line":"        .{ \"nothing\", .B },"},
{"lineNum":"  115","line":"        .{ \"incommon\", .C },"},
{"lineNum":"  116","line":"        .{ \"samelen\", .E },"},
{"lineNum":"  117","line":"    });"},
{"lineNum":"  118","line":""},
{"lineNum":"  119","line":"    try testMap(map);"},
{"lineNum":"  120","line":"}"},
{"lineNum":"  121","line":""},
{"lineNum":"  122","line":"test \"ComptimeStringMap slice of structs\" {"},
{"lineNum":"  123","line":"    const KV = struct { []const u8, TestEnum };"},
{"lineNum":"  124","line":"    const slice: []const KV = &[_]KV{"},
{"lineNum":"  125","line":"        .{ \"these\", .D },"},
{"lineNum":"  126","line":"        .{ \"have\", .A },"},
{"lineNum":"  127","line":"        .{ \"nothing\", .B },"},
{"lineNum":"  128","line":"        .{ \"incommon\", .C },"},
{"lineNum":"  129","line":"        .{ \"samelen\", .E },"},
{"lineNum":"  130","line":"    };"},
{"lineNum":"  131","line":"    const map = ComptimeStringMap(TestEnum, slice);"},
{"lineNum":"  132","line":""},
{"lineNum":"  133","line":"    try testMap(map);"},
{"lineNum":"  134","line":"}"},
{"lineNum":"  135","line":""},
{"lineNum":"  136","line":"fn testMap(comptime map: anytype) !void {"},
{"lineNum":"  137","line":"    try std.testing.expectEqual(TestEnum.A, map.get(\"have\").?);"},
{"lineNum":"  138","line":"    try std.testing.expectEqual(TestEnum.B, map.get(\"nothing\").?);"},
{"lineNum":"  139","line":"    try std.testing.expect(null == map.get(\"missing\"));"},
{"lineNum":"  140","line":"    try std.testing.expectEqual(TestEnum.D, map.get(\"these\").?);"},
{"lineNum":"  141","line":"    try std.testing.expectEqual(TestEnum.E, map.get(\"samelen\").?);"},
{"lineNum":"  142","line":""},
{"lineNum":"  143","line":"    try std.testing.expect(!map.has(\"missing\"));"},
{"lineNum":"  144","line":"    try std.testing.expect(map.has(\"these\"));"},
{"lineNum":"  145","line":"}"},
{"lineNum":"  146","line":""},
{"lineNum":"  147","line":"test \"ComptimeStringMap void value type, slice of structs\" {"},
{"lineNum":"  148","line":"    const KV = struct { []const u8 };"},
{"lineNum":"  149","line":"    const slice: []const KV = &[_]KV{"},
{"lineNum":"  150","line":"        .{\"these\"},"},
{"lineNum":"  151","line":"        .{\"have\"},"},
{"lineNum":"  152","line":"        .{\"nothing\"},"},
{"lineNum":"  153","line":"        .{\"incommon\"},"},
{"lineNum":"  154","line":"        .{\"samelen\"},"},
{"lineNum":"  155","line":"    };"},
{"lineNum":"  156","line":"    const map = ComptimeStringMap(void, slice);"},
{"lineNum":"  157","line":""},
{"lineNum":"  158","line":"    try testSet(map);"},
{"lineNum":"  159","line":"}"},
{"lineNum":"  160","line":""},
{"lineNum":"  161","line":"test \"ComptimeStringMap void value type, list literal of list literals\" {"},
{"lineNum":"  162","line":"    const map = ComptimeStringMap(void, .{"},
{"lineNum":"  163","line":"        .{\"these\"},"},
{"lineNum":"  164","line":"        .{\"have\"},"},
{"lineNum":"  165","line":"        .{\"nothing\"},"},
{"lineNum":"  166","line":"        .{\"incommon\"},"},
{"lineNum":"  167","line":"        .{\"samelen\"},"},
{"lineNum":"  168","line":"    });"},
{"lineNum":"  169","line":""},
{"lineNum":"  170","line":"    try testSet(map);"},
{"lineNum":"  171","line":"}"},
{"lineNum":"  172","line":""},
{"lineNum":"  173","line":"fn testSet(comptime map: anytype) !void {"},
{"lineNum":"  174","line":"    try std.testing.expectEqual({}, map.get(\"have\").?);"},
{"lineNum":"  175","line":"    try std.testing.expectEqual({}, map.get(\"nothing\").?);"},
{"lineNum":"  176","line":"    try std.testing.expect(null == map.get(\"missing\"));"},
{"lineNum":"  177","line":"    try std.testing.expectEqual({}, map.get(\"these\").?);"},
{"lineNum":"  178","line":"    try std.testing.expectEqual({}, map.get(\"samelen\").?);"},
{"lineNum":"  179","line":""},
{"lineNum":"  180","line":"    try std.testing.expect(!map.has(\"missing\"));"},
{"lineNum":"  181","line":"    try std.testing.expect(map.has(\"these\"));"},
{"lineNum":"  182","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test", "date" : "2024-04-26 16:14:49", "instrumented" : 12, "covered" : 12,};
var merged_data = [];
