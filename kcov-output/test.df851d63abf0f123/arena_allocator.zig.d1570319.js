var data = {lines:[
{"lineNum":"    1","line":"const std = @import(\"../std.zig\");"},
{"lineNum":"    2","line":"const assert = std.debug.assert;"},
{"lineNum":"    3","line":"const mem = std.mem;"},
{"lineNum":"    4","line":"const Allocator = std.mem.Allocator;"},
{"lineNum":"    5","line":""},
{"lineNum":"    6","line":"/// This allocator takes an existing allocator, wraps it, and provides an interface"},
{"lineNum":"    7","line":"/// where you can allocate without freeing, and then free it all together."},
{"lineNum":"    8","line":"pub const ArenaAllocator = struct {"},
{"lineNum":"    9","line":"    child_allocator: Allocator,"},
{"lineNum":"   10","line":"    state: State,"},
{"lineNum":"   11","line":""},
{"lineNum":"   12","line":"    /// Inner state of ArenaAllocator. Can be stored rather than the entire ArenaAllocator"},
{"lineNum":"   13","line":"    /// as a memory-saving optimization."},
{"lineNum":"   14","line":"    pub const State = struct {"},
{"lineNum":"   15","line":"        buffer_list: std.SinglyLinkedList(usize) = .{},"},
{"lineNum":"   16","line":"        end_index: usize = 0,"},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":"        pub fn promote(self: State, child_allocator: Allocator) ArenaAllocator {","class":"lineCov","hits":"1","order":"1337","possible_hits":"1",},
{"lineNum":"   19","line":"            return .{","class":"lineCov","hits":"1","order":"1338","possible_hits":"1",},
{"lineNum":"   20","line":"                .child_allocator = child_allocator,"},
{"lineNum":"   21","line":"                .state = self,"},
{"lineNum":"   22","line":"            };"},
{"lineNum":"   23","line":"        }"},
{"lineNum":"   24","line":"    };"},
{"lineNum":"   25","line":""},
{"lineNum":"   26","line":"    pub fn allocator(self: *ArenaAllocator) Allocator {","class":"lineCov","hits":"1","order":"1340","possible_hits":"1",},
{"lineNum":"   27","line":"        return .{","class":"lineCov","hits":"1","order":"1341","possible_hits":"1",},
{"lineNum":"   28","line":"            .ptr = self,"},
{"lineNum":"   29","line":"            .vtable = &.{"},
{"lineNum":"   30","line":"                .alloc = alloc,"},
{"lineNum":"   31","line":"                .resize = resize,"},
{"lineNum":"   32","line":"                .free = free,"},
{"lineNum":"   33","line":"            },"},
{"lineNum":"   34","line":"        };"},
{"lineNum":"   35","line":"    }"},
{"lineNum":"   36","line":""},
{"lineNum":"   37","line":"    const BufNode = std.SinglyLinkedList(usize).Node;"},
{"lineNum":"   38","line":""},
{"lineNum":"   39","line":"    pub fn init(child_allocator: Allocator) ArenaAllocator {","class":"lineCov","hits":"1","order":"1335","possible_hits":"1",},
{"lineNum":"   40","line":"        return (State{}).promote(child_allocator);","class":"lineCov","hits":"1","order":"1336","possible_hits":"1",},
{"lineNum":"   41","line":"    }"},
{"lineNum":"   42","line":""},
{"lineNum":"   43","line":"    pub fn deinit(self: ArenaAllocator) void {","class":"lineCov","hits":"1","order":"1492","possible_hits":"1",},
{"lineNum":"   44","line":"        // NOTE: When changing this, make sure `reset()` is adjusted accordingly!"},
{"lineNum":"   45","line":""},
{"lineNum":"   46","line":"        var it = self.state.buffer_list.first;","class":"lineCov","hits":"1","order":"1493","possible_hits":"1",},
{"lineNum":"   47","line":"        while (it) |node| {","class":"lineCov","hits":"2","order":"1494","possible_hits":"2",},
{"lineNum":"   48","line":"            // this has to occur before the free because the free frees node"},
{"lineNum":"   49","line":"            const next_it = node.next;","class":"lineCov","hits":"1","order":"1495","possible_hits":"1",},
{"lineNum":"   50","line":"            const align_bits = std.math.log2_int(usize, @alignOf(BufNode));","class":"lineCov","hits":"1","order":"1496","possible_hits":"1",},
{"lineNum":"   51","line":"            const alloc_buf = @as([*]u8, @ptrCast(node))[0..node.data];","class":"lineCov","hits":"3","order":"1497","possible_hits":"3",},
{"lineNum":"   52","line":"            self.child_allocator.rawFree(alloc_buf, align_bits, @returnAddress());","class":"lineCov","hits":"1","order":"1498","possible_hits":"1",},
{"lineNum":"   53","line":"            it = next_it;","class":"lineCov","hits":"4","order":"1507","possible_hits":"4",},
{"lineNum":"   54","line":"        }"},
{"lineNum":"   55","line":"    }"},
{"lineNum":"   56","line":""},
{"lineNum":"   57","line":"    pub const ResetMode = union(enum) {"},
{"lineNum":"   58","line":"        /// Releases all allocated memory in the arena."},
{"lineNum":"   59","line":"        free_all,"},
{"lineNum":"   60","line":"        /// This will pre-heat the arena for future allocations by allocating a"},
{"lineNum":"   61","line":"        /// large enough buffer for all previously done allocations."},
{"lineNum":"   62","line":"        /// Preheating will speed up the allocation process by invoking the backing allocator"},
{"lineNum":"   63","line":"        /// less often than before. If `reset()` is used in a loop, this means that after the"},
{"lineNum":"   64","line":"        /// biggest operation, no memory allocations are performed anymore."},
{"lineNum":"   65","line":"        retain_capacity,"},
{"lineNum":"   66","line":"        /// This is the same as `retain_capacity`, but the memory will be shrunk to"},
{"lineNum":"   67","line":"        /// this value if it exceeds the limit."},
{"lineNum":"   68","line":"        retain_with_limit: usize,"},
{"lineNum":"   69","line":"    };"},
{"lineNum":"   70","line":"    /// Queries the current memory use of this arena."},
{"lineNum":"   71","line":"    /// This will **not** include the storage required for internal keeping."},
{"lineNum":"   72","line":"    pub fn queryCapacity(self: ArenaAllocator) usize {"},
{"lineNum":"   73","line":"        var size: usize = 0;"},
{"lineNum":"   74","line":"        var it = self.state.buffer_list.first;"},
{"lineNum":"   75","line":"        while (it) |node| : (it = node.next) {"},
{"lineNum":"   76","line":"            // Compute the actually allocated size excluding the"},
{"lineNum":"   77","line":"            // linked list node."},
{"lineNum":"   78","line":"            size += node.data - @sizeOf(BufNode);"},
{"lineNum":"   79","line":"        }"},
{"lineNum":"   80","line":"        return size;"},
{"lineNum":"   81","line":"    }"},
{"lineNum":"   82","line":"    /// Resets the arena allocator and frees all allocated memory."},
{"lineNum":"   83","line":"    ///"},
{"lineNum":"   84","line":"    /// `mode` defines how the currently allocated memory is handled."},
{"lineNum":"   85","line":"    /// See the variant documentation for `ResetMode` for the effects of each mode."},
{"lineNum":"   86","line":"    ///"},
{"lineNum":"   87","line":"    /// The function will return whether the reset operation was successful or not."},
{"lineNum":"   88","line":"    /// If the reallocation  failed `false` is returned. The arena will still be fully"},
{"lineNum":"   89","line":"    /// functional in that case, all memory is released. Future allocations just might"},
{"lineNum":"   90","line":"    /// be slower."},
{"lineNum":"   91","line":"    ///"},
{"lineNum":"   92","line":"    /// NOTE: If `mode` is `free_mode`, the function will always return `true`."},
{"lineNum":"   93","line":"    pub fn reset(self: *ArenaAllocator, mode: ResetMode) bool {"},
{"lineNum":"   94","line":"        // Some words on the implementation:"},
{"lineNum":"   95","line":"        // The reset function can be implemented with two basic approaches:"},
{"lineNum":"   96","line":"        // - Counting how much bytes were allocated since the last reset, and storing that"},
{"lineNum":"   97","line":"        //   information in State. This will make reset fast and alloc only a teeny tiny bit"},
{"lineNum":"   98","line":"        //   slower."},
{"lineNum":"   99","line":"        // - Counting how much bytes were allocated by iterating the chunk linked list. This"},
{"lineNum":"  100","line":"        //   will make reset slower, but alloc() keeps the same speed when reset() as if reset()"},
{"lineNum":"  101","line":"        //   would not exist."},
{"lineNum":"  102","line":"        //"},
{"lineNum":"  103","line":"        // The second variant was chosen for implementation, as with more and more calls to reset(),"},
{"lineNum":"  104","line":"        // the function will get faster and faster. At one point, the complexity of the function"},
{"lineNum":"  105","line":"        // will drop to amortized O(1), as we\'re only ever having a single chunk that will not be"},
{"lineNum":"  106","line":"        // reallocated, and we\'re not even touching the backing allocator anymore."},
{"lineNum":"  107","line":"        //"},
{"lineNum":"  108","line":"        // Thus, only the first hand full of calls to reset() will actually need to iterate the linked"},
{"lineNum":"  109","line":"        // list, all future calls are just taking the first node, and only resetting the `end_index`"},
{"lineNum":"  110","line":"        // value."},
{"lineNum":"  111","line":"        const requested_capacity = switch (mode) {"},
{"lineNum":"  112","line":"            .retain_capacity => self.queryCapacity(),"},
{"lineNum":"  113","line":"            .retain_with_limit => |limit| @min(limit, self.queryCapacity()),"},
{"lineNum":"  114","line":"            .free_all => 0,"},
{"lineNum":"  115","line":"        };"},
{"lineNum":"  116","line":"        if (requested_capacity == 0) {"},
{"lineNum":"  117","line":"            // just reset when we don\'t have anything to reallocate"},
{"lineNum":"  118","line":"            self.deinit();"},
{"lineNum":"  119","line":"            self.state = State{};"},
{"lineNum":"  120","line":"            return true;"},
{"lineNum":"  121","line":"        }"},
{"lineNum":"  122","line":"        const total_size = requested_capacity + @sizeOf(BufNode);"},
{"lineNum":"  123","line":"        const align_bits = std.math.log2_int(usize, @alignOf(BufNode));"},
{"lineNum":"  124","line":"        // Free all nodes except for the last one"},
{"lineNum":"  125","line":"        var it = self.state.buffer_list.first;"},
{"lineNum":"  126","line":"        const maybe_first_node = while (it) |node| {"},
{"lineNum":"  127","line":"            // this has to occur before the free because the free frees node"},
{"lineNum":"  128","line":"            const next_it = node.next;"},
{"lineNum":"  129","line":"            if (next_it == null)"},
{"lineNum":"  130","line":"                break node;"},
{"lineNum":"  131","line":"            const alloc_buf = @as([*]u8, @ptrCast(node))[0..node.data];"},
{"lineNum":"  132","line":"            self.child_allocator.rawFree(alloc_buf, align_bits, @returnAddress());"},
{"lineNum":"  133","line":"            it = next_it;"},
{"lineNum":"  134","line":"        } else null;"},
{"lineNum":"  135","line":"        std.debug.assert(maybe_first_node == null or maybe_first_node.?.next == null);"},
{"lineNum":"  136","line":"        // reset the state before we try resizing the buffers, so we definitely have reset the arena to 0."},
{"lineNum":"  137","line":"        self.state.end_index = 0;"},
{"lineNum":"  138","line":"        if (maybe_first_node) |first_node| {"},
{"lineNum":"  139","line":"            self.state.buffer_list.first = first_node;"},
{"lineNum":"  140","line":"            // perfect, no need to invoke the child_allocator"},
{"lineNum":"  141","line":"            if (first_node.data == total_size)"},
{"lineNum":"  142","line":"                return true;"},
{"lineNum":"  143","line":"            const first_alloc_buf = @as([*]u8, @ptrCast(first_node))[0..first_node.data];"},
{"lineNum":"  144","line":"            if (self.child_allocator.rawResize(first_alloc_buf, align_bits, total_size, @returnAddress())) {"},
{"lineNum":"  145","line":"                // successful resize"},
{"lineNum":"  146","line":"                first_node.data = total_size;"},
{"lineNum":"  147","line":"            } else {"},
{"lineNum":"  148","line":"                // manual realloc"},
{"lineNum":"  149","line":"                const new_ptr = self.child_allocator.rawAlloc(total_size, align_bits, @returnAddress()) orelse {"},
{"lineNum":"  150","line":"                    // we failed to preheat the arena properly, signal this to the user."},
{"lineNum":"  151","line":"                    return false;"},
{"lineNum":"  152","line":"                };"},
{"lineNum":"  153","line":"                self.child_allocator.rawFree(first_alloc_buf, align_bits, @returnAddress());"},
{"lineNum":"  154","line":"                const node: *BufNode = @ptrCast(@alignCast(new_ptr));"},
{"lineNum":"  155","line":"                node.* = .{ .data = total_size };"},
{"lineNum":"  156","line":"                self.state.buffer_list.first = node;"},
{"lineNum":"  157","line":"            }"},
{"lineNum":"  158","line":"        }"},
{"lineNum":"  159","line":"        return true;"},
{"lineNum":"  160","line":"    }"},
{"lineNum":"  161","line":""},
{"lineNum":"  162","line":"    fn createNode(self: *ArenaAllocator, prev_len: usize, minimum_size: usize) ?*BufNode {","class":"lineCov","hits":"1","order":"1353","possible_hits":"1",},
{"lineNum":"  163","line":"        const actual_min_size = minimum_size + (@sizeOf(BufNode) + 16);","class":"lineCov","hits":"1","order":"1354","possible_hits":"1",},
{"lineNum":"  164","line":"        const big_enough_len = prev_len + actual_min_size;","class":"lineCov","hits":"1","order":"1355","possible_hits":"1",},
{"lineNum":"  165","line":"        const len = big_enough_len + big_enough_len / 2;","class":"lineCov","hits":"1","order":"1356","possible_hits":"1",},
{"lineNum":"  166","line":"        const log2_align = comptime std.math.log2_int(usize, @alignOf(BufNode));","class":"lineCov","hits":"1","order":"1357","possible_hits":"1",},
{"lineNum":"  167","line":"        const ptr = self.child_allocator.rawAlloc(len, log2_align, @returnAddress()) orelse","class":"lineCov","hits":"1","order":"1358","possible_hits":"1",},
{"lineNum":"  168","line":"            return null;","class":"linePartCov","hits":"1","order":"1359","possible_hits":"2",},
{"lineNum":"  169","line":"        const buf_node: *BufNode = @ptrCast(@alignCast(ptr));","class":"lineCov","hits":"3","order":"1360","possible_hits":"3",},
{"lineNum":"  170","line":"        buf_node.* = .{ .data = len };","class":"lineCov","hits":"1","order":"1361","possible_hits":"1",},
{"lineNum":"  171","line":"        self.state.buffer_list.prepend(buf_node);","class":"lineCov","hits":"1","order":"1362","possible_hits":"1",},
{"lineNum":"  172","line":"        self.state.end_index = 0;","class":"lineCov","hits":"1","order":"1366","possible_hits":"1",},
{"lineNum":"  173","line":"        return buf_node;","class":"lineCov","hits":"1","order":"1367","possible_hits":"1",},
{"lineNum":"  174","line":"    }"},
{"lineNum":"  175","line":""},
{"lineNum":"  176","line":"    fn alloc(ctx: *anyopaque, n: usize, log2_ptr_align: u8, ra: usize) ?[*]u8 {","class":"lineCov","hits":"1","order":"1348","possible_hits":"1",},
{"lineNum":"  177","line":"        const self: *ArenaAllocator = @ptrCast(@alignCast(ctx));","class":"lineCov","hits":"2","order":"1349","possible_hits":"2",},
{"lineNum":"  178","line":"        _ = ra;"},
{"lineNum":"  179","line":""},
{"lineNum":"  180","line":"        const ptr_align = @as(usize, 1) << @as(Allocator.Log2Align, @intCast(log2_ptr_align));","class":"lineCov","hits":"3","order":"1350","possible_hits":"3",},
{"lineNum":"  181","line":"        var cur_node = if (self.state.buffer_list.first) |first_node|","class":"lineCov","hits":"2","order":"1351","possible_hits":"2",},
{"lineNum":"  182","line":"            first_node"},
{"lineNum":"  183","line":"        else"},
{"lineNum":"  184","line":"            (self.createNode(0, n + ptr_align) orelse return null);","class":"lineCov","hits":"2","order":"1352","possible_hits":"2",},
{"lineNum":"  185","line":"        while (true) {"},
{"lineNum":"  186","line":"            const cur_alloc_buf = @as([*]u8, @ptrCast(cur_node))[0..cur_node.data];","class":"lineCov","hits":"2","order":"1368","possible_hits":"2",},
{"lineNum":"  187","line":"            const cur_buf = cur_alloc_buf[@sizeOf(BufNode)..];","class":"lineCov","hits":"3","order":"1369","possible_hits":"3",},
{"lineNum":"  188","line":"            const addr = @intFromPtr(cur_buf.ptr) + self.state.end_index;","class":"linePartCov","hits":"1","order":"1370","possible_hits":"2",},
{"lineNum":"  189","line":"            const adjusted_addr = mem.alignForward(usize, addr, ptr_align);","class":"lineCov","hits":"1","order":"1371","possible_hits":"1",},
{"lineNum":"  190","line":"            const adjusted_index = self.state.end_index + (adjusted_addr - addr);","class":"lineCov","hits":"1","order":"1372","possible_hits":"1",},
{"lineNum":"  191","line":"            const new_end_index = adjusted_index + n;","class":"lineCov","hits":"1","order":"1373","possible_hits":"1",},
{"lineNum":"  192","line":""},
{"lineNum":"  193","line":"            if (new_end_index <= cur_buf.len) {","class":"lineCov","hits":"1","order":"1374","possible_hits":"1",},
{"lineNum":"  194","line":"                const result = cur_buf[adjusted_index..new_end_index];","class":"lineCov","hits":"3","order":"1375","possible_hits":"3",},
{"lineNum":"  195","line":"                self.state.end_index = new_end_index;","class":"lineCov","hits":"1","order":"1376","possible_hits":"1",},
{"lineNum":"  196","line":"                return result.ptr;","class":"lineCov","hits":"2","order":"1377","possible_hits":"2",},
{"lineNum":"  197","line":"            }"},
{"lineNum":"  198","line":""},
{"lineNum":"  199","line":"            const bigger_buf_size = @sizeOf(BufNode) + new_end_index;","class":"linePartCov","hits":"1","order":"2372","possible_hits":"2",},
{"lineNum":"  200","line":"            const log2_align = comptime std.math.log2_int(usize, @alignOf(BufNode));","class":"lineCov","hits":"1","order":"2373","possible_hits":"1",},
{"lineNum":"  201","line":"            if (self.child_allocator.rawResize(cur_alloc_buf, log2_align, bigger_buf_size, @returnAddress())) {","class":"lineCov","hits":"1","order":"2374","possible_hits":"1",},
{"lineNum":"  202","line":"                cur_node.data = bigger_buf_size;","class":"lineCov","hits":"1","order":"2375","possible_hits":"1",},
{"lineNum":"  203","line":"            } else {"},
{"lineNum":"  204","line":"                // Allocate a new node if that\'s not possible"},
{"lineNum":"  205","line":"                cur_node = self.createNode(cur_buf.len, n + ptr_align) orelse return null;","class":"linePartCov","hits":"1","order":"2376","possible_hits":"2",},
{"lineNum":"  206","line":"            }"},
{"lineNum":"  207","line":"        }"},
{"lineNum":"  208","line":"    }"},
{"lineNum":"  209","line":""},
{"lineNum":"  210","line":"    fn resize(ctx: *anyopaque, buf: []u8, log2_buf_align: u8, new_len: usize, ret_addr: usize) bool {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  211","line":"        const self: *ArenaAllocator = @ptrCast(@alignCast(ctx));","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  212","line":"        _ = log2_buf_align;"},
{"lineNum":"  213","line":"        _ = ret_addr;"},
{"lineNum":"  214","line":""},
{"lineNum":"  215","line":"        const cur_node = self.state.buffer_list.first orelse return false;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  216","line":"        const cur_buf = @as([*]u8, @ptrCast(cur_node))[@sizeOf(BufNode)..cur_node.data];","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  217","line":"        if (@intFromPtr(cur_buf.ptr) + self.state.end_index != @intFromPtr(buf.ptr) + buf.len) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  218","line":"            // It\'s not the most recent allocation, so it cannot be expanded,"},
{"lineNum":"  219","line":"            // but it\'s fine if they want to make it smaller."},
{"lineNum":"  220","line":"            return new_len <= buf.len;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  221","line":"        }"},
{"lineNum":"  222","line":""},
{"lineNum":"  223","line":"        if (buf.len >= new_len) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  224","line":"            self.state.end_index -= buf.len - new_len;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  225","line":"            return true;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  226","line":"        } else if (cur_buf.len - self.state.end_index >= new_len - buf.len) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  227","line":"            self.state.end_index += new_len - buf.len;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  228","line":"            return true;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  229","line":"        } else {"},
{"lineNum":"  230","line":"            return false;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  231","line":"        }"},
{"lineNum":"  232","line":"    }"},
{"lineNum":"  233","line":""},
{"lineNum":"  234","line":"    fn free(ctx: *anyopaque, buf: []u8, log2_buf_align: u8, ret_addr: usize) void {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  235","line":"        _ = log2_buf_align;"},
{"lineNum":"  236","line":"        _ = ret_addr;"},
{"lineNum":"  237","line":""},
{"lineNum":"  238","line":"        const self: *ArenaAllocator = @ptrCast(@alignCast(ctx));","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  239","line":""},
{"lineNum":"  240","line":"        const cur_node = self.state.buffer_list.first orelse return;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  241","line":"        const cur_buf = @as([*]u8, @ptrCast(cur_node))[@sizeOf(BufNode)..cur_node.data];","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  242","line":""},
{"lineNum":"  243","line":"        if (@intFromPtr(cur_buf.ptr) + self.state.end_index == @intFromPtr(buf.ptr) + buf.len) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  244","line":"            self.state.end_index -= buf.len;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  245","line":"        }"},
{"lineNum":"  246","line":"    }"},
{"lineNum":"  247","line":"};"},
{"lineNum":"  248","line":""},
{"lineNum":"  249","line":"test \"ArenaAllocator (reset with preheating)\" {"},
{"lineNum":"  250","line":"    var arena_allocator = ArenaAllocator.init(std.testing.allocator);"},
{"lineNum":"  251","line":"    defer arena_allocator.deinit();"},
{"lineNum":"  252","line":"    // provides some variance in the allocated data"},
{"lineNum":"  253","line":"    var rng_src = std.rand.DefaultPrng.init(19930913);"},
{"lineNum":"  254","line":"    const random = rng_src.random();"},
{"lineNum":"  255","line":"    var rounds: usize = 25;"},
{"lineNum":"  256","line":"    while (rounds > 0) {"},
{"lineNum":"  257","line":"        rounds -= 1;"},
{"lineNum":"  258","line":"        _ = arena_allocator.reset(.retain_capacity);"},
{"lineNum":"  259","line":"        var alloced_bytes: usize = 0;"},
{"lineNum":"  260","line":"        var total_size: usize = random.intRangeAtMost(usize, 256, 16384);"},
{"lineNum":"  261","line":"        while (alloced_bytes < total_size) {"},
{"lineNum":"  262","line":"            const size = random.intRangeAtMost(usize, 16, 256);"},
{"lineNum":"  263","line":"            const alignment = 32;"},
{"lineNum":"  264","line":"            const slice = try arena_allocator.allocator().alignedAlloc(u8, alignment, size);"},
{"lineNum":"  265","line":"            try std.testing.expect(std.mem.isAligned(@intFromPtr(slice.ptr), alignment));"},
{"lineNum":"  266","line":"            try std.testing.expectEqual(size, slice.len);"},
{"lineNum":"  267","line":"            alloced_bytes += slice.len;"},
{"lineNum":"  268","line":"        }"},
{"lineNum":"  269","line":"    }"},
{"lineNum":"  270","line":"}"},
{"lineNum":"  271","line":""},
{"lineNum":"  272","line":"test \"ArenaAllocator (reset while retaining a buffer)\" {"},
{"lineNum":"  273","line":"    var arena_allocator = ArenaAllocator.init(std.testing.allocator);"},
{"lineNum":"  274","line":"    defer arena_allocator.deinit();"},
{"lineNum":"  275","line":"    const a = arena_allocator.allocator();"},
{"lineNum":"  276","line":""},
{"lineNum":"  277","line":"    // Create two internal buffers"},
{"lineNum":"  278","line":"    _ = try a.alloc(u8, 1);"},
{"lineNum":"  279","line":"    _ = try a.alloc(u8, 1000);"},
{"lineNum":"  280","line":""},
{"lineNum":"  281","line":"    // Check that we have at least two buffers"},
{"lineNum":"  282","line":"    try std.testing.expect(arena_allocator.state.buffer_list.first.?.next != null);"},
{"lineNum":"  283","line":""},
{"lineNum":"  284","line":"    // This retains the first allocated buffer"},
{"lineNum":"  285","line":"    try std.testing.expect(arena_allocator.reset(.{ .retain_with_limit = 1 }));"},
{"lineNum":"  286","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test", "date" : "2024-04-26 16:14:49", "instrumented" : 65, "covered" : 46,};
var merged_data = [];
