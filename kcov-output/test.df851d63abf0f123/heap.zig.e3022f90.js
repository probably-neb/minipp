var data = {lines:[
{"lineNum":"    1","line":"const std = @import(\"std.zig\");"},
{"lineNum":"    2","line":"const builtin = @import(\"builtin\");"},
{"lineNum":"    3","line":"const root = @import(\"root\");"},
{"lineNum":"    4","line":"const assert = std.debug.assert;"},
{"lineNum":"    5","line":"const testing = std.testing;"},
{"lineNum":"    6","line":"const mem = std.mem;"},
{"lineNum":"    7","line":"const os = std.os;"},
{"lineNum":"    8","line":"const c = std.c;"},
{"lineNum":"    9","line":"const maxInt = std.math.maxInt;"},
{"lineNum":"   10","line":"const Allocator = std.mem.Allocator;"},
{"lineNum":"   11","line":""},
{"lineNum":"   12","line":"pub const LoggingAllocator = @import(\"heap/logging_allocator.zig\").LoggingAllocator;"},
{"lineNum":"   13","line":"pub const loggingAllocator = @import(\"heap/logging_allocator.zig\").loggingAllocator;"},
{"lineNum":"   14","line":"pub const ScopedLoggingAllocator = @import(\"heap/logging_allocator.zig\").ScopedLoggingAllocator;"},
{"lineNum":"   15","line":"pub const LogToWriterAllocator = @import(\"heap/log_to_writer_allocator.zig\").LogToWriterAllocator;"},
{"lineNum":"   16","line":"pub const logToWriterAllocator = @import(\"heap/log_to_writer_allocator.zig\").logToWriterAllocator;"},
{"lineNum":"   17","line":"pub const ArenaAllocator = @import(\"heap/arena_allocator.zig\").ArenaAllocator;"},
{"lineNum":"   18","line":"pub const GeneralPurposeAllocator = @import(\"heap/general_purpose_allocator.zig\").GeneralPurposeAllocator;"},
{"lineNum":"   19","line":"pub const Check = @import(\"heap/general_purpose_allocator.zig\").Check;"},
{"lineNum":"   20","line":"pub const WasmAllocator = @import(\"heap/WasmAllocator.zig\");"},
{"lineNum":"   21","line":"pub const WasmPageAllocator = @import(\"heap/WasmPageAllocator.zig\");"},
{"lineNum":"   22","line":"pub const PageAllocator = @import(\"heap/PageAllocator.zig\");"},
{"lineNum":"   23","line":"pub const ThreadSafeAllocator = @import(\"heap/ThreadSafeAllocator.zig\");"},
{"lineNum":"   24","line":"pub const SbrkAllocator = @import(\"heap/sbrk_allocator.zig\").SbrkAllocator;"},
{"lineNum":"   25","line":""},
{"lineNum":"   26","line":"const memory_pool = @import(\"heap/memory_pool.zig\");"},
{"lineNum":"   27","line":"pub const MemoryPool = memory_pool.MemoryPool;"},
{"lineNum":"   28","line":"pub const MemoryPoolAligned = memory_pool.MemoryPoolAligned;"},
{"lineNum":"   29","line":"pub const MemoryPoolExtra = memory_pool.MemoryPoolExtra;"},
{"lineNum":"   30","line":"pub const MemoryPoolOptions = memory_pool.Options;"},
{"lineNum":"   31","line":""},
{"lineNum":"   32","line":"/// TODO Utilize this on Windows."},
{"lineNum":"   33","line":"pub var next_mmap_addr_hint: ?[*]align(mem.page_size) u8 = null;"},
{"lineNum":"   34","line":""},
{"lineNum":"   35","line":"const CAllocator = struct {"},
{"lineNum":"   36","line":"    comptime {"},
{"lineNum":"   37","line":"        if (!builtin.link_libc) {"},
{"lineNum":"   38","line":"            @compileError(\"C allocator is only available when linking against libc\");"},
{"lineNum":"   39","line":"        }"},
{"lineNum":"   40","line":"    }"},
{"lineNum":"   41","line":""},
{"lineNum":"   42","line":"    usingnamespace if (@hasDecl(c, \"malloc_size\"))"},
{"lineNum":"   43","line":"        struct {"},
{"lineNum":"   44","line":"            pub const supports_malloc_size = true;"},
{"lineNum":"   45","line":"            pub const malloc_size = c.malloc_size;"},
{"lineNum":"   46","line":"        }"},
{"lineNum":"   47","line":"    else if (@hasDecl(c, \"malloc_usable_size\"))"},
{"lineNum":"   48","line":"        struct {"},
{"lineNum":"   49","line":"            pub const supports_malloc_size = true;"},
{"lineNum":"   50","line":"            pub const malloc_size = c.malloc_usable_size;"},
{"lineNum":"   51","line":"        }"},
{"lineNum":"   52","line":"    else if (@hasDecl(c, \"_msize\"))"},
{"lineNum":"   53","line":"        struct {"},
{"lineNum":"   54","line":"            pub const supports_malloc_size = true;"},
{"lineNum":"   55","line":"            pub const malloc_size = c._msize;"},
{"lineNum":"   56","line":"        }"},
{"lineNum":"   57","line":"    else"},
{"lineNum":"   58","line":"        struct {"},
{"lineNum":"   59","line":"            pub const supports_malloc_size = false;"},
{"lineNum":"   60","line":"        };"},
{"lineNum":"   61","line":""},
{"lineNum":"   62","line":"    pub const supports_posix_memalign = @hasDecl(c, \"posix_memalign\");"},
{"lineNum":"   63","line":""},
{"lineNum":"   64","line":"    fn getHeader(ptr: [*]u8) *[*]u8 {"},
{"lineNum":"   65","line":"        return @as(*[*]u8, @ptrFromInt(@intFromPtr(ptr) - @sizeOf(usize)));"},
{"lineNum":"   66","line":"    }"},
{"lineNum":"   67","line":""},
{"lineNum":"   68","line":"    fn alignedAlloc(len: usize, log2_align: u8) ?[*]u8 {"},
{"lineNum":"   69","line":"        const alignment = @as(usize, 1) << @as(Allocator.Log2Align, @intCast(log2_align));"},
{"lineNum":"   70","line":"        if (supports_posix_memalign) {"},
{"lineNum":"   71","line":"            // The posix_memalign only accepts alignment values that are a"},
{"lineNum":"   72","line":"            // multiple of the pointer size"},
{"lineNum":"   73","line":"            const eff_alignment = @max(alignment, @sizeOf(usize));"},
{"lineNum":"   74","line":""},
{"lineNum":"   75","line":"            var aligned_ptr: ?*anyopaque = undefined;"},
{"lineNum":"   76","line":"            if (c.posix_memalign(&aligned_ptr, eff_alignment, len) != 0)"},
{"lineNum":"   77","line":"                return null;"},
{"lineNum":"   78","line":""},
{"lineNum":"   79","line":"            return @as([*]u8, @ptrCast(aligned_ptr));"},
{"lineNum":"   80","line":"        }"},
{"lineNum":"   81","line":""},
{"lineNum":"   82","line":"        // Thin wrapper around regular malloc, overallocate to account for"},
{"lineNum":"   83","line":"        // alignment padding and store the original malloc()\'ed pointer before"},
{"lineNum":"   84","line":"        // the aligned address."},
{"lineNum":"   85","line":"        var unaligned_ptr = @as([*]u8, @ptrCast(c.malloc(len + alignment - 1 + @sizeOf(usize)) orelse return null));"},
{"lineNum":"   86","line":"        const unaligned_addr = @intFromPtr(unaligned_ptr);"},
{"lineNum":"   87","line":"        const aligned_addr = mem.alignForward(usize, unaligned_addr + @sizeOf(usize), alignment);"},
{"lineNum":"   88","line":"        var aligned_ptr = unaligned_ptr + (aligned_addr - unaligned_addr);"},
{"lineNum":"   89","line":"        getHeader(aligned_ptr).* = unaligned_ptr;"},
{"lineNum":"   90","line":""},
{"lineNum":"   91","line":"        return aligned_ptr;"},
{"lineNum":"   92","line":"    }"},
{"lineNum":"   93","line":""},
{"lineNum":"   94","line":"    fn alignedFree(ptr: [*]u8) void {"},
{"lineNum":"   95","line":"        if (supports_posix_memalign) {"},
{"lineNum":"   96","line":"            return c.free(ptr);"},
{"lineNum":"   97","line":"        }"},
{"lineNum":"   98","line":""},
{"lineNum":"   99","line":"        const unaligned_ptr = getHeader(ptr).*;"},
{"lineNum":"  100","line":"        c.free(unaligned_ptr);"},
{"lineNum":"  101","line":"    }"},
{"lineNum":"  102","line":""},
{"lineNum":"  103","line":"    fn alignedAllocSize(ptr: [*]u8) usize {"},
{"lineNum":"  104","line":"        if (supports_posix_memalign) {"},
{"lineNum":"  105","line":"            return CAllocator.malloc_size(ptr);"},
{"lineNum":"  106","line":"        }"},
{"lineNum":"  107","line":""},
{"lineNum":"  108","line":"        const unaligned_ptr = getHeader(ptr).*;"},
{"lineNum":"  109","line":"        const delta = @intFromPtr(ptr) - @intFromPtr(unaligned_ptr);"},
{"lineNum":"  110","line":"        return CAllocator.malloc_size(unaligned_ptr) - delta;"},
{"lineNum":"  111","line":"    }"},
{"lineNum":"  112","line":""},
{"lineNum":"  113","line":"    fn alloc("},
{"lineNum":"  114","line":"        _: *anyopaque,"},
{"lineNum":"  115","line":"        len: usize,"},
{"lineNum":"  116","line":"        log2_align: u8,"},
{"lineNum":"  117","line":"        return_address: usize,"},
{"lineNum":"  118","line":"    ) ?[*]u8 {"},
{"lineNum":"  119","line":"        _ = return_address;"},
{"lineNum":"  120","line":"        assert(len > 0);"},
{"lineNum":"  121","line":"        return alignedAlloc(len, log2_align);"},
{"lineNum":"  122","line":"    }"},
{"lineNum":"  123","line":""},
{"lineNum":"  124","line":"    fn resize("},
{"lineNum":"  125","line":"        _: *anyopaque,"},
{"lineNum":"  126","line":"        buf: []u8,"},
{"lineNum":"  127","line":"        log2_buf_align: u8,"},
{"lineNum":"  128","line":"        new_len: usize,"},
{"lineNum":"  129","line":"        return_address: usize,"},
{"lineNum":"  130","line":"    ) bool {"},
{"lineNum":"  131","line":"        _ = log2_buf_align;"},
{"lineNum":"  132","line":"        _ = return_address;"},
{"lineNum":"  133","line":"        if (new_len <= buf.len) {"},
{"lineNum":"  134","line":"            return true;"},
{"lineNum":"  135","line":"        }"},
{"lineNum":"  136","line":"        if (CAllocator.supports_malloc_size) {"},
{"lineNum":"  137","line":"            const full_len = alignedAllocSize(buf.ptr);"},
{"lineNum":"  138","line":"            if (new_len <= full_len) {"},
{"lineNum":"  139","line":"                return true;"},
{"lineNum":"  140","line":"            }"},
{"lineNum":"  141","line":"        }"},
{"lineNum":"  142","line":"        return false;"},
{"lineNum":"  143","line":"    }"},
{"lineNum":"  144","line":""},
{"lineNum":"  145","line":"    fn free("},
{"lineNum":"  146","line":"        _: *anyopaque,"},
{"lineNum":"  147","line":"        buf: []u8,"},
{"lineNum":"  148","line":"        log2_buf_align: u8,"},
{"lineNum":"  149","line":"        return_address: usize,"},
{"lineNum":"  150","line":"    ) void {"},
{"lineNum":"  151","line":"        _ = log2_buf_align;"},
{"lineNum":"  152","line":"        _ = return_address;"},
{"lineNum":"  153","line":"        alignedFree(buf.ptr);"},
{"lineNum":"  154","line":"    }"},
{"lineNum":"  155","line":"};"},
{"lineNum":"  156","line":""},
{"lineNum":"  157","line":"/// Supports the full Allocator interface, including alignment, and exploiting"},
{"lineNum":"  158","line":"/// `malloc_usable_size` if available. For an allocator that directly calls"},
{"lineNum":"  159","line":"/// `malloc`/`free`, see `raw_c_allocator`."},
{"lineNum":"  160","line":"pub const c_allocator = Allocator{"},
{"lineNum":"  161","line":"    .ptr = undefined,"},
{"lineNum":"  162","line":"    .vtable = &c_allocator_vtable,"},
{"lineNum":"  163","line":"};"},
{"lineNum":"  164","line":"const c_allocator_vtable = Allocator.VTable{"},
{"lineNum":"  165","line":"    .alloc = CAllocator.alloc,"},
{"lineNum":"  166","line":"    .resize = CAllocator.resize,"},
{"lineNum":"  167","line":"    .free = CAllocator.free,"},
{"lineNum":"  168","line":"};"},
{"lineNum":"  169","line":""},
{"lineNum":"  170","line":"/// Asserts allocations are within `@alignOf(std.c.max_align_t)` and directly calls"},
{"lineNum":"  171","line":"/// `malloc`/`free`. Does not attempt to utilize `malloc_usable_size`."},
{"lineNum":"  172","line":"/// This allocator is safe to use as the backing allocator with"},
{"lineNum":"  173","line":"/// `ArenaAllocator` for example and is more optimal in such a case"},
{"lineNum":"  174","line":"/// than `c_allocator`."},
{"lineNum":"  175","line":"pub const raw_c_allocator = Allocator{"},
{"lineNum":"  176","line":"    .ptr = undefined,"},
{"lineNum":"  177","line":"    .vtable = &raw_c_allocator_vtable,"},
{"lineNum":"  178","line":"};"},
{"lineNum":"  179","line":"const raw_c_allocator_vtable = Allocator.VTable{"},
{"lineNum":"  180","line":"    .alloc = rawCAlloc,"},
{"lineNum":"  181","line":"    .resize = rawCResize,"},
{"lineNum":"  182","line":"    .free = rawCFree,"},
{"lineNum":"  183","line":"};"},
{"lineNum":"  184","line":""},
{"lineNum":"  185","line":"fn rawCAlloc("},
{"lineNum":"  186","line":"    _: *anyopaque,"},
{"lineNum":"  187","line":"    len: usize,"},
{"lineNum":"  188","line":"    log2_ptr_align: u8,"},
{"lineNum":"  189","line":"    ret_addr: usize,"},
{"lineNum":"  190","line":") ?[*]u8 {"},
{"lineNum":"  191","line":"    _ = ret_addr;"},
{"lineNum":"  192","line":"    assert(log2_ptr_align <= comptime std.math.log2_int(usize, @alignOf(std.c.max_align_t)));"},
{"lineNum":"  193","line":"    // Note that this pointer cannot be aligncasted to max_align_t because if"},
{"lineNum":"  194","line":"    // len is < max_align_t then the alignment can be smaller. For example, if"},
{"lineNum":"  195","line":"    // max_align_t is 16, but the user requests 8 bytes, there is no built-in"},
{"lineNum":"  196","line":"    // type in C that is size 8 and has 16 byte alignment, so the alignment may"},
{"lineNum":"  197","line":"    // be 8 bytes rather than 16. Similarly if only 1 byte is requested, malloc"},
{"lineNum":"  198","line":"    // is allowed to return a 1-byte aligned pointer."},
{"lineNum":"  199","line":"    return @as(?[*]u8, @ptrCast(c.malloc(len)));"},
{"lineNum":"  200","line":"}"},
{"lineNum":"  201","line":""},
{"lineNum":"  202","line":"fn rawCResize("},
{"lineNum":"  203","line":"    _: *anyopaque,"},
{"lineNum":"  204","line":"    buf: []u8,"},
{"lineNum":"  205","line":"    log2_old_align: u8,"},
{"lineNum":"  206","line":"    new_len: usize,"},
{"lineNum":"  207","line":"    ret_addr: usize,"},
{"lineNum":"  208","line":") bool {"},
{"lineNum":"  209","line":"    _ = log2_old_align;"},
{"lineNum":"  210","line":"    _ = ret_addr;"},
{"lineNum":"  211","line":"    return new_len <= buf.len;"},
{"lineNum":"  212","line":"}"},
{"lineNum":"  213","line":""},
{"lineNum":"  214","line":"fn rawCFree("},
{"lineNum":"  215","line":"    _: *anyopaque,"},
{"lineNum":"  216","line":"    buf: []u8,"},
{"lineNum":"  217","line":"    log2_old_align: u8,"},
{"lineNum":"  218","line":"    ret_addr: usize,"},
{"lineNum":"  219","line":") void {"},
{"lineNum":"  220","line":"    _ = log2_old_align;"},
{"lineNum":"  221","line":"    _ = ret_addr;"},
{"lineNum":"  222","line":"    c.free(buf.ptr);"},
{"lineNum":"  223","line":"}"},
{"lineNum":"  224","line":""},
{"lineNum":"  225","line":"/// This allocator makes a syscall directly for every allocation and free."},
{"lineNum":"  226","line":"/// Thread-safe and lock-free."},
{"lineNum":"  227","line":"pub const page_allocator = if (builtin.target.isWasm())"},
{"lineNum":"  228","line":"    Allocator{"},
{"lineNum":"  229","line":"        .ptr = undefined,"},
{"lineNum":"  230","line":"        .vtable = &WasmPageAllocator.vtable,"},
{"lineNum":"  231","line":"    }"},
{"lineNum":"  232","line":"else if (builtin.target.os.tag == .plan9)"},
{"lineNum":"  233","line":"    Allocator{"},
{"lineNum":"  234","line":"        .ptr = undefined,"},
{"lineNum":"  235","line":"        .vtable = &SbrkAllocator(std.os.plan9.sbrk).vtable,"},
{"lineNum":"  236","line":"    }"},
{"lineNum":"  237","line":"else if (builtin.target.os.tag == .freestanding)"},
{"lineNum":"  238","line":"    root.os.heap.page_allocator"},
{"lineNum":"  239","line":"else"},
{"lineNum":"  240","line":"    Allocator{"},
{"lineNum":"  241","line":"        .ptr = undefined,"},
{"lineNum":"  242","line":"        .vtable = &PageAllocator.vtable,"},
{"lineNum":"  243","line":"    };"},
{"lineNum":"  244","line":""},
{"lineNum":"  245","line":"/// This allocator is fast, small, and specific to WebAssembly. In the future,"},
{"lineNum":"  246","line":"/// this will be the implementation automatically selected by"},
{"lineNum":"  247","line":"/// `GeneralPurposeAllocator` when compiling in `ReleaseSmall` mode for wasm32"},
{"lineNum":"  248","line":"/// and wasm64 architectures."},
{"lineNum":"  249","line":"/// Until then, it is available here to play with."},
{"lineNum":"  250","line":"pub const wasm_allocator = Allocator{"},
{"lineNum":"  251","line":"    .ptr = undefined,"},
{"lineNum":"  252","line":"    .vtable = &std.heap.WasmAllocator.vtable,"},
{"lineNum":"  253","line":"};"},
{"lineNum":"  254","line":""},
{"lineNum":"  255","line":"/// Verifies that the adjusted length will still map to the full length"},
{"lineNum":"  256","line":"pub fn alignPageAllocLen(full_len: usize, len: usize) usize {"},
{"lineNum":"  257","line":"    const aligned_len = mem.alignAllocLen(full_len, len);"},
{"lineNum":"  258","line":"    assert(mem.alignForward(usize, aligned_len, mem.page_size) == full_len);"},
{"lineNum":"  259","line":"    return aligned_len;"},
{"lineNum":"  260","line":"}"},
{"lineNum":"  261","line":""},
{"lineNum":"  262","line":"pub const HeapAllocator = switch (builtin.os.tag) {"},
{"lineNum":"  263","line":"    .windows => struct {"},
{"lineNum":"  264","line":"        heap_handle: ?HeapHandle,"},
{"lineNum":"  265","line":""},
{"lineNum":"  266","line":"        const HeapHandle = os.windows.HANDLE;"},
{"lineNum":"  267","line":""},
{"lineNum":"  268","line":"        pub fn init() HeapAllocator {"},
{"lineNum":"  269","line":"            return HeapAllocator{"},
{"lineNum":"  270","line":"                .heap_handle = null,"},
{"lineNum":"  271","line":"            };"},
{"lineNum":"  272","line":"        }"},
{"lineNum":"  273","line":""},
{"lineNum":"  274","line":"        pub fn allocator(self: *HeapAllocator) Allocator {"},
{"lineNum":"  275","line":"            return .{"},
{"lineNum":"  276","line":"                .ptr = self,"},
{"lineNum":"  277","line":"                .vtable = &.{"},
{"lineNum":"  278","line":"                    .alloc = alloc,"},
{"lineNum":"  279","line":"                    .resize = resize,"},
{"lineNum":"  280","line":"                    .free = free,"},
{"lineNum":"  281","line":"                },"},
{"lineNum":"  282","line":"            };"},
{"lineNum":"  283","line":"        }"},
{"lineNum":"  284","line":""},
{"lineNum":"  285","line":"        pub fn deinit(self: *HeapAllocator) void {"},
{"lineNum":"  286","line":"            if (self.heap_handle) |heap_handle| {"},
{"lineNum":"  287","line":"                os.windows.HeapDestroy(heap_handle);"},
{"lineNum":"  288","line":"            }"},
{"lineNum":"  289","line":"        }"},
{"lineNum":"  290","line":""},
{"lineNum":"  291","line":"        fn getRecordPtr(buf: []u8) *align(1) usize {"},
{"lineNum":"  292","line":"            return @as(*align(1) usize, @ptrFromInt(@intFromPtr(buf.ptr) + buf.len));"},
{"lineNum":"  293","line":"        }"},
{"lineNum":"  294","line":""},
{"lineNum":"  295","line":"        fn alloc("},
{"lineNum":"  296","line":"            ctx: *anyopaque,"},
{"lineNum":"  297","line":"            n: usize,"},
{"lineNum":"  298","line":"            log2_ptr_align: u8,"},
{"lineNum":"  299","line":"            return_address: usize,"},
{"lineNum":"  300","line":"        ) ?[*]u8 {"},
{"lineNum":"  301","line":"            _ = return_address;"},
{"lineNum":"  302","line":"            const self: *HeapAllocator = @ptrCast(@alignCast(ctx));"},
{"lineNum":"  303","line":""},
{"lineNum":"  304","line":"            const ptr_align = @as(usize, 1) << @as(Allocator.Log2Align, @intCast(log2_ptr_align));"},
{"lineNum":"  305","line":"            const amt = n + ptr_align - 1 + @sizeOf(usize);"},
{"lineNum":"  306","line":"            const optional_heap_handle = @atomicLoad(?HeapHandle, &self.heap_handle, .SeqCst);"},
{"lineNum":"  307","line":"            const heap_handle = optional_heap_handle orelse blk: {"},
{"lineNum":"  308","line":"                const options = if (builtin.single_threaded) os.windows.HEAP_NO_SERIALIZE else 0;"},
{"lineNum":"  309","line":"                const hh = os.windows.kernel32.HeapCreate(options, amt, 0) orelse return null;"},
{"lineNum":"  310","line":"                const other_hh = @cmpxchgStrong(?HeapHandle, &self.heap_handle, null, hh, .SeqCst, .SeqCst) orelse break :blk hh;"},
{"lineNum":"  311","line":"                os.windows.HeapDestroy(hh);"},
{"lineNum":"  312","line":"                break :blk other_hh.?; // can\'t be null because of the cmpxchg"},
{"lineNum":"  313","line":"            };"},
{"lineNum":"  314","line":"            const ptr = os.windows.kernel32.HeapAlloc(heap_handle, 0, amt) orelse return null;"},
{"lineNum":"  315","line":"            const root_addr = @intFromPtr(ptr);"},
{"lineNum":"  316","line":"            const aligned_addr = mem.alignForward(usize, root_addr, ptr_align);"},
{"lineNum":"  317","line":"            const buf = @as([*]u8, @ptrFromInt(aligned_addr))[0..n];"},
{"lineNum":"  318","line":"            getRecordPtr(buf).* = root_addr;"},
{"lineNum":"  319","line":"            return buf.ptr;"},
{"lineNum":"  320","line":"        }"},
{"lineNum":"  321","line":""},
{"lineNum":"  322","line":"        fn resize("},
{"lineNum":"  323","line":"            ctx: *anyopaque,"},
{"lineNum":"  324","line":"            buf: []u8,"},
{"lineNum":"  325","line":"            log2_buf_align: u8,"},
{"lineNum":"  326","line":"            new_size: usize,"},
{"lineNum":"  327","line":"            return_address: usize,"},
{"lineNum":"  328","line":"        ) bool {"},
{"lineNum":"  329","line":"            _ = log2_buf_align;"},
{"lineNum":"  330","line":"            _ = return_address;"},
{"lineNum":"  331","line":"            const self: *HeapAllocator = @ptrCast(@alignCast(ctx));"},
{"lineNum":"  332","line":""},
{"lineNum":"  333","line":"            const root_addr = getRecordPtr(buf).*;"},
{"lineNum":"  334","line":"            const align_offset = @intFromPtr(buf.ptr) - root_addr;"},
{"lineNum":"  335","line":"            const amt = align_offset + new_size + @sizeOf(usize);"},
{"lineNum":"  336","line":"            const new_ptr = os.windows.kernel32.HeapReAlloc("},
{"lineNum":"  337","line":"                self.heap_handle.?,"},
{"lineNum":"  338","line":"                os.windows.HEAP_REALLOC_IN_PLACE_ONLY,"},
{"lineNum":"  339","line":"                @as(*anyopaque, @ptrFromInt(root_addr)),"},
{"lineNum":"  340","line":"                amt,"},
{"lineNum":"  341","line":"            ) orelse return false;"},
{"lineNum":"  342","line":"            assert(new_ptr == @as(*anyopaque, @ptrFromInt(root_addr)));"},
{"lineNum":"  343","line":"            getRecordPtr(buf.ptr[0..new_size]).* = root_addr;"},
{"lineNum":"  344","line":"            return true;"},
{"lineNum":"  345","line":"        }"},
{"lineNum":"  346","line":""},
{"lineNum":"  347","line":"        fn free("},
{"lineNum":"  348","line":"            ctx: *anyopaque,"},
{"lineNum":"  349","line":"            buf: []u8,"},
{"lineNum":"  350","line":"            log2_buf_align: u8,"},
{"lineNum":"  351","line":"            return_address: usize,"},
{"lineNum":"  352","line":"        ) void {"},
{"lineNum":"  353","line":"            _ = log2_buf_align;"},
{"lineNum":"  354","line":"            _ = return_address;"},
{"lineNum":"  355","line":"            const self: *HeapAllocator = @ptrCast(@alignCast(ctx));"},
{"lineNum":"  356","line":"            os.windows.HeapFree(self.heap_handle.?, 0, @as(*anyopaque, @ptrFromInt(getRecordPtr(buf).*)));"},
{"lineNum":"  357","line":"        }"},
{"lineNum":"  358","line":"    },"},
{"lineNum":"  359","line":"    else => @compileError(\"Unsupported OS\"),"},
{"lineNum":"  360","line":"};"},
{"lineNum":"  361","line":""},
{"lineNum":"  362","line":"fn sliceContainsPtr(container: []u8, ptr: [*]u8) bool {"},
{"lineNum":"  363","line":"    return @intFromPtr(ptr) >= @intFromPtr(container.ptr) and"},
{"lineNum":"  364","line":"        @intFromPtr(ptr) < (@intFromPtr(container.ptr) + container.len);"},
{"lineNum":"  365","line":"}"},
{"lineNum":"  366","line":""},
{"lineNum":"  367","line":"fn sliceContainsSlice(container: []u8, slice: []u8) bool {","class":"lineCov","hits":"1","order":"328","possible_hits":"1",},
{"lineNum":"  368","line":"    return @intFromPtr(slice.ptr) >= @intFromPtr(container.ptr) and","class":"lineCov","hits":"1","order":"329","possible_hits":"1",},
{"lineNum":"  369","line":"        (@intFromPtr(slice.ptr) + slice.len) <= (@intFromPtr(container.ptr) + container.len);","class":"lineCov","hits":"1","order":"330","possible_hits":"1",},
{"lineNum":"  370","line":"}"},
{"lineNum":"  371","line":""},
{"lineNum":"  372","line":"pub const FixedBufferAllocator = struct {"},
{"lineNum":"  373","line":"    end_index: usize,"},
{"lineNum":"  374","line":"    buffer: []u8,"},
{"lineNum":"  375","line":""},
{"lineNum":"  376","line":"    pub fn init(buffer: []u8) FixedBufferAllocator {"},
{"lineNum":"  377","line":"        return FixedBufferAllocator{"},
{"lineNum":"  378","line":"            .buffer = buffer,"},
{"lineNum":"  379","line":"            .end_index = 0,"},
{"lineNum":"  380","line":"        };"},
{"lineNum":"  381","line":"    }"},
{"lineNum":"  382","line":""},
{"lineNum":"  383","line":"    /// *WARNING* using this at the same time as the interface returned by `threadSafeAllocator` is not thread safe"},
{"lineNum":"  384","line":"    pub fn allocator(self: *FixedBufferAllocator) Allocator {","class":"lineCov","hits":"1","order":"163","possible_hits":"1",},
{"lineNum":"  385","line":"        return .{","class":"lineCov","hits":"1","order":"164","possible_hits":"1",},
{"lineNum":"  386","line":"            .ptr = self,"},
{"lineNum":"  387","line":"            .vtable = &.{"},
{"lineNum":"  388","line":"                .alloc = alloc,"},
{"lineNum":"  389","line":"                .resize = resize,"},
{"lineNum":"  390","line":"                .free = free,"},
{"lineNum":"  391","line":"            },"},
{"lineNum":"  392","line":"        };"},
{"lineNum":"  393","line":"    }"},
{"lineNum":"  394","line":""},
{"lineNum":"  395","line":"    /// Provides a lock free thread safe `Allocator` interface to the underlying `FixedBufferAllocator`"},
{"lineNum":"  396","line":"    /// *WARNING* using this at the same time as the interface returned by `allocator` is not thread safe"},
{"lineNum":"  397","line":"    pub fn threadSafeAllocator(self: *FixedBufferAllocator) Allocator {"},
{"lineNum":"  398","line":"        return .{"},
{"lineNum":"  399","line":"            .ptr = self,"},
{"lineNum":"  400","line":"            .vtable = &.{"},
{"lineNum":"  401","line":"                .alloc = threadSafeAlloc,"},
{"lineNum":"  402","line":"                .resize = Allocator.noResize,"},
{"lineNum":"  403","line":"                .free = Allocator.noFree,"},
{"lineNum":"  404","line":"            },"},
{"lineNum":"  405","line":"        };"},
{"lineNum":"  406","line":"    }"},
{"lineNum":"  407","line":""},
{"lineNum":"  408","line":"    pub fn ownsPtr(self: *FixedBufferAllocator, ptr: [*]u8) bool {"},
{"lineNum":"  409","line":"        return sliceContainsPtr(self.buffer, ptr);"},
{"lineNum":"  410","line":"    }"},
{"lineNum":"  411","line":""},
{"lineNum":"  412","line":"    pub fn ownsSlice(self: *FixedBufferAllocator, slice: []u8) bool {","class":"lineCov","hits":"1","order":"326","possible_hits":"1",},
{"lineNum":"  413","line":"        return sliceContainsSlice(self.buffer, slice);","class":"lineCov","hits":"1","order":"327","possible_hits":"1",},
{"lineNum":"  414","line":"    }"},
{"lineNum":"  415","line":""},
{"lineNum":"  416","line":"    /// NOTE: this will not work in all cases, if the last allocation had an adjusted_index"},
{"lineNum":"  417","line":"    ///       then we won\'t be able to determine what the last allocation was.  This is because"},
{"lineNum":"  418","line":"    ///       the alignForward operation done in alloc is not reversible."},
{"lineNum":"  419","line":"    pub fn isLastAllocation(self: *FixedBufferAllocator, buf: []u8) bool {","class":"lineCov","hits":"1","order":"332","possible_hits":"1",},
{"lineNum":"  420","line":"        return buf.ptr + buf.len == self.buffer.ptr + self.end_index;","class":"lineCov","hits":"1","order":"333","possible_hits":"1",},
{"lineNum":"  421","line":"    }"},
{"lineNum":"  422","line":""},
{"lineNum":"  423","line":"    fn alloc(ctx: *anyopaque, n: usize, log2_ptr_align: u8, ra: usize) ?[*]u8 {","class":"lineCov","hits":"1","order":"238","possible_hits":"1",},
{"lineNum":"  424","line":"        const self: *FixedBufferAllocator = @ptrCast(@alignCast(ctx));","class":"lineCov","hits":"2","order":"239","possible_hits":"2",},
{"lineNum":"  425","line":"        _ = ra;"},
{"lineNum":"  426","line":"        const ptr_align = @as(usize, 1) << @as(Allocator.Log2Align, @intCast(log2_ptr_align));","class":"lineCov","hits":"3","order":"240","possible_hits":"3",},
{"lineNum":"  427","line":"        const adjust_off = mem.alignPointerOffset(self.buffer.ptr + self.end_index, ptr_align) orelse return null;","class":"lineCov","hits":"3","order":"241","possible_hits":"3",},
{"lineNum":"  428","line":"        const adjusted_index = self.end_index + adjust_off;","class":"linePartCov","hits":"1","order":"248","possible_hits":"2",},
{"lineNum":"  429","line":"        const new_end_index = adjusted_index + n;","class":"lineCov","hits":"1","order":"249","possible_hits":"1",},
{"lineNum":"  430","line":"        if (new_end_index > self.buffer.len) return null;","class":"linePartCov","hits":"1","order":"250","possible_hits":"2",},
{"lineNum":"  431","line":"        self.end_index = new_end_index;","class":"lineCov","hits":"1","order":"251","possible_hits":"1",},
{"lineNum":"  432","line":"        return self.buffer.ptr + adjusted_index;","class":"lineCov","hits":"1","order":"252","possible_hits":"1",},
{"lineNum":"  433","line":"    }"},
{"lineNum":"  434","line":""},
{"lineNum":"  435","line":"    fn resize("},
{"lineNum":"  436","line":"        ctx: *anyopaque,"},
{"lineNum":"  437","line":"        buf: []u8,"},
{"lineNum":"  438","line":"        log2_buf_align: u8,"},
{"lineNum":"  439","line":"        new_size: usize,"},
{"lineNum":"  440","line":"        return_address: usize,"},
{"lineNum":"  441","line":"    ) bool {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  442","line":"        const self: *FixedBufferAllocator = @ptrCast(@alignCast(ctx));","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  443","line":"        _ = log2_buf_align;"},
{"lineNum":"  444","line":"        _ = return_address;"},
{"lineNum":"  445","line":"        assert(@inComptime() or self.ownsSlice(buf));","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  446","line":""},
{"lineNum":"  447","line":"        if (!self.isLastAllocation(buf)) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  448","line":"            if (new_size > buf.len) return false;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  449","line":"            return true;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  450","line":"        }"},
{"lineNum":"  451","line":""},
{"lineNum":"  452","line":"        if (new_size <= buf.len) {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  453","line":"            const sub = buf.len - new_size;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  454","line":"            self.end_index -= sub;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  455","line":"            return true;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  456","line":"        }"},
{"lineNum":"  457","line":""},
{"lineNum":"  458","line":"        const add = new_size - buf.len;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  459","line":"        if (add + self.end_index > self.buffer.len) return false;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  460","line":""},
{"lineNum":"  461","line":"        self.end_index += add;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  462","line":"        return true;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  463","line":"    }"},
{"lineNum":"  464","line":""},
{"lineNum":"  465","line":"    fn free("},
{"lineNum":"  466","line":"        ctx: *anyopaque,"},
{"lineNum":"  467","line":"        buf: []u8,"},
{"lineNum":"  468","line":"        log2_buf_align: u8,"},
{"lineNum":"  469","line":"        return_address: usize,"},
{"lineNum":"  470","line":"    ) void {","class":"lineCov","hits":"1","order":"323","possible_hits":"1",},
{"lineNum":"  471","line":"        const self: *FixedBufferAllocator = @ptrCast(@alignCast(ctx));","class":"lineCov","hits":"2","order":"324","possible_hits":"2",},
{"lineNum":"  472","line":"        _ = log2_buf_align;"},
{"lineNum":"  473","line":"        _ = return_address;"},
{"lineNum":"  474","line":"        assert(@inComptime() or self.ownsSlice(buf));","class":"lineCov","hits":"1","order":"325","possible_hits":"1",},
{"lineNum":"  475","line":""},
{"lineNum":"  476","line":"        if (self.isLastAllocation(buf)) {","class":"lineCov","hits":"1","order":"331","possible_hits":"1",},
{"lineNum":"  477","line":"            self.end_index -= buf.len;","class":"lineCov","hits":"1","order":"334","possible_hits":"1",},
{"lineNum":"  478","line":"        }"},
{"lineNum":"  479","line":"    }"},
{"lineNum":"  480","line":""},
{"lineNum":"  481","line":"    fn threadSafeAlloc(ctx: *anyopaque, n: usize, log2_ptr_align: u8, ra: usize) ?[*]u8 {"},
{"lineNum":"  482","line":"        const self: *FixedBufferAllocator = @ptrCast(@alignCast(ctx));"},
{"lineNum":"  483","line":"        _ = ra;"},
{"lineNum":"  484","line":"        const ptr_align = @as(usize, 1) << @as(Allocator.Log2Align, @intCast(log2_ptr_align));"},
{"lineNum":"  485","line":"        var end_index = @atomicLoad(usize, &self.end_index, .SeqCst);"},
{"lineNum":"  486","line":"        while (true) {"},
{"lineNum":"  487","line":"            const adjust_off = mem.alignPointerOffset(self.buffer.ptr + end_index, ptr_align) orelse return null;"},
{"lineNum":"  488","line":"            const adjusted_index = end_index + adjust_off;"},
{"lineNum":"  489","line":"            const new_end_index = adjusted_index + n;"},
{"lineNum":"  490","line":"            if (new_end_index > self.buffer.len) return null;"},
{"lineNum":"  491","line":"            end_index = @cmpxchgWeak(usize, &self.end_index, end_index, new_end_index, .SeqCst, .SeqCst) orelse"},
{"lineNum":"  492","line":"                return self.buffer[adjusted_index..new_end_index].ptr;"},
{"lineNum":"  493","line":"        }"},
{"lineNum":"  494","line":"    }"},
{"lineNum":"  495","line":""},
{"lineNum":"  496","line":"    pub fn reset(self: *FixedBufferAllocator) void {"},
{"lineNum":"  497","line":"        self.end_index = 0;"},
{"lineNum":"  498","line":"    }"},
{"lineNum":"  499","line":"};"},
{"lineNum":"  500","line":""},
{"lineNum":"  501","line":"pub const ThreadSafeFixedBufferAllocator = @compileError(\"ThreadSafeFixedBufferAllocator has been replaced with `threadSafeAllocator` on FixedBufferAllocator\");"},
{"lineNum":"  502","line":""},
{"lineNum":"  503","line":"/// Returns a `StackFallbackAllocator` allocating using either a"},
{"lineNum":"  504","line":"/// `FixedBufferAllocator` on an array of size `size` and falling back to"},
{"lineNum":"  505","line":"/// `fallback_allocator` if that fails."},
{"lineNum":"  506","line":"pub fn stackFallback(comptime size: usize, fallback_allocator: Allocator) StackFallbackAllocator(size) {"},
{"lineNum":"  507","line":"    return StackFallbackAllocator(size){"},
{"lineNum":"  508","line":"        .buffer = undefined,"},
{"lineNum":"  509","line":"        .fallback_allocator = fallback_allocator,"},
{"lineNum":"  510","line":"        .fixed_buffer_allocator = undefined,"},
{"lineNum":"  511","line":"    };"},
{"lineNum":"  512","line":"}"},
{"lineNum":"  513","line":""},
{"lineNum":"  514","line":"/// An allocator that attempts to allocate using a"},
{"lineNum":"  515","line":"/// `FixedBufferAllocator` using an array of size `size`. If the"},
{"lineNum":"  516","line":"/// allocation fails, it will fall back to using"},
{"lineNum":"  517","line":"/// `fallback_allocator`. Easily created with `stackFallback`."},
{"lineNum":"  518","line":"pub fn StackFallbackAllocator(comptime size: usize) type {"},
{"lineNum":"  519","line":"    return struct {"},
{"lineNum":"  520","line":"        const Self = @This();"},
{"lineNum":"  521","line":""},
{"lineNum":"  522","line":"        buffer: [size]u8,"},
{"lineNum":"  523","line":"        fallback_allocator: Allocator,"},
{"lineNum":"  524","line":"        fixed_buffer_allocator: FixedBufferAllocator,"},
{"lineNum":"  525","line":""},
{"lineNum":"  526","line":"        /// This function both fetches a `Allocator` interface to this"},
{"lineNum":"  527","line":"        /// allocator *and* resets the internal buffer allocator."},
{"lineNum":"  528","line":"        pub fn get(self: *Self) Allocator {"},
{"lineNum":"  529","line":"            self.fixed_buffer_allocator = FixedBufferAllocator.init(self.buffer[0..]);"},
{"lineNum":"  530","line":"            return .{"},
{"lineNum":"  531","line":"                .ptr = self,"},
{"lineNum":"  532","line":"                .vtable = &.{"},
{"lineNum":"  533","line":"                    .alloc = alloc,"},
{"lineNum":"  534","line":"                    .resize = resize,"},
{"lineNum":"  535","line":"                    .free = free,"},
{"lineNum":"  536","line":"                },"},
{"lineNum":"  537","line":"            };"},
{"lineNum":"  538","line":"        }"},
{"lineNum":"  539","line":""},
{"lineNum":"  540","line":"        fn alloc("},
{"lineNum":"  541","line":"            ctx: *anyopaque,"},
{"lineNum":"  542","line":"            len: usize,"},
{"lineNum":"  543","line":"            log2_ptr_align: u8,"},
{"lineNum":"  544","line":"            ra: usize,"},
{"lineNum":"  545","line":"        ) ?[*]u8 {"},
{"lineNum":"  546","line":"            const self: *Self = @ptrCast(@alignCast(ctx));"},
{"lineNum":"  547","line":"            return FixedBufferAllocator.alloc(&self.fixed_buffer_allocator, len, log2_ptr_align, ra) orelse"},
{"lineNum":"  548","line":"                return self.fallback_allocator.rawAlloc(len, log2_ptr_align, ra);"},
{"lineNum":"  549","line":"        }"},
{"lineNum":"  550","line":""},
{"lineNum":"  551","line":"        fn resize("},
{"lineNum":"  552","line":"            ctx: *anyopaque,"},
{"lineNum":"  553","line":"            buf: []u8,"},
{"lineNum":"  554","line":"            log2_buf_align: u8,"},
{"lineNum":"  555","line":"            new_len: usize,"},
{"lineNum":"  556","line":"            ra: usize,"},
{"lineNum":"  557","line":"        ) bool {"},
{"lineNum":"  558","line":"            const self: *Self = @ptrCast(@alignCast(ctx));"},
{"lineNum":"  559","line":"            if (self.fixed_buffer_allocator.ownsPtr(buf.ptr)) {"},
{"lineNum":"  560","line":"                return FixedBufferAllocator.resize(&self.fixed_buffer_allocator, buf, log2_buf_align, new_len, ra);"},
{"lineNum":"  561","line":"            } else {"},
{"lineNum":"  562","line":"                return self.fallback_allocator.rawResize(buf, log2_buf_align, new_len, ra);"},
{"lineNum":"  563","line":"            }"},
{"lineNum":"  564","line":"        }"},
{"lineNum":"  565","line":""},
{"lineNum":"  566","line":"        fn free("},
{"lineNum":"  567","line":"            ctx: *anyopaque,"},
{"lineNum":"  568","line":"            buf: []u8,"},
{"lineNum":"  569","line":"            log2_buf_align: u8,"},
{"lineNum":"  570","line":"            ra: usize,"},
{"lineNum":"  571","line":"        ) void {"},
{"lineNum":"  572","line":"            const self: *Self = @ptrCast(@alignCast(ctx));"},
{"lineNum":"  573","line":"            if (self.fixed_buffer_allocator.ownsPtr(buf.ptr)) {"},
{"lineNum":"  574","line":"                return FixedBufferAllocator.free(&self.fixed_buffer_allocator, buf, log2_buf_align, ra);"},
{"lineNum":"  575","line":"            } else {"},
{"lineNum":"  576","line":"                return self.fallback_allocator.rawFree(buf, log2_buf_align, ra);"},
{"lineNum":"  577","line":"            }"},
{"lineNum":"  578","line":"        }"},
{"lineNum":"  579","line":"    };"},
{"lineNum":"  580","line":"}"},
{"lineNum":"  581","line":""},
{"lineNum":"  582","line":"test \"c_allocator\" {"},
{"lineNum":"  583","line":"    if (builtin.link_libc) {"},
{"lineNum":"  584","line":"        try testAllocator(c_allocator);"},
{"lineNum":"  585","line":"        try testAllocatorAligned(c_allocator);"},
{"lineNum":"  586","line":"        try testAllocatorLargeAlignment(c_allocator);"},
{"lineNum":"  587","line":"        try testAllocatorAlignedShrink(c_allocator);"},
{"lineNum":"  588","line":"    }"},
{"lineNum":"  589","line":"}"},
{"lineNum":"  590","line":""},
{"lineNum":"  591","line":"test \"raw_c_allocator\" {"},
{"lineNum":"  592","line":"    if (builtin.link_libc) {"},
{"lineNum":"  593","line":"        try testAllocator(raw_c_allocator);"},
{"lineNum":"  594","line":"    }"},
{"lineNum":"  595","line":"}"},
{"lineNum":"  596","line":""},
{"lineNum":"  597","line":"test \"PageAllocator\" {"},
{"lineNum":"  598","line":"    const allocator = page_allocator;"},
{"lineNum":"  599","line":"    try testAllocator(allocator);"},
{"lineNum":"  600","line":"    try testAllocatorAligned(allocator);"},
{"lineNum":"  601","line":"    if (!builtin.target.isWasm()) {"},
{"lineNum":"  602","line":"        try testAllocatorLargeAlignment(allocator);"},
{"lineNum":"  603","line":"        try testAllocatorAlignedShrink(allocator);"},
{"lineNum":"  604","line":"    }"},
{"lineNum":"  605","line":""},
{"lineNum":"  606","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":"  607","line":"        const slice = try allocator.alignedAlloc(u8, mem.page_size, 128);"},
{"lineNum":"  608","line":"        slice[0] = 0x12;"},
{"lineNum":"  609","line":"        slice[127] = 0x34;"},
{"lineNum":"  610","line":"        allocator.free(slice);"},
{"lineNum":"  611","line":"    }"},
{"lineNum":"  612","line":"    {"},
{"lineNum":"  613","line":"        var buf = try allocator.alloc(u8, mem.page_size + 1);"},
{"lineNum":"  614","line":"        defer allocator.free(buf);"},
{"lineNum":"  615","line":"        buf = try allocator.realloc(buf, 1); // shrink past the page boundary"},
{"lineNum":"  616","line":"    }"},
{"lineNum":"  617","line":"}"},
{"lineNum":"  618","line":""},
{"lineNum":"  619","line":"test \"HeapAllocator\" {"},
{"lineNum":"  620","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":"  621","line":"        // https://github.com/ziglang/zig/issues/13702"},
{"lineNum":"  622","line":"        if (builtin.cpu.arch == .aarch64) return error.SkipZigTest;"},
{"lineNum":"  623","line":""},
{"lineNum":"  624","line":"        var heap_allocator = HeapAllocator.init();"},
{"lineNum":"  625","line":"        defer heap_allocator.deinit();"},
{"lineNum":"  626","line":"        const allocator = heap_allocator.allocator();"},
{"lineNum":"  627","line":""},
{"lineNum":"  628","line":"        try testAllocator(allocator);"},
{"lineNum":"  629","line":"        try testAllocatorAligned(allocator);"},
{"lineNum":"  630","line":"        try testAllocatorLargeAlignment(allocator);"},
{"lineNum":"  631","line":"        try testAllocatorAlignedShrink(allocator);"},
{"lineNum":"  632","line":"    }"},
{"lineNum":"  633","line":"}"},
{"lineNum":"  634","line":""},
{"lineNum":"  635","line":"test \"ArenaAllocator\" {"},
{"lineNum":"  636","line":"    var arena_allocator = ArenaAllocator.init(page_allocator);"},
{"lineNum":"  637","line":"    defer arena_allocator.deinit();"},
{"lineNum":"  638","line":"    const allocator = arena_allocator.allocator();"},
{"lineNum":"  639","line":""},
{"lineNum":"  640","line":"    try testAllocator(allocator);"},
{"lineNum":"  641","line":"    try testAllocatorAligned(allocator);"},
{"lineNum":"  642","line":"    try testAllocatorLargeAlignment(allocator);"},
{"lineNum":"  643","line":"    try testAllocatorAlignedShrink(allocator);"},
{"lineNum":"  644","line":"}"},
{"lineNum":"  645","line":""},
{"lineNum":"  646","line":"var test_fixed_buffer_allocator_memory: [800000 * @sizeOf(u64)]u8 = undefined;"},
{"lineNum":"  647","line":"test \"FixedBufferAllocator\" {"},
{"lineNum":"  648","line":"    var fixed_buffer_allocator = mem.validationWrap(FixedBufferAllocator.init(test_fixed_buffer_allocator_memory[0..]));"},
{"lineNum":"  649","line":"    const allocator = fixed_buffer_allocator.allocator();"},
{"lineNum":"  650","line":""},
{"lineNum":"  651","line":"    try testAllocator(allocator);"},
{"lineNum":"  652","line":"    try testAllocatorAligned(allocator);"},
{"lineNum":"  653","line":"    try testAllocatorLargeAlignment(allocator);"},
{"lineNum":"  654","line":"    try testAllocatorAlignedShrink(allocator);"},
{"lineNum":"  655","line":"}"},
{"lineNum":"  656","line":""},
{"lineNum":"  657","line":"test \"FixedBufferAllocator.reset\" {"},
{"lineNum":"  658","line":"    var buf: [8]u8 align(@alignOf(u64)) = undefined;"},
{"lineNum":"  659","line":"    var fba = FixedBufferAllocator.init(buf[0..]);"},
{"lineNum":"  660","line":"    const allocator = fba.allocator();"},
{"lineNum":"  661","line":""},
{"lineNum":"  662","line":"    const X = 0xeeeeeeeeeeeeeeee;"},
{"lineNum":"  663","line":"    const Y = 0xffffffffffffffff;"},
{"lineNum":"  664","line":""},
{"lineNum":"  665","line":"    var x = try allocator.create(u64);"},
{"lineNum":"  666","line":"    x.* = X;"},
{"lineNum":"  667","line":"    try testing.expectError(error.OutOfMemory, allocator.create(u64));"},
{"lineNum":"  668","line":""},
{"lineNum":"  669","line":"    fba.reset();"},
{"lineNum":"  670","line":"    var y = try allocator.create(u64);"},
{"lineNum":"  671","line":"    y.* = Y;"},
{"lineNum":"  672","line":""},
{"lineNum":"  673","line":"    // we expect Y to have overwritten X."},
{"lineNum":"  674","line":"    try testing.expect(x.* == y.*);"},
{"lineNum":"  675","line":"    try testing.expect(y.* == Y);"},
{"lineNum":"  676","line":"}"},
{"lineNum":"  677","line":""},
{"lineNum":"  678","line":"test \"StackFallbackAllocator\" {"},
{"lineNum":"  679","line":"    const fallback_allocator = page_allocator;"},
{"lineNum":"  680","line":"    var stack_allocator = stackFallback(4096, fallback_allocator);"},
{"lineNum":"  681","line":""},
{"lineNum":"  682","line":"    try testAllocator(stack_allocator.get());"},
{"lineNum":"  683","line":"    try testAllocatorAligned(stack_allocator.get());"},
{"lineNum":"  684","line":"    try testAllocatorLargeAlignment(stack_allocator.get());"},
{"lineNum":"  685","line":"    try testAllocatorAlignedShrink(stack_allocator.get());"},
{"lineNum":"  686","line":"}"},
{"lineNum":"  687","line":""},
{"lineNum":"  688","line":"test \"FixedBufferAllocator Reuse memory on realloc\" {"},
{"lineNum":"  689","line":"    var small_fixed_buffer: [10]u8 = undefined;"},
{"lineNum":"  690","line":"    // check if we re-use the memory"},
{"lineNum":"  691","line":"    {"},
{"lineNum":"  692","line":"        var fixed_buffer_allocator = FixedBufferAllocator.init(small_fixed_buffer[0..]);"},
{"lineNum":"  693","line":"        const allocator = fixed_buffer_allocator.allocator();"},
{"lineNum":"  694","line":""},
{"lineNum":"  695","line":"        var slice0 = try allocator.alloc(u8, 5);"},
{"lineNum":"  696","line":"        try testing.expect(slice0.len == 5);"},
{"lineNum":"  697","line":"        var slice1 = try allocator.realloc(slice0, 10);"},
{"lineNum":"  698","line":"        try testing.expect(slice1.ptr == slice0.ptr);"},
{"lineNum":"  699","line":"        try testing.expect(slice1.len == 10);"},
{"lineNum":"  700","line":"        try testing.expectError(error.OutOfMemory, allocator.realloc(slice1, 11));"},
{"lineNum":"  701","line":"    }"},
{"lineNum":"  702","line":"    // check that we don\'t re-use the memory if it\'s not the most recent block"},
{"lineNum":"  703","line":"    {"},
{"lineNum":"  704","line":"        var fixed_buffer_allocator = FixedBufferAllocator.init(small_fixed_buffer[0..]);"},
{"lineNum":"  705","line":"        const allocator = fixed_buffer_allocator.allocator();"},
{"lineNum":"  706","line":""},
{"lineNum":"  707","line":"        var slice0 = try allocator.alloc(u8, 2);"},
{"lineNum":"  708","line":"        slice0[0] = 1;"},
{"lineNum":"  709","line":"        slice0[1] = 2;"},
{"lineNum":"  710","line":"        var slice1 = try allocator.alloc(u8, 2);"},
{"lineNum":"  711","line":"        var slice2 = try allocator.realloc(slice0, 4);"},
{"lineNum":"  712","line":"        try testing.expect(slice0.ptr != slice2.ptr);"},
{"lineNum":"  713","line":"        try testing.expect(slice1.ptr != slice2.ptr);"},
{"lineNum":"  714","line":"        try testing.expect(slice2[0] == 1);"},
{"lineNum":"  715","line":"        try testing.expect(slice2[1] == 2);"},
{"lineNum":"  716","line":"    }"},
{"lineNum":"  717","line":"}"},
{"lineNum":"  718","line":""},
{"lineNum":"  719","line":"test \"Thread safe FixedBufferAllocator\" {"},
{"lineNum":"  720","line":"    var fixed_buffer_allocator = FixedBufferAllocator.init(test_fixed_buffer_allocator_memory[0..]);"},
{"lineNum":"  721","line":""},
{"lineNum":"  722","line":"    try testAllocator(fixed_buffer_allocator.threadSafeAllocator());"},
{"lineNum":"  723","line":"    try testAllocatorAligned(fixed_buffer_allocator.threadSafeAllocator());"},
{"lineNum":"  724","line":"    try testAllocatorLargeAlignment(fixed_buffer_allocator.threadSafeAllocator());"},
{"lineNum":"  725","line":"    try testAllocatorAlignedShrink(fixed_buffer_allocator.threadSafeAllocator());"},
{"lineNum":"  726","line":"}"},
{"lineNum":"  727","line":""},
{"lineNum":"  728","line":"/// This one should not try alignments that exceed what C malloc can handle."},
{"lineNum":"  729","line":"pub fn testAllocator(base_allocator: mem.Allocator) !void {"},
{"lineNum":"  730","line":"    var validationAllocator = mem.validationWrap(base_allocator);"},
{"lineNum":"  731","line":"    const allocator = validationAllocator.allocator();"},
{"lineNum":"  732","line":""},
{"lineNum":"  733","line":"    var slice = try allocator.alloc(*i32, 100);"},
{"lineNum":"  734","line":"    try testing.expect(slice.len == 100);"},
{"lineNum":"  735","line":"    for (slice, 0..) |*item, i| {"},
{"lineNum":"  736","line":"        item.* = try allocator.create(i32);"},
{"lineNum":"  737","line":"        item.*.* = @as(i32, @intCast(i));"},
{"lineNum":"  738","line":"    }"},
{"lineNum":"  739","line":""},
{"lineNum":"  740","line":"    slice = try allocator.realloc(slice, 20000);"},
{"lineNum":"  741","line":"    try testing.expect(slice.len == 20000);"},
{"lineNum":"  742","line":""},
{"lineNum":"  743","line":"    for (slice[0..100], 0..) |item, i| {"},
{"lineNum":"  744","line":"        try testing.expect(item.* == @as(i32, @intCast(i)));"},
{"lineNum":"  745","line":"        allocator.destroy(item);"},
{"lineNum":"  746","line":"    }"},
{"lineNum":"  747","line":""},
{"lineNum":"  748","line":"    if (allocator.resize(slice, 50)) {"},
{"lineNum":"  749","line":"        slice = slice[0..50];"},
{"lineNum":"  750","line":"        if (allocator.resize(slice, 25)) {"},
{"lineNum":"  751","line":"            slice = slice[0..25];"},
{"lineNum":"  752","line":"            try testing.expect(allocator.resize(slice, 0));"},
{"lineNum":"  753","line":"            slice = slice[0..0];"},
{"lineNum":"  754","line":"            slice = try allocator.realloc(slice, 10);"},
{"lineNum":"  755","line":"            try testing.expect(slice.len == 10);"},
{"lineNum":"  756","line":"        }"},
{"lineNum":"  757","line":"    }"},
{"lineNum":"  758","line":"    allocator.free(slice);"},
{"lineNum":"  759","line":""},
{"lineNum":"  760","line":"    // Zero-length allocation"},
{"lineNum":"  761","line":"    var empty = try allocator.alloc(u8, 0);"},
{"lineNum":"  762","line":"    allocator.free(empty);"},
{"lineNum":"  763","line":"    // Allocation with zero-sized types"},
{"lineNum":"  764","line":"    const zero_bit_ptr = try allocator.create(u0);"},
{"lineNum":"  765","line":"    zero_bit_ptr.* = 0;"},
{"lineNum":"  766","line":"    allocator.destroy(zero_bit_ptr);"},
{"lineNum":"  767","line":""},
{"lineNum":"  768","line":"    const oversize = try allocator.alignedAlloc(u32, null, 5);"},
{"lineNum":"  769","line":"    try testing.expect(oversize.len >= 5);"},
{"lineNum":"  770","line":"    for (oversize) |*item| {"},
{"lineNum":"  771","line":"        item.* = 0xDEADBEEF;"},
{"lineNum":"  772","line":"    }"},
{"lineNum":"  773","line":"    allocator.free(oversize);"},
{"lineNum":"  774","line":"}"},
{"lineNum":"  775","line":""},
{"lineNum":"  776","line":"pub fn testAllocatorAligned(base_allocator: mem.Allocator) !void {"},
{"lineNum":"  777","line":"    var validationAllocator = mem.validationWrap(base_allocator);"},
{"lineNum":"  778","line":"    const allocator = validationAllocator.allocator();"},
{"lineNum":"  779","line":""},
{"lineNum":"  780","line":"    // Test a few alignment values, smaller and bigger than the type\'s one"},
{"lineNum":"  781","line":"    inline for ([_]u29{ 1, 2, 4, 8, 16, 32, 64 }) |alignment| {"},
{"lineNum":"  782","line":"        // initial"},
{"lineNum":"  783","line":"        var slice = try allocator.alignedAlloc(u8, alignment, 10);"},
{"lineNum":"  784","line":"        try testing.expect(slice.len == 10);"},
{"lineNum":"  785","line":"        // grow"},
{"lineNum":"  786","line":"        slice = try allocator.realloc(slice, 100);"},
{"lineNum":"  787","line":"        try testing.expect(slice.len == 100);"},
{"lineNum":"  788","line":"        if (allocator.resize(slice, 10)) {"},
{"lineNum":"  789","line":"            slice = slice[0..10];"},
{"lineNum":"  790","line":"        }"},
{"lineNum":"  791","line":"        try testing.expect(allocator.resize(slice, 0));"},
{"lineNum":"  792","line":"        slice = slice[0..0];"},
{"lineNum":"  793","line":"        // realloc from zero"},
{"lineNum":"  794","line":"        slice = try allocator.realloc(slice, 100);"},
{"lineNum":"  795","line":"        try testing.expect(slice.len == 100);"},
{"lineNum":"  796","line":"        if (allocator.resize(slice, 10)) {"},
{"lineNum":"  797","line":"            slice = slice[0..10];"},
{"lineNum":"  798","line":"        }"},
{"lineNum":"  799","line":"        try testing.expect(allocator.resize(slice, 0));"},
{"lineNum":"  800","line":"    }"},
{"lineNum":"  801","line":"}"},
{"lineNum":"  802","line":""},
{"lineNum":"  803","line":"pub fn testAllocatorLargeAlignment(base_allocator: mem.Allocator) !void {"},
{"lineNum":"  804","line":"    var validationAllocator = mem.validationWrap(base_allocator);"},
{"lineNum":"  805","line":"    const allocator = validationAllocator.allocator();"},
{"lineNum":"  806","line":""},
{"lineNum":"  807","line":"    const large_align: usize = mem.page_size / 2;"},
{"lineNum":"  808","line":""},
{"lineNum":"  809","line":"    var align_mask: usize = undefined;"},
{"lineNum":"  810","line":"    align_mask = @shlWithOverflow(~@as(usize, 0), @as(Allocator.Log2Align, @ctz(large_align)))[0];"},
{"lineNum":"  811","line":""},
{"lineNum":"  812","line":"    var slice = try allocator.alignedAlloc(u8, large_align, 500);"},
{"lineNum":"  813","line":"    try testing.expect(@intFromPtr(slice.ptr) & align_mask == @intFromPtr(slice.ptr));"},
{"lineNum":"  814","line":""},
{"lineNum":"  815","line":"    if (allocator.resize(slice, 100)) {"},
{"lineNum":"  816","line":"        slice = slice[0..100];"},
{"lineNum":"  817","line":"    }"},
{"lineNum":"  818","line":""},
{"lineNum":"  819","line":"    slice = try allocator.realloc(slice, 5000);"},
{"lineNum":"  820","line":"    try testing.expect(@intFromPtr(slice.ptr) & align_mask == @intFromPtr(slice.ptr));"},
{"lineNum":"  821","line":""},
{"lineNum":"  822","line":"    if (allocator.resize(slice, 10)) {"},
{"lineNum":"  823","line":"        slice = slice[0..10];"},
{"lineNum":"  824","line":"    }"},
{"lineNum":"  825","line":""},
{"lineNum":"  826","line":"    slice = try allocator.realloc(slice, 20000);"},
{"lineNum":"  827","line":"    try testing.expect(@intFromPtr(slice.ptr) & align_mask == @intFromPtr(slice.ptr));"},
{"lineNum":"  828","line":""},
{"lineNum":"  829","line":"    allocator.free(slice);"},
{"lineNum":"  830","line":"}"},
{"lineNum":"  831","line":""},
{"lineNum":"  832","line":"pub fn testAllocatorAlignedShrink(base_allocator: mem.Allocator) !void {"},
{"lineNum":"  833","line":"    var validationAllocator = mem.validationWrap(base_allocator);"},
{"lineNum":"  834","line":"    const allocator = validationAllocator.allocator();"},
{"lineNum":"  835","line":""},
{"lineNum":"  836","line":"    var debug_buffer: [1000]u8 = undefined;"},
{"lineNum":"  837","line":"    var fib = FixedBufferAllocator.init(&debug_buffer);"},
{"lineNum":"  838","line":"    const debug_allocator = fib.allocator();"},
{"lineNum":"  839","line":""},
{"lineNum":"  840","line":"    const alloc_size = mem.page_size * 2 + 50;"},
{"lineNum":"  841","line":"    var slice = try allocator.alignedAlloc(u8, 16, alloc_size);"},
{"lineNum":"  842","line":"    defer allocator.free(slice);"},
{"lineNum":"  843","line":""},
{"lineNum":"  844","line":"    var stuff_to_free = std.ArrayList([]align(16) u8).init(debug_allocator);"},
{"lineNum":"  845","line":"    // On Windows, VirtualAlloc returns addresses aligned to a 64K boundary,"},
{"lineNum":"  846","line":"    // which is 16 pages, hence the 32. This test may require to increase"},
{"lineNum":"  847","line":"    // the size of the allocations feeding the `allocator` parameter if they"},
{"lineNum":"  848","line":"    // fail, because of this high over-alignment we want to have."},
{"lineNum":"  849","line":"    while (@intFromPtr(slice.ptr) == mem.alignForward(usize, @intFromPtr(slice.ptr), mem.page_size * 32)) {"},
{"lineNum":"  850","line":"        try stuff_to_free.append(slice);"},
{"lineNum":"  851","line":"        slice = try allocator.alignedAlloc(u8, 16, alloc_size);"},
{"lineNum":"  852","line":"    }"},
{"lineNum":"  853","line":"    while (stuff_to_free.popOrNull()) |item| {"},
{"lineNum":"  854","line":"        allocator.free(item);"},
{"lineNum":"  855","line":"    }"},
{"lineNum":"  856","line":"    slice[0] = 0x12;"},
{"lineNum":"  857","line":"    slice[60] = 0x34;"},
{"lineNum":"  858","line":""},
{"lineNum":"  859","line":"    slice = try allocator.reallocAdvanced(slice, alloc_size / 2, 0);"},
{"lineNum":"  860","line":"    try testing.expect(slice[0] == 0x12);"},
{"lineNum":"  861","line":"    try testing.expect(slice[60] == 0x34);"},
{"lineNum":"  862","line":"}"},
{"lineNum":"  863","line":""},
{"lineNum":"  864","line":"test {"},
{"lineNum":"  865","line":"    _ = LoggingAllocator;"},
{"lineNum":"  866","line":"    _ = LogToWriterAllocator;"},
{"lineNum":"  867","line":"    _ = ScopedLoggingAllocator;"},
{"lineNum":"  868","line":"    _ = @import(\"heap/memory_pool.zig\");"},
{"lineNum":"  869","line":"    _ = ArenaAllocator;"},
{"lineNum":"  870","line":"    _ = GeneralPurposeAllocator;"},
{"lineNum":"  871","line":"    if (comptime builtin.target.isWasm()) {"},
{"lineNum":"  872","line":"        _ = WasmAllocator;"},
{"lineNum":"  873","line":"        _ = WasmPageAllocator;"},
{"lineNum":"  874","line":"    }"},
{"lineNum":"  875","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test", "date" : "2024-04-26 16:14:49", "instrumented" : 37, "covered" : 23,};
var merged_data = [];
