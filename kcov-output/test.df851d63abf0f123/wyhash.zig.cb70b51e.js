var data = {lines:[
{"lineNum":"    1","line":"const std = @import(\"std\");"},
{"lineNum":"    2","line":""},
{"lineNum":"    3","line":"pub const Wyhash = struct {"},
{"lineNum":"    4","line":"    const secret = [_]u64{"},
{"lineNum":"    5","line":"        0xa0761d6478bd642f,"},
{"lineNum":"    6","line":"        0xe7037ed1a0b428db,"},
{"lineNum":"    7","line":"        0x8ebc6af09c88c6e3,"},
{"lineNum":"    8","line":"        0x589965cc75374cc3,"},
{"lineNum":"    9","line":"    };"},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"    a: u64,"},
{"lineNum":"   12","line":"    b: u64,"},
{"lineNum":"   13","line":"    state: [3]u64,"},
{"lineNum":"   14","line":"    total_len: usize,"},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"    buf: [48]u8,"},
{"lineNum":"   17","line":"    buf_len: usize,"},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"    pub fn init(seed: u64) Wyhash {","class":"lineCov","hits":"1","order":"998","possible_hits":"1",},
{"lineNum":"   20","line":"        var self = Wyhash{","class":"lineCov","hits":"1","order":"999","possible_hits":"1",},
{"lineNum":"   21","line":"            .a = undefined,"},
{"lineNum":"   22","line":"            .b = undefined,"},
{"lineNum":"   23","line":"            .state = undefined,"},
{"lineNum":"   24","line":"            .total_len = 0,"},
{"lineNum":"   25","line":"            .buf = undefined,"},
{"lineNum":"   26","line":"            .buf_len = 0,"},
{"lineNum":"   27","line":"        };"},
{"lineNum":"   28","line":""},
{"lineNum":"   29","line":"        self.state[0] = seed ^ mix(seed ^ secret[0], secret[1]);","class":"lineCov","hits":"1","order":"1000","possible_hits":"1",},
{"lineNum":"   30","line":"        self.state[1] = self.state[0];","class":"lineCov","hits":"1","order":"1008","possible_hits":"1",},
{"lineNum":"   31","line":"        self.state[2] = self.state[0];","class":"lineCov","hits":"1","order":"1009","possible_hits":"1",},
{"lineNum":"   32","line":"        return self;","class":"lineCov","hits":"1","order":"1010","possible_hits":"1",},
{"lineNum":"   33","line":"    }"},
{"lineNum":"   34","line":""},
{"lineNum":"   35","line":"    // This is subtly different from other hash function update calls. Wyhash requires the last"},
{"lineNum":"   36","line":"    // full 48-byte block to be run through final1 if is exactly aligned to 48-bytes."},
{"lineNum":"   37","line":"    pub fn update(self: *Wyhash, input: []const u8) void {"},
{"lineNum":"   38","line":"        self.total_len += input.len;"},
{"lineNum":"   39","line":""},
{"lineNum":"   40","line":"        if (input.len <= 48 - self.buf_len) {"},
{"lineNum":"   41","line":"            @memcpy(self.buf[self.buf_len..][0..input.len], input);"},
{"lineNum":"   42","line":"            self.buf_len += input.len;"},
{"lineNum":"   43","line":"            return;"},
{"lineNum":"   44","line":"        }"},
{"lineNum":"   45","line":""},
{"lineNum":"   46","line":"        var i: usize = 0;"},
{"lineNum":"   47","line":""},
{"lineNum":"   48","line":"        if (self.buf_len > 0) {"},
{"lineNum":"   49","line":"            i = 48 - self.buf_len;"},
{"lineNum":"   50","line":"            @memcpy(self.buf[self.buf_len..][0..i], input[0..i]);"},
{"lineNum":"   51","line":"            self.round(&self.buf);"},
{"lineNum":"   52","line":"            self.buf_len = 0;"},
{"lineNum":"   53","line":"        }"},
{"lineNum":"   54","line":""},
{"lineNum":"   55","line":"        while (i + 48 < input.len) : (i += 48) {"},
{"lineNum":"   56","line":"            self.round(input[i..][0..48]);"},
{"lineNum":"   57","line":"        }"},
{"lineNum":"   58","line":""},
{"lineNum":"   59","line":"        const remaining_bytes = input[i..];"},
{"lineNum":"   60","line":"        @memcpy(self.buf[0..remaining_bytes.len], remaining_bytes);"},
{"lineNum":"   61","line":"        self.buf_len = remaining_bytes.len;"},
{"lineNum":"   62","line":"    }"},
{"lineNum":"   63","line":""},
{"lineNum":"   64","line":"    pub fn final(self: *Wyhash) u64 {"},
{"lineNum":"   65","line":"        var input = self.buf[0..self.buf_len];"},
{"lineNum":"   66","line":"        var newSelf = self.shallowCopy(); // ensure idempotency"},
{"lineNum":"   67","line":""},
{"lineNum":"   68","line":"        if (self.total_len <= 16) {"},
{"lineNum":"   69","line":"            newSelf.smallKey(input);"},
{"lineNum":"   70","line":"        } else {"},
{"lineNum":"   71","line":"            var offset: usize = 0;"},
{"lineNum":"   72","line":"            if (self.buf_len < 16) {"},
{"lineNum":"   73","line":"                var scratch: [16]u8 = undefined;"},
{"lineNum":"   74","line":"                const rem = 16 - self.buf_len;"},
{"lineNum":"   75","line":"                @memcpy(scratch[0..rem], self.buf[self.buf.len - rem ..][0..rem]);"},
{"lineNum":"   76","line":"                @memcpy(scratch[rem..][0..self.buf_len], self.buf[0..self.buf_len]);"},
{"lineNum":"   77","line":""},
{"lineNum":"   78","line":"                // Same as input but with additional bytes preceeding start in case of a short buffer"},
{"lineNum":"   79","line":"                input = &scratch;"},
{"lineNum":"   80","line":"                offset = rem;"},
{"lineNum":"   81","line":"            }"},
{"lineNum":"   82","line":""},
{"lineNum":"   83","line":"            newSelf.final0();"},
{"lineNum":"   84","line":"            newSelf.final1(input, offset);"},
{"lineNum":"   85","line":"        }"},
{"lineNum":"   86","line":""},
{"lineNum":"   87","line":"        return newSelf.final2();"},
{"lineNum":"   88","line":"    }"},
{"lineNum":"   89","line":""},
{"lineNum":"   90","line":"    // Copies the core wyhash state but not any internal buffers."},
{"lineNum":"   91","line":"    inline fn shallowCopy(self: *Wyhash) Wyhash {"},
{"lineNum":"   92","line":"        return .{"},
{"lineNum":"   93","line":"            .a = self.a,"},
{"lineNum":"   94","line":"            .b = self.b,"},
{"lineNum":"   95","line":"            .state = self.state,"},
{"lineNum":"   96","line":"            .total_len = self.total_len,"},
{"lineNum":"   97","line":"            .buf = undefined,"},
{"lineNum":"   98","line":"            .buf_len = undefined,"},
{"lineNum":"   99","line":"        };"},
{"lineNum":"  100","line":"    }"},
{"lineNum":"  101","line":""},
{"lineNum":"  102","line":"    inline fn smallKey(self: *Wyhash, input: []const u8) void {"},
{"lineNum":"  103","line":"        std.debug.assert(input.len <= 16);","class":"lineCov","hits":"1","order":"1013","possible_hits":"1",},
{"lineNum":"  104","line":""},
{"lineNum":"  105","line":"        if (input.len >= 4) {","class":"lineCov","hits":"1","order":"1014","possible_hits":"1",},
{"lineNum":"  106","line":"            const end = input.len - 4;","class":"linePartCov","hits":"1","order":"1300","possible_hits":"2",},
{"lineNum":"  107","line":"            const quarter = (input.len >> 3) << 2;","class":"lineCov","hits":"1","order":"1301","possible_hits":"1",},
{"lineNum":"  108","line":"            self.a = (read(4, input[0..]) << 32) | read(4, input[quarter..]);","class":"lineCov","hits":"5","order":"1302","possible_hits":"5",},
{"lineNum":"  109","line":"            self.b = (read(4, input[end..]) << 32) | read(4, input[end - quarter ..]);","class":"linePartCov","hits":"5","order":"1307","possible_hits":"6",},
{"lineNum":"  110","line":"        } else if (input.len > 0) {","class":"lineCov","hits":"1","order":"1015","possible_hits":"1",},
{"lineNum":"  111","line":"            self.a = (@as(u64, input[0]) << 16) | (@as(u64, input[input.len >> 1]) << 8) | input[input.len - 1];","class":"lineCov","hits":"3","order":"1016","possible_hits":"3",},
{"lineNum":"  112","line":"            self.b = 0;","class":"lineCov","hits":"1","order":"1017","possible_hits":"1",},
{"lineNum":"  113","line":"        } else {"},
{"lineNum":"  114","line":"            self.a = 0;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  115","line":"            self.b = 0;","class":"linePartCov","hits":"2","order":"1018","possible_hits":"3",},
{"lineNum":"  116","line":"        }"},
{"lineNum":"  117","line":"    }"},
{"lineNum":"  118","line":""},
{"lineNum":"  119","line":"    inline fn round(self: *Wyhash, input: *const [48]u8) void {"},
{"lineNum":"  120","line":"        inline for (0..3) |i| {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  121","line":"            const a = read(8, input[8 * (2 * i) ..]);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  122","line":"            const b = read(8, input[8 * (2 * i + 1) ..]);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  123","line":"            self.state[i] = mix(a ^ secret[i + 1], b ^ self.state[i]);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  124","line":"        }"},
{"lineNum":"  125","line":"    }"},
{"lineNum":"  126","line":""},
{"lineNum":"  127","line":"    inline fn read(comptime bytes: usize, data: []const u8) u64 {"},
{"lineNum":"  128","line":"        std.debug.assert(bytes <= 8);","class":"linePartCov","hits":"4","order":"1303","possible_hits":"14",},
{"lineNum":"  129","line":"        const T = std.meta.Int(.unsigned, 8 * bytes);"},
{"lineNum":"  130","line":"        return @as(u64, std.mem.readIntLittle(T, data[0..bytes]));","class":"linePartCov","hits":"11","order":"1304","possible_hits":"30",},
{"lineNum":"  131","line":"    }"},
{"lineNum":"  132","line":""},
{"lineNum":"  133","line":"    inline fn mum(a: *u64, b: *u64) void {"},
{"lineNum":"  134","line":"        const x = @as(u128, a.*) *% b.*;","class":"linePartCov","hits":"3","order":"1004","possible_hits":"7",},
{"lineNum":"  135","line":"        a.* = @as(u64, @truncate(x));","class":"linePartCov","hits":"3","order":"1005","possible_hits":"7",},
{"lineNum":"  136","line":"        b.* = @as(u64, @truncate(x >> 64));","class":"linePartCov","hits":"3","order":"1006","possible_hits":"7",},
{"lineNum":"  137","line":"    }"},
{"lineNum":"  138","line":""},
{"lineNum":"  139","line":"    inline fn mix(a_: u64, b_: u64) u64 {"},
{"lineNum":"  140","line":"        var a = a_;","class":"linePartCov","hits":"2","order":"1001","possible_hits":"6",},
{"lineNum":"  141","line":"        var b = b_;","class":"linePartCov","hits":"2","order":"1002","possible_hits":"6",},
{"lineNum":"  142","line":"        mum(&a, &b);","class":"linePartCov","hits":"2","order":"1003","possible_hits":"6",},
{"lineNum":"  143","line":"        return a ^ b;","class":"linePartCov","hits":"2","order":"1007","possible_hits":"6",},
{"lineNum":"  144","line":"    }"},
{"lineNum":"  145","line":""},
{"lineNum":"  146","line":"    inline fn final0(self: *Wyhash) void {"},
{"lineNum":"  147","line":"        self.state[0] ^= self.state[1] ^ self.state[2];","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  148","line":"    }"},
{"lineNum":"  149","line":""},
{"lineNum":"  150","line":"    // input_lb must be at least 16-bytes long (in shorter key cases the smallKey function will be"},
{"lineNum":"  151","line":"    // used instead). We use an index into a slice to for comptime processing as opposed to if we"},
{"lineNum":"  152","line":"    // used pointers."},
{"lineNum":"  153","line":"    inline fn final1(self: *Wyhash, input_lb: []const u8, start_pos: usize) void {"},
{"lineNum":"  154","line":"        std.debug.assert(input_lb.len >= 16);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  155","line":"        std.debug.assert(input_lb.len - start_pos <= 48);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  156","line":"        const input = input_lb[start_pos..];","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  157","line":""},
{"lineNum":"  158","line":"        var i: usize = 0;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  159","line":"        while (i + 16 < input.len) : (i += 16) {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  160","line":"            self.state[0] = mix(read(8, input[i..]) ^ secret[1], read(8, input[i + 8 ..]) ^ self.state[0]);","class":"lineNoCov","hits":"0","possible_hits":"7",},
{"lineNum":"  161","line":"        }"},
{"lineNum":"  162","line":""},
{"lineNum":"  163","line":"        self.a = read(8, input_lb[input_lb.len - 16 ..][0..8]);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  164","line":"        self.b = read(8, input_lb[input_lb.len - 8 ..][0..8]);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  165","line":"    }"},
{"lineNum":"  166","line":""},
{"lineNum":"  167","line":"    inline fn final2(self: *Wyhash) u64 {"},
{"lineNum":"  168","line":"        self.a ^= secret[1];","class":"lineCov","hits":"1","order":"1021","possible_hits":"1",},
{"lineNum":"  169","line":"        self.b ^= self.state[0];","class":"lineCov","hits":"1","order":"1022","possible_hits":"1",},
{"lineNum":"  170","line":"        mum(&self.a, &self.b);","class":"lineCov","hits":"1","order":"1023","possible_hits":"1",},
{"lineNum":"  171","line":"        return mix(self.a ^ secret[0] ^ self.total_len, self.b ^ secret[1]);","class":"lineCov","hits":"1","order":"1024","possible_hits":"1",},
{"lineNum":"  172","line":"    }"},
{"lineNum":"  173","line":""},
{"lineNum":"  174","line":"    pub fn hash(seed: u64, input: []const u8) u64 {","class":"lineCov","hits":"1","order":"996","possible_hits":"1",},
{"lineNum":"  175","line":"        var self = Wyhash.init(seed);","class":"lineCov","hits":"1","order":"997","possible_hits":"1",},
{"lineNum":"  176","line":""},
{"lineNum":"  177","line":"        if (input.len <= 16) {","class":"lineCov","hits":"1","order":"1011","possible_hits":"1",},
{"lineNum":"  178","line":"            self.smallKey(input);","class":"lineCov","hits":"1","order":"1012","possible_hits":"1",},
{"lineNum":"  179","line":"        } else {"},
{"lineNum":"  180","line":"            var i: usize = 0;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  181","line":"            if (input.len >= 48) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  182","line":"                while (i + 48 < input.len) : (i += 48) {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  183","line":"                    self.round(input[i..][0..48]);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  184","line":"                }"},
{"lineNum":"  185","line":"                self.final0();","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  186","line":"            }"},
{"lineNum":"  187","line":"            self.final1(input, i);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  188","line":"        }"},
{"lineNum":"  189","line":""},
{"lineNum":"  190","line":"        self.total_len = input.len;","class":"lineCov","hits":"1","order":"1019","possible_hits":"1",},
{"lineNum":"  191","line":"        return self.final2();","class":"lineCov","hits":"2","order":"1020","possible_hits":"2",},
{"lineNum":"  192","line":"    }"},
{"lineNum":"  193","line":"};"},
{"lineNum":"  194","line":""},
{"lineNum":"  195","line":"const expectEqual = std.testing.expectEqual;"},
{"lineNum":"  196","line":""},
{"lineNum":"  197","line":"const TestVector = struct {"},
{"lineNum":"  198","line":"    expected: u64,"},
{"lineNum":"  199","line":"    seed: u64,"},
{"lineNum":"  200","line":"    input: []const u8,"},
{"lineNum":"  201","line":"};"},
{"lineNum":"  202","line":""},
{"lineNum":"  203","line":"// Run https://github.com/wangyi-fudan/wyhash/blob/77e50f267fbc7b8e2d09f2d455219adb70ad4749/test_vector.cpp directly."},
{"lineNum":"  204","line":"const vectors = [_]TestVector{"},
{"lineNum":"  205","line":"    .{ .seed = 0, .expected = 0x409638ee2bde459, .input = \"\" },"},
{"lineNum":"  206","line":"    .{ .seed = 1, .expected = 0xa8412d091b5fe0a9, .input = \"a\" },"},
{"lineNum":"  207","line":"    .{ .seed = 2, .expected = 0x32dd92e4b2915153, .input = \"abc\" },"},
{"lineNum":"  208","line":"    .{ .seed = 3, .expected = 0x8619124089a3a16b, .input = \"message digest\" },"},
{"lineNum":"  209","line":"    .{ .seed = 4, .expected = 0x7a43afb61d7f5f40, .input = \"abcdefghijklmnopqrstuvwxyz\" },"},
{"lineNum":"  210","line":"    .{ .seed = 5, .expected = 0xff42329b90e50d58, .input = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\" },"},
{"lineNum":"  211","line":"    .{ .seed = 6, .expected = 0xc39cab13b115aad3, .input = \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\" },"},
{"lineNum":"  212","line":"};"},
{"lineNum":"  213","line":""},
{"lineNum":"  214","line":"test \"test vectors\" {"},
{"lineNum":"  215","line":"    for (vectors) |e| {"},
{"lineNum":"  216","line":"        try expectEqual(e.expected, Wyhash.hash(e.seed, e.input));"},
{"lineNum":"  217","line":"    }"},
{"lineNum":"  218","line":"}"},
{"lineNum":"  219","line":""},
{"lineNum":"  220","line":"test \"test vectors at comptime\" {"},
{"lineNum":"  221","line":"    comptime {"},
{"lineNum":"  222","line":"        inline for (vectors) |e| {"},
{"lineNum":"  223","line":"            try expectEqual(e.expected, Wyhash.hash(e.seed, e.input));"},
{"lineNum":"  224","line":"        }"},
{"lineNum":"  225","line":"    }"},
{"lineNum":"  226","line":"}"},
{"lineNum":"  227","line":""},
{"lineNum":"  228","line":"test \"test vectors streaming\" {"},
{"lineNum":"  229","line":"    const step = 5;"},
{"lineNum":"  230","line":""},
{"lineNum":"  231","line":"    for (vectors) |e| {"},
{"lineNum":"  232","line":"        var wh = Wyhash.init(e.seed);"},
{"lineNum":"  233","line":"        var i: usize = 0;"},
{"lineNum":"  234","line":"        while (i < e.input.len) : (i += step) {"},
{"lineNum":"  235","line":"            const len = if (i + step > e.input.len) e.input.len - i else step;"},
{"lineNum":"  236","line":"            wh.update(e.input[i..][0..len]);"},
{"lineNum":"  237","line":"        }"},
{"lineNum":"  238","line":"        try expectEqual(e.expected, wh.final());"},
{"lineNum":"  239","line":"    }"},
{"lineNum":"  240","line":"}"},
{"lineNum":"  241","line":""},
{"lineNum":"  242","line":"test \"test ensure idempotent final call\" {"},
{"lineNum":"  243","line":"    const e: TestVector = .{ .seed = 6, .expected = 0xc39cab13b115aad3, .input = \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\" };"},
{"lineNum":"  244","line":"    var wh = Wyhash.init(e.seed);"},
{"lineNum":"  245","line":"    wh.update(e.input);"},
{"lineNum":"  246","line":""},
{"lineNum":"  247","line":"    for (0..10) |_| {"},
{"lineNum":"  248","line":"        try expectEqual(e.expected, wh.final());"},
{"lineNum":"  249","line":"    }"},
{"lineNum":"  250","line":"}"},
{"lineNum":"  251","line":""},
{"lineNum":"  252","line":"test \"iterative non-divisible update\" {"},
{"lineNum":"  253","line":"    var buf: [8192]u8 = undefined;"},
{"lineNum":"  254","line":"    for (&buf, 0..) |*e, i| {"},
{"lineNum":"  255","line":"        e.* = @as(u8, @truncate(i));"},
{"lineNum":"  256","line":"    }"},
{"lineNum":"  257","line":""},
{"lineNum":"  258","line":"    const seed = 0x128dad08f;"},
{"lineNum":"  259","line":""},
{"lineNum":"  260","line":"    var end: usize = 32;"},
{"lineNum":"  261","line":"    while (end < buf.len) : (end += 32) {"},
{"lineNum":"  262","line":"        const non_iterative_hash = Wyhash.hash(seed, buf[0..end]);"},
{"lineNum":"  263","line":""},
{"lineNum":"  264","line":"        var wy = Wyhash.init(seed);"},
{"lineNum":"  265","line":"        var i: usize = 0;"},
{"lineNum":"  266","line":"        while (i < end) : (i += 33) {"},
{"lineNum":"  267","line":"            wy.update(buf[i..@min(i + 33, end)]);"},
{"lineNum":"  268","line":"        }"},
{"lineNum":"  269","line":"        const iterative_hash = wy.final();"},
{"lineNum":"  270","line":""},
{"lineNum":"  271","line":"        try std.testing.expectEqual(iterative_hash, non_iterative_hash);"},
{"lineNum":"  272","line":"    }"},
{"lineNum":"  273","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test", "date" : "2024-04-26 16:14:49", "instrumented" : 55, "covered" : 35,};
var merged_data = [];
