var data = {lines:[
{"lineNum":"    1","line":"const builtin = @import(\"builtin\");"},
{"lineNum":"    2","line":"const std = @import(\"std\");"},
{"lineNum":"    3","line":"const testing = std.testing;"},
{"lineNum":"    4","line":""},
{"lineNum":"    5","line":"/// Read a single unsigned LEB128 value from the given reader as type T,"},
{"lineNum":"    6","line":"/// or error.Overflow if the value cannot fit."},
{"lineNum":"    7","line":"pub fn readULEB128(comptime T: type, reader: anytype) !T {","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"    8","line":"    const U = if (@typeInfo(T).Int.bits < 8) u8 else T;"},
{"lineNum":"    9","line":"    const ShiftT = std.math.Log2Int(U);"},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"    const max_group = (@typeInfo(U).Int.bits + 6) / 7;","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"   12","line":""},
{"lineNum":"   13","line":"    var value: U = 0;","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"   14","line":"    var group: ShiftT = 0;","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"    while (group < max_group) : (group += 1) {","class":"lineNoCov","hits":"0","possible_hits":"15",},
{"lineNum":"   17","line":"        const byte = try reader.readByte();","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"        const ov = @shlWithOverflow(@as(U, byte & 0x7f), group * 7);","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"   20","line":"        if (ov[1] != 0) return error.Overflow;","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"   21","line":""},
{"lineNum":"   22","line":"        value |= ov[0];","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"   23","line":"        if (byte & 0x80 == 0) break;","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"   24","line":"    } else {"},
{"lineNum":"   25","line":"        return error.Overflow;","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"   26","line":"    }"},
{"lineNum":"   27","line":""},
{"lineNum":"   28","line":"    // only applies in the case that we extended to u8"},
{"lineNum":"   29","line":"    if (U != T) {"},
{"lineNum":"   30","line":"        if (value > std.math.maxInt(T)) return error.Overflow;"},
{"lineNum":"   31","line":"    }"},
{"lineNum":"   32","line":""},
{"lineNum":"   33","line":"    return @as(T, @truncate(value));","class":"lineNoCov","hits":"0","possible_hits":"5",},
{"lineNum":"   34","line":"}"},
{"lineNum":"   35","line":""},
{"lineNum":"   36","line":"/// Write a single unsigned integer as unsigned LEB128 to the given writer."},
{"lineNum":"   37","line":"pub fn writeULEB128(writer: anytype, uint_value: anytype) !void {"},
{"lineNum":"   38","line":"    const T = @TypeOf(uint_value);"},
{"lineNum":"   39","line":"    const U = if (@typeInfo(T).Int.bits < 8) u8 else T;"},
{"lineNum":"   40","line":"    var value: U = @intCast(uint_value);"},
{"lineNum":"   41","line":""},
{"lineNum":"   42","line":"    while (true) {"},
{"lineNum":"   43","line":"        const byte: u8 = @truncate(value & 0x7f);"},
{"lineNum":"   44","line":"        value >>= 7;"},
{"lineNum":"   45","line":"        if (value == 0) {"},
{"lineNum":"   46","line":"            try writer.writeByte(byte);"},
{"lineNum":"   47","line":"            break;"},
{"lineNum":"   48","line":"        } else {"},
{"lineNum":"   49","line":"            try writer.writeByte(byte | 0x80);"},
{"lineNum":"   50","line":"        }"},
{"lineNum":"   51","line":"    }"},
{"lineNum":"   52","line":"}"},
{"lineNum":"   53","line":""},
{"lineNum":"   54","line":"/// Read a single signed LEB128 value from the given reader as type T,"},
{"lineNum":"   55","line":"/// or error.Overflow if the value cannot fit."},
{"lineNum":"   56","line":"pub fn readILEB128(comptime T: type, reader: anytype) !T {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   57","line":"    const S = if (@typeInfo(T).Int.bits < 8) i8 else T;"},
{"lineNum":"   58","line":"    const U = std.meta.Int(.unsigned, @typeInfo(S).Int.bits);"},
{"lineNum":"   59","line":"    const ShiftU = std.math.Log2Int(U);"},
{"lineNum":"   60","line":""},
{"lineNum":"   61","line":"    const max_group = (@typeInfo(U).Int.bits + 6) / 7;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   62","line":""},
{"lineNum":"   63","line":"    var value = @as(U, 0);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   64","line":"    var group = @as(ShiftU, 0);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   65","line":""},
{"lineNum":"   66","line":"    while (group < max_group) : (group += 1) {","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"   67","line":"        const byte = try reader.readByte();","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"   68","line":""},
{"lineNum":"   69","line":"        const shift = group * 7;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   70","line":"        const ov = @shlWithOverflow(@as(U, byte & 0x7f), shift);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   71","line":"        if (ov[1] != 0) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   72","line":"            // Overflow is ok so long as the sign bit is set and this is the last byte"},
{"lineNum":"   73","line":"            if (byte & 0x80 != 0) return error.Overflow;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"   74","line":"            if (@as(S, @bitCast(ov[0])) >= 0) return error.Overflow;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"   75","line":""},
{"lineNum":"   76","line":"            // and all the overflowed bits are 1"},
{"lineNum":"   77","line":"            const remaining_shift = @as(u3, @intCast(@typeInfo(U).Int.bits - @as(u16, shift)));","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"   78","line":"            const remaining_bits = @as(i8, @bitCast(byte | 0x80)) >> remaining_shift;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   79","line":"            if (remaining_bits != -1) return error.Overflow;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"   80","line":"        } else {"},
{"lineNum":"   81","line":"            // If we don\'t overflow and this is the last byte and the number being decoded"},
{"lineNum":"   82","line":"            // is negative, check that the remaining bits are 1"},
{"lineNum":"   83","line":"            if ((byte & 0x80 == 0) and (@as(S, @bitCast(ov[0])) < 0)) {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"   84","line":"                const remaining_shift = @as(u3, @intCast(@typeInfo(U).Int.bits - @as(u16, shift)));","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"   85","line":"                const remaining_bits = @as(i8, @bitCast(byte | 0x80)) >> remaining_shift;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   86","line":"                if (remaining_bits != -1) return error.Overflow;","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"   87","line":"            }"},
{"lineNum":"   88","line":"        }"},
{"lineNum":"   89","line":""},
{"lineNum":"   90","line":"        value |= ov[0];","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   91","line":"        if (byte & 0x80 == 0) {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   92","line":"            const needs_sign_ext = group + 1 < max_group;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"   93","line":"            if (byte & 0x40 != 0 and needs_sign_ext) {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"   94","line":"                const ones = @as(S, -1);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   95","line":"                value |= @as(U, @bitCast(ones)) << (shift + 7);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   96","line":"            }"},
{"lineNum":"   97","line":"            break;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"   98","line":"        }"},
{"lineNum":"   99","line":"    } else {"},
{"lineNum":"  100","line":"        return error.Overflow;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  101","line":"    }"},
{"lineNum":"  102","line":""},
{"lineNum":"  103","line":"    const result = @as(S, @bitCast(value));","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  104","line":"    // Only applies if we extended to i8"},
{"lineNum":"  105","line":"    if (S != T) {"},
{"lineNum":"  106","line":"        if (result > std.math.maxInt(T) or result < std.math.minInt(T)) return error.Overflow;"},
{"lineNum":"  107","line":"    }"},
{"lineNum":"  108","line":""},
{"lineNum":"  109","line":"    return @as(T, @truncate(result));","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  110","line":"}"},
{"lineNum":"  111","line":""},
{"lineNum":"  112","line":"/// Write a single signed integer as signed LEB128 to the given writer."},
{"lineNum":"  113","line":"pub fn writeILEB128(writer: anytype, int_value: anytype) !void {"},
{"lineNum":"  114","line":"    const T = @TypeOf(int_value);"},
{"lineNum":"  115","line":"    const S = if (@typeInfo(T).Int.bits < 8) i8 else T;"},
{"lineNum":"  116","line":"    const U = std.meta.Int(.unsigned, @typeInfo(S).Int.bits);"},
{"lineNum":"  117","line":""},
{"lineNum":"  118","line":"    var value: S = @intCast(int_value);"},
{"lineNum":"  119","line":""},
{"lineNum":"  120","line":"    while (true) {"},
{"lineNum":"  121","line":"        const uvalue: U = @bitCast(value);"},
{"lineNum":"  122","line":"        const byte: u8 = @truncate(uvalue);"},
{"lineNum":"  123","line":"        value >>= 6;"},
{"lineNum":"  124","line":"        if (value == -1 or value == 0) {"},
{"lineNum":"  125","line":"            try writer.writeByte(byte & 0x7F);"},
{"lineNum":"  126","line":"            break;"},
{"lineNum":"  127","line":"        } else {"},
{"lineNum":"  128","line":"            value >>= 1;"},
{"lineNum":"  129","line":"            try writer.writeByte(byte | 0x80);"},
{"lineNum":"  130","line":"        }"},
{"lineNum":"  131","line":"    }"},
{"lineNum":"  132","line":"}"},
{"lineNum":"  133","line":""},
{"lineNum":"  134","line":"/// This is an \"advanced\" function. It allows one to use a fixed amount of memory to store a"},
{"lineNum":"  135","line":"/// ULEB128. This defeats the entire purpose of using this data encoding; it will no longer use"},
{"lineNum":"  136","line":"/// fewer bytes to store smaller numbers. The advantage of using a fixed width is that it makes"},
{"lineNum":"  137","line":"/// fields have a predictable size and so depending on the use case this tradeoff can be worthwhile."},
{"lineNum":"  138","line":"/// An example use case of this is in emitting DWARF info where one wants to make a ULEB128 field"},
{"lineNum":"  139","line":"/// \"relocatable\", meaning that it becomes possible to later go back and patch the number to be a"},
{"lineNum":"  140","line":"/// different value without shifting all the following code."},
{"lineNum":"  141","line":"pub fn writeUnsignedFixed(comptime l: usize, ptr: *[l]u8, int: std.meta.Int(.unsigned, l * 7)) void {"},
{"lineNum":"  142","line":"    const T = @TypeOf(int);"},
{"lineNum":"  143","line":"    const U = if (@typeInfo(T).Int.bits < 8) u8 else T;"},
{"lineNum":"  144","line":"    var value: U = @intCast(int);"},
{"lineNum":"  145","line":""},
{"lineNum":"  146","line":"    comptime var i = 0;"},
{"lineNum":"  147","line":"    inline while (i < (l - 1)) : (i += 1) {"},
{"lineNum":"  148","line":"        const byte = @as(u8, @truncate(value)) | 0b1000_0000;"},
{"lineNum":"  149","line":"        value >>= 7;"},
{"lineNum":"  150","line":"        ptr[i] = byte;"},
{"lineNum":"  151","line":"    }"},
{"lineNum":"  152","line":"    ptr[i] = @as(u8, @truncate(value));"},
{"lineNum":"  153","line":"}"},
{"lineNum":"  154","line":""},
{"lineNum":"  155","line":"test \"writeUnsignedFixed\" {"},
{"lineNum":"  156","line":"    {"},
{"lineNum":"  157","line":"        var buf: [4]u8 = undefined;"},
{"lineNum":"  158","line":"        writeUnsignedFixed(4, &buf, 0);"},
{"lineNum":"  159","line":"        try testing.expect((try test_read_uleb128(u64, &buf)) == 0);"},
{"lineNum":"  160","line":"    }"},
{"lineNum":"  161","line":"    {"},
{"lineNum":"  162","line":"        var buf: [4]u8 = undefined;"},
{"lineNum":"  163","line":"        writeUnsignedFixed(4, &buf, 1);"},
{"lineNum":"  164","line":"        try testing.expect((try test_read_uleb128(u64, &buf)) == 1);"},
{"lineNum":"  165","line":"    }"},
{"lineNum":"  166","line":"    {"},
{"lineNum":"  167","line":"        var buf: [4]u8 = undefined;"},
{"lineNum":"  168","line":"        writeUnsignedFixed(4, &buf, 1000);"},
{"lineNum":"  169","line":"        try testing.expect((try test_read_uleb128(u64, &buf)) == 1000);"},
{"lineNum":"  170","line":"    }"},
{"lineNum":"  171","line":"    {"},
{"lineNum":"  172","line":"        var buf: [4]u8 = undefined;"},
{"lineNum":"  173","line":"        writeUnsignedFixed(4, &buf, 10000000);"},
{"lineNum":"  174","line":"        try testing.expect((try test_read_uleb128(u64, &buf)) == 10000000);"},
{"lineNum":"  175","line":"    }"},
{"lineNum":"  176","line":"}"},
{"lineNum":"  177","line":""},
{"lineNum":"  178","line":"// tests"},
{"lineNum":"  179","line":"fn test_read_stream_ileb128(comptime T: type, encoded: []const u8) !T {"},
{"lineNum":"  180","line":"    var reader = std.io.fixedBufferStream(encoded);"},
{"lineNum":"  181","line":"    return try readILEB128(T, reader.reader());"},
{"lineNum":"  182","line":"}"},
{"lineNum":"  183","line":""},
{"lineNum":"  184","line":"fn test_read_stream_uleb128(comptime T: type, encoded: []const u8) !T {"},
{"lineNum":"  185","line":"    var reader = std.io.fixedBufferStream(encoded);"},
{"lineNum":"  186","line":"    return try readULEB128(T, reader.reader());"},
{"lineNum":"  187","line":"}"},
{"lineNum":"  188","line":""},
{"lineNum":"  189","line":"fn test_read_ileb128(comptime T: type, encoded: []const u8) !T {"},
{"lineNum":"  190","line":"    var reader = std.io.fixedBufferStream(encoded);"},
{"lineNum":"  191","line":"    const v1 = try readILEB128(T, reader.reader());"},
{"lineNum":"  192","line":"    return v1;"},
{"lineNum":"  193","line":"}"},
{"lineNum":"  194","line":""},
{"lineNum":"  195","line":"fn test_read_uleb128(comptime T: type, encoded: []const u8) !T {"},
{"lineNum":"  196","line":"    var reader = std.io.fixedBufferStream(encoded);"},
{"lineNum":"  197","line":"    const v1 = try readULEB128(T, reader.reader());"},
{"lineNum":"  198","line":"    return v1;"},
{"lineNum":"  199","line":"}"},
{"lineNum":"  200","line":""},
{"lineNum":"  201","line":"fn test_read_ileb128_seq(comptime T: type, comptime N: usize, encoded: []const u8) !void {"},
{"lineNum":"  202","line":"    var reader = std.io.fixedBufferStream(encoded);"},
{"lineNum":"  203","line":"    var i: usize = 0;"},
{"lineNum":"  204","line":"    while (i < N) : (i += 1) {"},
{"lineNum":"  205","line":"        _ = try readILEB128(T, reader.reader());"},
{"lineNum":"  206","line":"    }"},
{"lineNum":"  207","line":"}"},
{"lineNum":"  208","line":""},
{"lineNum":"  209","line":"fn test_read_uleb128_seq(comptime T: type, comptime N: usize, encoded: []const u8) !void {"},
{"lineNum":"  210","line":"    var reader = std.io.fixedBufferStream(encoded);"},
{"lineNum":"  211","line":"    var i: usize = 0;"},
{"lineNum":"  212","line":"    while (i < N) : (i += 1) {"},
{"lineNum":"  213","line":"        _ = try readULEB128(T, reader.reader());"},
{"lineNum":"  214","line":"    }"},
{"lineNum":"  215","line":"}"},
{"lineNum":"  216","line":""},
{"lineNum":"  217","line":"test \"deserialize signed LEB128\" {"},
{"lineNum":"  218","line":"    // Truncated"},
{"lineNum":"  219","line":"    try testing.expectError(error.EndOfStream, test_read_stream_ileb128(i64, \"\\x80\"));"},
{"lineNum":"  220","line":""},
{"lineNum":"  221","line":"    // Overflow"},
{"lineNum":"  222","line":"    try testing.expectError(error.Overflow, test_read_ileb128(i8, \"\\x80\\x80\\x40\"));"},
{"lineNum":"  223","line":"    try testing.expectError(error.Overflow, test_read_ileb128(i16, \"\\x80\\x80\\x80\\x40\"));"},
{"lineNum":"  224","line":"    try testing.expectError(error.Overflow, test_read_ileb128(i32, \"\\x80\\x80\\x80\\x80\\x40\"));"},
{"lineNum":"  225","line":"    try testing.expectError(error.Overflow, test_read_ileb128(i64, \"\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x40\"));"},
{"lineNum":"  226","line":"    try testing.expectError(error.Overflow, test_read_ileb128(i8, \"\\xff\\x7e\"));"},
{"lineNum":"  227","line":"    try testing.expectError(error.Overflow, test_read_ileb128(i32, \"\\x80\\x80\\x80\\x80\\x08\"));"},
{"lineNum":"  228","line":"    try testing.expectError(error.Overflow, test_read_ileb128(i64, \"\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x01\"));"},
{"lineNum":"  229","line":""},
{"lineNum":"  230","line":"    // Decode SLEB128"},
{"lineNum":"  231","line":"    try testing.expect((try test_read_ileb128(i64, \"\\x00\")) == 0);"},
{"lineNum":"  232","line":"    try testing.expect((try test_read_ileb128(i64, \"\\x01\")) == 1);"},
{"lineNum":"  233","line":"    try testing.expect((try test_read_ileb128(i64, \"\\x3f\")) == 63);"},
{"lineNum":"  234","line":"    try testing.expect((try test_read_ileb128(i64, \"\\x40\")) == -64);"},
{"lineNum":"  235","line":"    try testing.expect((try test_read_ileb128(i64, \"\\x41\")) == -63);"},
{"lineNum":"  236","line":"    try testing.expect((try test_read_ileb128(i64, \"\\x7f\")) == -1);"},
{"lineNum":"  237","line":"    try testing.expect((try test_read_ileb128(i64, \"\\x80\\x01\")) == 128);"},
{"lineNum":"  238","line":"    try testing.expect((try test_read_ileb128(i64, \"\\x81\\x01\")) == 129);"},
{"lineNum":"  239","line":"    try testing.expect((try test_read_ileb128(i64, \"\\xff\\x7e\")) == -129);"},
{"lineNum":"  240","line":"    try testing.expect((try test_read_ileb128(i64, \"\\x80\\x7f\")) == -128);"},
{"lineNum":"  241","line":"    try testing.expect((try test_read_ileb128(i64, \"\\x81\\x7f\")) == -127);"},
{"lineNum":"  242","line":"    try testing.expect((try test_read_ileb128(i64, \"\\xc0\\x00\")) == 64);"},
{"lineNum":"  243","line":"    try testing.expect((try test_read_ileb128(i64, \"\\xc7\\x9f\\x7f\")) == -12345);"},
{"lineNum":"  244","line":"    try testing.expect((try test_read_ileb128(i8, \"\\xff\\x7f\")) == -1);"},
{"lineNum":"  245","line":"    try testing.expect((try test_read_ileb128(i16, \"\\xff\\xff\\x7f\")) == -1);"},
{"lineNum":"  246","line":"    try testing.expect((try test_read_ileb128(i32, \"\\xff\\xff\\xff\\xff\\x7f\")) == -1);"},
{"lineNum":"  247","line":"    try testing.expect((try test_read_ileb128(i32, \"\\x80\\x80\\x80\\x80\\x78\")) == -0x80000000);"},
{"lineNum":"  248","line":"    try testing.expect((try test_read_ileb128(i64, \"\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x7f\")) == @as(i64, @bitCast(@as(u64, @intCast(0x8000000000000000)))));"},
{"lineNum":"  249","line":"    try testing.expect((try test_read_ileb128(i64, \"\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x40\")) == -0x4000000000000000);"},
{"lineNum":"  250","line":"    try testing.expect((try test_read_ileb128(i64, \"\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x7f\")) == -0x8000000000000000);"},
{"lineNum":"  251","line":""},
{"lineNum":"  252","line":"    // Decode unnormalized SLEB128 with extra padding bytes."},
{"lineNum":"  253","line":"    try testing.expect((try test_read_ileb128(i64, \"\\x80\\x00\")) == 0);"},
{"lineNum":"  254","line":"    try testing.expect((try test_read_ileb128(i64, \"\\x80\\x80\\x00\")) == 0);"},
{"lineNum":"  255","line":"    try testing.expect((try test_read_ileb128(i64, \"\\xff\\x00\")) == 0x7f);"},
{"lineNum":"  256","line":"    try testing.expect((try test_read_ileb128(i64, \"\\xff\\x80\\x00\")) == 0x7f);"},
{"lineNum":"  257","line":"    try testing.expect((try test_read_ileb128(i64, \"\\x80\\x81\\x00\")) == 0x80);"},
{"lineNum":"  258","line":"    try testing.expect((try test_read_ileb128(i64, \"\\x80\\x81\\x80\\x00\")) == 0x80);"},
{"lineNum":"  259","line":""},
{"lineNum":"  260","line":"    // Decode sequence of SLEB128 values"},
{"lineNum":"  261","line":"    try test_read_ileb128_seq(i64, 4, \"\\x81\\x01\\x3f\\x80\\x7f\\x80\\x80\\x80\\x00\");"},
{"lineNum":"  262","line":"}"},
{"lineNum":"  263","line":""},
{"lineNum":"  264","line":"test \"deserialize unsigned LEB128\" {"},
{"lineNum":"  265","line":"    // Truncated"},
{"lineNum":"  266","line":"    try testing.expectError(error.EndOfStream, test_read_stream_uleb128(u64, \"\\x80\"));"},
{"lineNum":"  267","line":""},
{"lineNum":"  268","line":"    // Overflow"},
{"lineNum":"  269","line":"    try testing.expectError(error.Overflow, test_read_uleb128(u8, \"\\x80\\x02\"));"},
{"lineNum":"  270","line":"    try testing.expectError(error.Overflow, test_read_uleb128(u8, \"\\x80\\x80\\x40\"));"},
{"lineNum":"  271","line":"    try testing.expectError(error.Overflow, test_read_uleb128(u16, \"\\x80\\x80\\x84\"));"},
{"lineNum":"  272","line":"    try testing.expectError(error.Overflow, test_read_uleb128(u16, \"\\x80\\x80\\x80\\x40\"));"},
{"lineNum":"  273","line":"    try testing.expectError(error.Overflow, test_read_uleb128(u32, \"\\x80\\x80\\x80\\x80\\x90\"));"},
{"lineNum":"  274","line":"    try testing.expectError(error.Overflow, test_read_uleb128(u32, \"\\x80\\x80\\x80\\x80\\x40\"));"},
{"lineNum":"  275","line":"    try testing.expectError(error.Overflow, test_read_uleb128(u64, \"\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x40\"));"},
{"lineNum":"  276","line":""},
{"lineNum":"  277","line":"    // Decode ULEB128"},
{"lineNum":"  278","line":"    try testing.expect((try test_read_uleb128(u64, \"\\x00\")) == 0);"},
{"lineNum":"  279","line":"    try testing.expect((try test_read_uleb128(u64, \"\\x01\")) == 1);"},
{"lineNum":"  280","line":"    try testing.expect((try test_read_uleb128(u64, \"\\x3f\")) == 63);"},
{"lineNum":"  281","line":"    try testing.expect((try test_read_uleb128(u64, \"\\x40\")) == 64);"},
{"lineNum":"  282","line":"    try testing.expect((try test_read_uleb128(u64, \"\\x7f\")) == 0x7f);"},
{"lineNum":"  283","line":"    try testing.expect((try test_read_uleb128(u64, \"\\x80\\x01\")) == 0x80);"},
{"lineNum":"  284","line":"    try testing.expect((try test_read_uleb128(u64, \"\\x81\\x01\")) == 0x81);"},
{"lineNum":"  285","line":"    try testing.expect((try test_read_uleb128(u64, \"\\x90\\x01\")) == 0x90);"},
{"lineNum":"  286","line":"    try testing.expect((try test_read_uleb128(u64, \"\\xff\\x01\")) == 0xff);"},
{"lineNum":"  287","line":"    try testing.expect((try test_read_uleb128(u64, \"\\x80\\x02\")) == 0x100);"},
{"lineNum":"  288","line":"    try testing.expect((try test_read_uleb128(u64, \"\\x81\\x02\")) == 0x101);"},
{"lineNum":"  289","line":"    try testing.expect((try test_read_uleb128(u64, \"\\x80\\xc1\\x80\\x80\\x10\")) == 4294975616);"},
{"lineNum":"  290","line":"    try testing.expect((try test_read_uleb128(u64, \"\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x80\\x01\")) == 0x8000000000000000);"},
{"lineNum":"  291","line":""},
{"lineNum":"  292","line":"    // Decode ULEB128 with extra padding bytes"},
{"lineNum":"  293","line":"    try testing.expect((try test_read_uleb128(u64, \"\\x80\\x00\")) == 0);"},
{"lineNum":"  294","line":"    try testing.expect((try test_read_uleb128(u64, \"\\x80\\x80\\x00\")) == 0);"},
{"lineNum":"  295","line":"    try testing.expect((try test_read_uleb128(u64, \"\\xff\\x00\")) == 0x7f);"},
{"lineNum":"  296","line":"    try testing.expect((try test_read_uleb128(u64, \"\\xff\\x80\\x00\")) == 0x7f);"},
{"lineNum":"  297","line":"    try testing.expect((try test_read_uleb128(u64, \"\\x80\\x81\\x00\")) == 0x80);"},
{"lineNum":"  298","line":"    try testing.expect((try test_read_uleb128(u64, \"\\x80\\x81\\x80\\x00\")) == 0x80);"},
{"lineNum":"  299","line":""},
{"lineNum":"  300","line":"    // Decode sequence of ULEB128 values"},
{"lineNum":"  301","line":"    try test_read_uleb128_seq(u64, 4, \"\\x81\\x01\\x3f\\x80\\x7f\\x80\\x80\\x80\\x00\");"},
{"lineNum":"  302","line":"}"},
{"lineNum":"  303","line":""},
{"lineNum":"  304","line":"fn test_write_leb128(value: anytype) !void {"},
{"lineNum":"  305","line":"    const T = @TypeOf(value);"},
{"lineNum":"  306","line":"    const signedness = @typeInfo(T).Int.signedness;"},
{"lineNum":"  307","line":"    const t_signed = signedness == .signed;"},
{"lineNum":"  308","line":""},
{"lineNum":"  309","line":"    const writeStream = if (t_signed) writeILEB128 else writeULEB128;"},
{"lineNum":"  310","line":"    const readStream = if (t_signed) readILEB128 else readULEB128;"},
{"lineNum":"  311","line":""},
{"lineNum":"  312","line":"    // decode to a larger bit size too, to ensure sign extension"},
{"lineNum":"  313","line":"    // is working as expected"},
{"lineNum":"  314","line":"    const larger_type_bits = ((@typeInfo(T).Int.bits + 8) / 8) * 8;"},
{"lineNum":"  315","line":"    const B = std.meta.Int(signedness, larger_type_bits);"},
{"lineNum":"  316","line":""},
{"lineNum":"  317","line":"    const bytes_needed = bn: {"},
{"lineNum":"  318","line":"        if (@typeInfo(T).Int.bits <= 7) break :bn @as(u16, 1);"},
{"lineNum":"  319","line":""},
{"lineNum":"  320","line":"        const unused_bits = if (value < 0) @clz(~value) else @clz(value);"},
{"lineNum":"  321","line":"        const used_bits: u16 = (@typeInfo(T).Int.bits - unused_bits) + @intFromBool(t_signed);"},
{"lineNum":"  322","line":"        if (used_bits <= 7) break :bn @as(u16, 1);"},
{"lineNum":"  323","line":"        break :bn ((used_bits + 6) / 7);"},
{"lineNum":"  324","line":"    };"},
{"lineNum":"  325","line":""},
{"lineNum":"  326","line":"    const max_groups = if (@typeInfo(T).Int.bits == 0) 1 else (@typeInfo(T).Int.bits + 6) / 7;"},
{"lineNum":"  327","line":""},
{"lineNum":"  328","line":"    var buf: [max_groups]u8 = undefined;"},
{"lineNum":"  329","line":"    var fbs = std.io.fixedBufferStream(&buf);"},
{"lineNum":"  330","line":""},
{"lineNum":"  331","line":"    // stream write"},
{"lineNum":"  332","line":"    try writeStream(fbs.writer(), value);"},
{"lineNum":"  333","line":"    const w1_pos = fbs.pos;"},
{"lineNum":"  334","line":"    try testing.expect(w1_pos == bytes_needed);"},
{"lineNum":"  335","line":""},
{"lineNum":"  336","line":"    // stream read"},
{"lineNum":"  337","line":"    fbs.pos = 0;"},
{"lineNum":"  338","line":"    const sr = try readStream(T, fbs.reader());"},
{"lineNum":"  339","line":"    try testing.expect(fbs.pos == w1_pos);"},
{"lineNum":"  340","line":"    try testing.expect(sr == value);"},
{"lineNum":"  341","line":""},
{"lineNum":"  342","line":"    // bigger type stream read"},
{"lineNum":"  343","line":"    fbs.pos = 0;"},
{"lineNum":"  344","line":"    const bsr = try readStream(B, fbs.reader());"},
{"lineNum":"  345","line":"    try testing.expect(fbs.pos == w1_pos);"},
{"lineNum":"  346","line":"    try testing.expect(bsr == value);"},
{"lineNum":"  347","line":"}"},
{"lineNum":"  348","line":""},
{"lineNum":"  349","line":"test \"serialize unsigned LEB128\" {"},
{"lineNum":"  350","line":"    const max_bits = 18;"},
{"lineNum":"  351","line":""},
{"lineNum":"  352","line":"    comptime var t = 0;"},
{"lineNum":"  353","line":"    inline while (t <= max_bits) : (t += 1) {"},
{"lineNum":"  354","line":"        const T = std.meta.Int(.unsigned, t);"},
{"lineNum":"  355","line":"        const min = std.math.minInt(T);"},
{"lineNum":"  356","line":"        const max = std.math.maxInt(T);"},
{"lineNum":"  357","line":"        var i = @as(std.meta.Int(.unsigned, @typeInfo(T).Int.bits + 1), min);"},
{"lineNum":"  358","line":""},
{"lineNum":"  359","line":"        while (i <= max) : (i += 1) try test_write_leb128(@as(T, @intCast(i)));"},
{"lineNum":"  360","line":"    }"},
{"lineNum":"  361","line":"}"},
{"lineNum":"  362","line":""},
{"lineNum":"  363","line":"test \"serialize signed LEB128\" {"},
{"lineNum":"  364","line":"    // explicitly test i0 because starting `t` at 0"},
{"lineNum":"  365","line":"    // will break the while loop"},
{"lineNum":"  366","line":"    try test_write_leb128(@as(i0, 0));"},
{"lineNum":"  367","line":""},
{"lineNum":"  368","line":"    const max_bits = 18;"},
{"lineNum":"  369","line":""},
{"lineNum":"  370","line":"    comptime var t = 1;"},
{"lineNum":"  371","line":"    inline while (t <= max_bits) : (t += 1) {"},
{"lineNum":"  372","line":"        const T = std.meta.Int(.signed, t);"},
{"lineNum":"  373","line":"        const min = std.math.minInt(T);"},
{"lineNum":"  374","line":"        const max = std.math.maxInt(T);"},
{"lineNum":"  375","line":"        var i = @as(std.meta.Int(.signed, @typeInfo(T).Int.bits + 1), min);"},
{"lineNum":"  376","line":""},
{"lineNum":"  377","line":"        while (i <= max) : (i += 1) try test_write_leb128(@as(T, @intCast(i)));"},
{"lineNum":"  378","line":"    }"},
{"lineNum":"  379","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test", "date" : "2024-04-26 16:14:49", "instrumented" : 40, "covered" : 0,};
var merged_data = [];
