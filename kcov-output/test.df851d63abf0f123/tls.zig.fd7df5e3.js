var data = {lines:[
{"lineNum":"    1","line":"const std = @import(\"std\");"},
{"lineNum":"    2","line":"const os = std.os;"},
{"lineNum":"    3","line":"const mem = std.mem;"},
{"lineNum":"    4","line":"const elf = std.elf;"},
{"lineNum":"    5","line":"const math = std.math;"},
{"lineNum":"    6","line":"const assert = std.debug.assert;"},
{"lineNum":"    7","line":"const native_arch = @import(\"builtin\").cpu.arch;"},
{"lineNum":"    8","line":""},
{"lineNum":"    9","line":"// This file implements the two TLS variants [1] used by ELF-based systems."},
{"lineNum":"   10","line":"//"},
{"lineNum":"   11","line":"// The variant I has the following layout in memory:"},
{"lineNum":"   12","line":"// -------------------------------------------------------"},
{"lineNum":"   13","line":"// |   DTV   |     Zig     |   DTV   | Alignment |  TLS  |"},
{"lineNum":"   14","line":"// | storage | thread data | pointer |           | block |"},
{"lineNum":"   15","line":"// ------------------------^------------------------------"},
{"lineNum":"   16","line":"//                         `-- The thread pointer register points here"},
{"lineNum":"   17","line":"//"},
{"lineNum":"   18","line":"// In this case we allocate additional space for our control structure that\'s"},
{"lineNum":"   19","line":"// placed _before_ the DTV pointer together with the DTV."},
{"lineNum":"   20","line":"//"},
{"lineNum":"   21","line":"// NOTE: Some systems such as power64 or mips use this variant with a twist: the"},
{"lineNum":"   22","line":"// alignment is not present and the tp and DTV addresses are offset by a"},
{"lineNum":"   23","line":"// constant."},
{"lineNum":"   24","line":"//"},
{"lineNum":"   25","line":"// On the other hand the variant II has the following layout in memory:"},
{"lineNum":"   26","line":"// ---------------------------------------"},
{"lineNum":"   27","line":"// |  TLS  | TCB |     Zig     |   DTV   |"},
{"lineNum":"   28","line":"// | block |     | thread data | storage |"},
{"lineNum":"   29","line":"// --------^------------------------------"},
{"lineNum":"   30","line":"//         `-- The thread pointer register points here"},
{"lineNum":"   31","line":"//"},
{"lineNum":"   32","line":"// The structure of the TCB is not defined by the ABI so we reserve enough space"},
{"lineNum":"   33","line":"// for a single pointer as some architectures such as x86 and x86_64 need a"},
{"lineNum":"   34","line":"// pointer to the TCB block itself at the address pointed by the tp."},
{"lineNum":"   35","line":"//"},
{"lineNum":"   36","line":"// In this case the control structure and DTV are placed one after another right"},
{"lineNum":"   37","line":"// after the TLS block data."},
{"lineNum":"   38","line":"//"},
{"lineNum":"   39","line":"// At the moment the DTV is very simple since we only support static TLS, all we"},
{"lineNum":"   40","line":"// need is a two word vector to hold the number of entries (1) and the address"},
{"lineNum":"   41","line":"// of the first TLS block."},
{"lineNum":"   42","line":"//"},
{"lineNum":"   43","line":"// [1] https://www.akkadia.org/drepper/tls.pdf"},
{"lineNum":"   44","line":""},
{"lineNum":"   45","line":"const TLSVariant = enum {"},
{"lineNum":"   46","line":"    VariantI,"},
{"lineNum":"   47","line":"    VariantII,"},
{"lineNum":"   48","line":"};"},
{"lineNum":"   49","line":""},
{"lineNum":"   50","line":"const tls_variant = switch (native_arch) {"},
{"lineNum":"   51","line":"    .arm, .armeb, .thumb, .aarch64, .aarch64_be, .riscv32, .riscv64, .mips, .mipsel, .mips64, .mips64el, .powerpc, .powerpcle, .powerpc64, .powerpc64le => TLSVariant.VariantI,"},
{"lineNum":"   52","line":"    .x86_64, .x86, .sparc64 => TLSVariant.VariantII,"},
{"lineNum":"   53","line":"    else => @compileError(\"undefined tls_variant for this architecture\"),"},
{"lineNum":"   54","line":"};"},
{"lineNum":"   55","line":""},
{"lineNum":"   56","line":"// Controls how many bytes are reserved for the Thread Control Block"},
{"lineNum":"   57","line":"const tls_tcb_size = switch (native_arch) {"},
{"lineNum":"   58","line":"    // ARM EABI mandates enough space for two pointers: the first one points to"},
{"lineNum":"   59","line":"    // the DTV while the second one is unspecified but reserved"},
{"lineNum":"   60","line":"    .arm, .armeb, .thumb, .aarch64, .aarch64_be => 2 * @sizeOf(usize),"},
{"lineNum":"   61","line":"    // One pointer-sized word that points either to the DTV or the TCB itself"},
{"lineNum":"   62","line":"    else => @sizeOf(usize),"},
{"lineNum":"   63","line":"};"},
{"lineNum":"   64","line":""},
{"lineNum":"   65","line":"// Controls if the TP points to the end of the TCB instead of its beginning"},
{"lineNum":"   66","line":"const tls_tp_points_past_tcb = switch (native_arch) {"},
{"lineNum":"   67","line":"    .riscv32, .riscv64, .mips, .mipsel, .mips64, .mips64el, .powerpc, .powerpc64, .powerpc64le => true,"},
{"lineNum":"   68","line":"    else => false,"},
{"lineNum":"   69","line":"};"},
{"lineNum":"   70","line":""},
{"lineNum":"   71","line":"// Some architectures add some offset to the tp and dtv addresses in order to"},
{"lineNum":"   72","line":"// make the generated code more efficient"},
{"lineNum":"   73","line":""},
{"lineNum":"   74","line":"const tls_tp_offset = switch (native_arch) {"},
{"lineNum":"   75","line":"    .mips, .mipsel, .mips64, .mips64el, .powerpc, .powerpc64, .powerpc64le => 0x7000,"},
{"lineNum":"   76","line":"    else => 0,"},
{"lineNum":"   77","line":"};"},
{"lineNum":"   78","line":""},
{"lineNum":"   79","line":"const tls_dtv_offset = switch (native_arch) {"},
{"lineNum":"   80","line":"    .mips, .mipsel, .mips64, .mips64el, .powerpc, .powerpc64, .powerpc64le => 0x8000,"},
{"lineNum":"   81","line":"    .riscv32, .riscv64 => 0x800,"},
{"lineNum":"   82","line":"    else => 0,"},
{"lineNum":"   83","line":"};"},
{"lineNum":"   84","line":""},
{"lineNum":"   85","line":"// Per-thread storage for Zig\'s use"},
{"lineNum":"   86","line":"const CustomData = struct {"},
{"lineNum":"   87","line":"    dummy: usize,"},
{"lineNum":"   88","line":"};"},
{"lineNum":"   89","line":""},
{"lineNum":"   90","line":"// Dynamic Thread Vector"},
{"lineNum":"   91","line":"const DTV = extern struct {"},
{"lineNum":"   92","line":"    entries: usize,"},
{"lineNum":"   93","line":"    tls_block: [1][*]u8,"},
{"lineNum":"   94","line":"};"},
{"lineNum":"   95","line":""},
{"lineNum":"   96","line":"// Holds all the information about the process TLS image"},
{"lineNum":"   97","line":"const TLSImage = struct {"},
{"lineNum":"   98","line":"    init_data: []const u8,"},
{"lineNum":"   99","line":"    alloc_size: usize,"},
{"lineNum":"  100","line":"    alloc_align: usize,"},
{"lineNum":"  101","line":"    tcb_offset: usize,"},
{"lineNum":"  102","line":"    dtv_offset: usize,"},
{"lineNum":"  103","line":"    data_offset: usize,"},
{"lineNum":"  104","line":"    data_size: usize,"},
{"lineNum":"  105","line":"    // Only used on the x86 architecture"},
{"lineNum":"  106","line":"    gdt_entry_number: usize,"},
{"lineNum":"  107","line":"};"},
{"lineNum":"  108","line":""},
{"lineNum":"  109","line":"pub var tls_image: TLSImage = undefined;"},
{"lineNum":"  110","line":""},
{"lineNum":"  111","line":"pub fn setThreadPointer(addr: usize) void {","class":"lineCov","hits":"1","order":"90","possible_hits":"1",},
{"lineNum":"  112","line":"    switch (native_arch) {"},
{"lineNum":"  113","line":"        .x86 => {"},
{"lineNum":"  114","line":"            var user_desc = std.os.linux.user_desc{"},
{"lineNum":"  115","line":"                .entry_number = tls_image.gdt_entry_number,"},
{"lineNum":"  116","line":"                .base_addr = addr,"},
{"lineNum":"  117","line":"                .limit = 0xfffff,"},
{"lineNum":"  118","line":"                .flags = .{"},
{"lineNum":"  119","line":"                    .seg_32bit = 1,"},
{"lineNum":"  120","line":"                    .contents = 0, // Data"},
{"lineNum":"  121","line":"                    .read_exec_only = 0,"},
{"lineNum":"  122","line":"                    .limit_in_pages = 1,"},
{"lineNum":"  123","line":"                    .seg_not_present = 0,"},
{"lineNum":"  124","line":"                    .useable = 1,"},
{"lineNum":"  125","line":"                },"},
{"lineNum":"  126","line":"            };"},
{"lineNum":"  127","line":"            const rc = std.os.linux.syscall1(.set_thread_area, @intFromPtr(&user_desc));"},
{"lineNum":"  128","line":"            assert(rc == 0);"},
{"lineNum":"  129","line":""},
{"lineNum":"  130","line":"            const gdt_entry_number = user_desc.entry_number;"},
{"lineNum":"  131","line":"            // We have to keep track of our slot as it\'s also needed for clone()"},
{"lineNum":"  132","line":"            tls_image.gdt_entry_number = gdt_entry_number;"},
{"lineNum":"  133","line":"            // Update the %gs selector"},
{"lineNum":"  134","line":"            asm volatile (\"movl %[gs_val], %%gs\""},
{"lineNum":"  135","line":"                :"},
{"lineNum":"  136","line":"                : [gs_val] \"r\" (gdt_entry_number << 3 | 3),"},
{"lineNum":"  137","line":"            );"},
{"lineNum":"  138","line":"        },"},
{"lineNum":"  139","line":"        .x86_64 => {"},
{"lineNum":"  140","line":"            const rc = std.os.linux.syscall2(.arch_prctl, std.os.linux.ARCH.SET_FS, addr);","class":"lineCov","hits":"1","order":"91","possible_hits":"1",},
{"lineNum":"  141","line":"            assert(rc == 0);","class":"lineCov","hits":"1","order":"94","possible_hits":"1",},
{"lineNum":"  142","line":"        },"},
{"lineNum":"  143","line":"        .aarch64, .aarch64_be => {"},
{"lineNum":"  144","line":"            asm volatile ("},
{"lineNum":"  145","line":"                \\\\ msr tpidr_el0, %[addr]"},
{"lineNum":"  146","line":"                :"},
{"lineNum":"  147","line":"                : [addr] \"r\" (addr),"},
{"lineNum":"  148","line":"            );"},
{"lineNum":"  149","line":"        },"},
{"lineNum":"  150","line":"        .arm, .thumb => {"},
{"lineNum":"  151","line":"            const rc = std.os.linux.syscall1(.set_tls, addr);"},
{"lineNum":"  152","line":"            assert(rc == 0);"},
{"lineNum":"  153","line":"        },"},
{"lineNum":"  154","line":"        .riscv64 => {"},
{"lineNum":"  155","line":"            asm volatile ("},
{"lineNum":"  156","line":"                \\\\ mv tp, %[addr]"},
{"lineNum":"  157","line":"                :"},
{"lineNum":"  158","line":"                : [addr] \"r\" (addr),"},
{"lineNum":"  159","line":"            );"},
{"lineNum":"  160","line":"        },"},
{"lineNum":"  161","line":"        .mips, .mipsel, .mips64, .mips64el => {"},
{"lineNum":"  162","line":"            const rc = std.os.linux.syscall1(.set_thread_area, addr);"},
{"lineNum":"  163","line":"            assert(rc == 0);"},
{"lineNum":"  164","line":"        },"},
{"lineNum":"  165","line":"        .powerpc, .powerpcle => {"},
{"lineNum":"  166","line":"            asm volatile ("},
{"lineNum":"  167","line":"                \\\\ mr 2, %[addr]"},
{"lineNum":"  168","line":"                :"},
{"lineNum":"  169","line":"                : [addr] \"r\" (addr),"},
{"lineNum":"  170","line":"            );"},
{"lineNum":"  171","line":"        },"},
{"lineNum":"  172","line":"        .powerpc64, .powerpc64le => {"},
{"lineNum":"  173","line":"            asm volatile ("},
{"lineNum":"  174","line":"                \\\\ mr 13, %[addr]"},
{"lineNum":"  175","line":"                :"},
{"lineNum":"  176","line":"                : [addr] \"r\" (addr),"},
{"lineNum":"  177","line":"            );"},
{"lineNum":"  178","line":"        },"},
{"lineNum":"  179","line":"        .sparc64 => {"},
{"lineNum":"  180","line":"            asm volatile ("},
{"lineNum":"  181","line":"                \\\\ mov %[addr], %%g7"},
{"lineNum":"  182","line":"                :"},
{"lineNum":"  183","line":"                : [addr] \"r\" (addr),"},
{"lineNum":"  184","line":"            );"},
{"lineNum":"  185","line":"        },"},
{"lineNum":"  186","line":"        else => @compileError(\"Unsupported architecture\"),"},
{"lineNum":"  187","line":"    }"},
{"lineNum":"  188","line":"}"},
{"lineNum":"  189","line":""},
{"lineNum":"  190","line":"fn initTLS(phdrs: []elf.Phdr) void {","class":"lineCov","hits":"1","order":"24","possible_hits":"1",},
{"lineNum":"  191","line":"    var tls_phdr: ?*elf.Phdr = null;","class":"lineCov","hits":"1","order":"25","possible_hits":"1",},
{"lineNum":"  192","line":"    var img_base: usize = 0;","class":"lineCov","hits":"1","order":"26","possible_hits":"1",},
{"lineNum":"  193","line":""},
{"lineNum":"  194","line":"    for (phdrs) |*phdr| {","class":"lineCov","hits":"3","order":"27","possible_hits":"3",},
{"lineNum":"  195","line":"        switch (phdr.p_type) {","class":"lineCov","hits":"1","order":"28","possible_hits":"1",},
{"lineNum":"  196","line":"            elf.PT_PHDR => img_base = @intFromPtr(phdrs.ptr) - phdr.p_vaddr,","class":"lineCov","hits":"1","order":"29","possible_hits":"1",},
{"lineNum":"  197","line":"            elf.PT_TLS => tls_phdr = phdr,","class":"lineCov","hits":"3","order":"30","possible_hits":"3",},
{"lineNum":"  198","line":"            else => {},"},
{"lineNum":"  199","line":"        }"},
{"lineNum":"  200","line":"    }"},
{"lineNum":"  201","line":""},
{"lineNum":"  202","line":"    var tls_align_factor: usize = undefined;","class":"lineCov","hits":"1","order":"31","possible_hits":"1",},
{"lineNum":"  203","line":"    var tls_data: []const u8 = undefined;","class":"lineCov","hits":"1","order":"37","possible_hits":"1",},
{"lineNum":"  204","line":"    var tls_data_alloc_size: usize = undefined;","class":"lineCov","hits":"1","order":"38","possible_hits":"1",},
{"lineNum":"  205","line":"    if (tls_phdr) |phdr| {","class":"lineCov","hits":"2","order":"39","possible_hits":"2",},
{"lineNum":"  206","line":"        // The effective size in memory is represented by p_memsz, the length of"},
{"lineNum":"  207","line":"        // the data stored in the PT_TLS segment is p_filesz and may be less"},
{"lineNum":"  208","line":"        // than the former"},
{"lineNum":"  209","line":"        tls_align_factor = phdr.p_align;","class":"lineCov","hits":"1","order":"40","possible_hits":"1",},
{"lineNum":"  210","line":"        tls_data = @as([*]u8, @ptrFromInt(img_base + phdr.p_vaddr))[0..phdr.p_filesz];","class":"linePartCov","hits":"2","order":"41","possible_hits":"3",},
{"lineNum":"  211","line":"        tls_data_alloc_size = phdr.p_memsz;","class":"lineCov","hits":"1","order":"42","possible_hits":"1",},
{"lineNum":"  212","line":"    } else {"},
{"lineNum":"  213","line":"        tls_align_factor = @alignOf(usize);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  214","line":"        tls_data = &[_]u8{};","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  215","line":"        tls_data_alloc_size = 0;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  216","line":"    }"},
{"lineNum":"  217","line":""},
{"lineNum":"  218","line":"    // Offsets into the allocated TLS area"},
{"lineNum":"  219","line":"    var tcb_offset: usize = undefined;","class":"lineCov","hits":"1","order":"43","possible_hits":"1",},
{"lineNum":"  220","line":"    var dtv_offset: usize = undefined;","class":"lineCov","hits":"1","order":"44","possible_hits":"1",},
{"lineNum":"  221","line":"    var data_offset: usize = undefined;","class":"lineCov","hits":"1","order":"45","possible_hits":"1",},
{"lineNum":"  222","line":"    // Compute the total size of the ABI-specific data plus our own control"},
{"lineNum":"  223","line":"    // structures. All the offset calculated here assume a well-aligned base"},
{"lineNum":"  224","line":"    // address."},
{"lineNum":"  225","line":"    const alloc_size = switch (tls_variant) {"},
{"lineNum":"  226","line":"        .VariantI => blk: {"},
{"lineNum":"  227","line":"            var l: usize = 0;"},
{"lineNum":"  228","line":"            dtv_offset = l;"},
{"lineNum":"  229","line":"            l += @sizeOf(DTV);"},
{"lineNum":"  230","line":"            // Add some padding here so that the thread pointer (tcb_offset) is"},
{"lineNum":"  231","line":"            // aligned to p_align and the CustomData structure can be found by"},
{"lineNum":"  232","line":"            // simply subtracting its @sizeOf from the tp value"},
{"lineNum":"  233","line":"            const delta = (l + @sizeOf(CustomData)) & (tls_align_factor - 1);"},
{"lineNum":"  234","line":"            if (delta > 0)"},
{"lineNum":"  235","line":"                l += tls_align_factor - delta;"},
{"lineNum":"  236","line":"            l += @sizeOf(CustomData);"},
{"lineNum":"  237","line":"            tcb_offset = l;"},
{"lineNum":"  238","line":"            l += mem.alignForward(usize, tls_tcb_size, tls_align_factor);"},
{"lineNum":"  239","line":"            data_offset = l;"},
{"lineNum":"  240","line":"            l += tls_data_alloc_size;"},
{"lineNum":"  241","line":"            break :blk l;"},
{"lineNum":"  242","line":"        },"},
{"lineNum":"  243","line":"        .VariantII => blk: {"},
{"lineNum":"  244","line":"            var l: usize = 0;","class":"lineCov","hits":"1","order":"46","possible_hits":"1",},
{"lineNum":"  245","line":"            data_offset = l;","class":"lineCov","hits":"1","order":"47","possible_hits":"1",},
{"lineNum":"  246","line":"            l += mem.alignForward(usize, tls_data_alloc_size, tls_align_factor);","class":"linePartCov","hits":"1","order":"48","possible_hits":"2",},
{"lineNum":"  247","line":"            // The thread pointer is aligned to p_align"},
{"lineNum":"  248","line":"            tcb_offset = l;","class":"lineCov","hits":"1","order":"62","possible_hits":"1",},
{"lineNum":"  249","line":"            l += tls_tcb_size;","class":"lineCov","hits":"1","order":"63","possible_hits":"1",},
{"lineNum":"  250","line":"            // The CustomData structure is right after the TCB with no padding"},
{"lineNum":"  251","line":"            // in between so it can be easily found"},
{"lineNum":"  252","line":"            l += @sizeOf(CustomData);","class":"lineCov","hits":"1","order":"64","possible_hits":"1",},
{"lineNum":"  253","line":"            l = mem.alignForward(usize, l, @alignOf(DTV));","class":"lineCov","hits":"1","order":"65","possible_hits":"1",},
{"lineNum":"  254","line":"            dtv_offset = l;","class":"lineCov","hits":"1","order":"66","possible_hits":"1",},
{"lineNum":"  255","line":"            l += @sizeOf(DTV);","class":"lineCov","hits":"1","order":"67","possible_hits":"1",},
{"lineNum":"  256","line":"            break :blk l;","class":"lineCov","hits":"1","order":"68","possible_hits":"1",},
{"lineNum":"  257","line":"        },"},
{"lineNum":"  258","line":"    };"},
{"lineNum":"  259","line":""},
{"lineNum":"  260","line":"    tls_image = TLSImage{","class":"lineCov","hits":"1","order":"69","possible_hits":"1",},
{"lineNum":"  261","line":"        .init_data = tls_data,"},
{"lineNum":"  262","line":"        .alloc_size = alloc_size,"},
{"lineNum":"  263","line":"        .alloc_align = tls_align_factor,"},
{"lineNum":"  264","line":"        .tcb_offset = tcb_offset,"},
{"lineNum":"  265","line":"        .dtv_offset = dtv_offset,"},
{"lineNum":"  266","line":"        .data_offset = data_offset,"},
{"lineNum":"  267","line":"        .data_size = tls_data_alloc_size,"},
{"lineNum":"  268","line":"        .gdt_entry_number = @as(usize, @bitCast(@as(isize, -1))),"},
{"lineNum":"  269","line":"    };"},
{"lineNum":"  270","line":"}"},
{"lineNum":"  271","line":""},
{"lineNum":"  272","line":"inline fn alignPtrCast(comptime T: type, ptr: [*]u8) *T {"},
{"lineNum":"  273","line":"    return @ptrCast(@alignCast(ptr));","class":"lineCov","hits":"3","order":"78","possible_hits":"3",},
{"lineNum":"  274","line":"}"},
{"lineNum":"  275","line":""},
{"lineNum":"  276","line":"/// Initializes all the fields of the static TLS area and returns the computed"},
{"lineNum":"  277","line":"/// architecture-specific value of the thread-pointer register"},
{"lineNum":"  278","line":"pub fn prepareTLS(area: []u8) usize {","class":"lineCov","hits":"1","order":"75","possible_hits":"1",},
{"lineNum":"  279","line":"    // Clear the area we\'re going to use, just to be safe"},
{"lineNum":"  280","line":"    @memset(area, 0);","class":"lineCov","hits":"1","order":"76","possible_hits":"1",},
{"lineNum":"  281","line":"    // Prepare the DTV"},
{"lineNum":"  282","line":"    const dtv = alignPtrCast(DTV, area.ptr + tls_image.dtv_offset);","class":"lineCov","hits":"1","order":"77","possible_hits":"1",},
{"lineNum":"  283","line":"    dtv.entries = 1;","class":"lineCov","hits":"1","order":"79","possible_hits":"1",},
{"lineNum":"  284","line":"    dtv.tls_block[0] = area.ptr + tls_dtv_offset + tls_image.data_offset;","class":"lineCov","hits":"1","order":"80","possible_hits":"1",},
{"lineNum":"  285","line":"    // Prepare the TCB"},
{"lineNum":"  286","line":"    const tcb_ptr = alignPtrCast([*]u8, area.ptr + tls_image.tcb_offset);","class":"lineCov","hits":"1","order":"81","possible_hits":"1",},
{"lineNum":"  287","line":"    tcb_ptr.* = switch (tls_variant) {"},
{"lineNum":"  288","line":"        .VariantI => area.ptr + tls_image.dtv_offset,"},
{"lineNum":"  289","line":"        .VariantII => area.ptr + tls_image.tcb_offset,","class":"lineCov","hits":"1","order":"82","possible_hits":"1",},
{"lineNum":"  290","line":"    };"},
{"lineNum":"  291","line":"    // Copy the data"},
{"lineNum":"  292","line":"    @memcpy(area[tls_image.data_offset..][0..tls_image.init_data.len], tls_image.init_data);","class":"lineCov","hits":"3","order":"83","possible_hits":"3",},
{"lineNum":"  293","line":""},
{"lineNum":"  294","line":"    // Return the corrected value (if needed) for the tp register."},
{"lineNum":"  295","line":"    // Overflow here is not a problem, the pointer arithmetic involving the tp"},
{"lineNum":"  296","line":"    // is done with wrapping semantics."},
{"lineNum":"  297","line":"    return @intFromPtr(area.ptr) +% tls_tp_offset +%","class":"lineCov","hits":"1","order":"88","possible_hits":"1",},
{"lineNum":"  298","line":"        if (tls_tp_points_past_tcb) tls_image.data_offset else tls_image.tcb_offset;","class":"lineCov","hits":"1","order":"87","possible_hits":"1",},
{"lineNum":"  299","line":"}"},
{"lineNum":"  300","line":""},
{"lineNum":"  301","line":"// The main motivation for the size chosen here is this is how much ends up being"},
{"lineNum":"  302","line":"// requested for the thread local variables of the std.crypto.random implementation."},
{"lineNum":"  303","line":"// I\'m not sure why it ends up being so much; the struct itself is only 64 bytes."},
{"lineNum":"  304","line":"// I think it has to do with being page aligned and LLVM or LLD is not smart enough"},
{"lineNum":"  305","line":"// to lay out the TLS data in a space conserving way. Anyway I think it\'s fine"},
{"lineNum":"  306","line":"// because it\'s less than 3 pages of memory, and putting it in the ELF like this"},
{"lineNum":"  307","line":"// is equivalent to moving the mmap call below into the kernel, avoiding syscall"},
{"lineNum":"  308","line":"// overhead."},
{"lineNum":"  309","line":"var main_thread_tls_buffer: [0x2100]u8 align(mem.page_size) = undefined;"},
{"lineNum":"  310","line":""},
{"lineNum":"  311","line":"pub fn initStaticTLS(phdrs: []elf.Phdr) void {","class":"lineCov","hits":"1","order":"22","possible_hits":"1",},
{"lineNum":"  312","line":"    initTLS(phdrs);","class":"lineCov","hits":"1","order":"23","possible_hits":"1",},
{"lineNum":"  313","line":""},
{"lineNum":"  314","line":"    const tls_area = blk: {"},
{"lineNum":"  315","line":"        // Fast path for the common case where the TLS data is really small,"},
{"lineNum":"  316","line":"        // avoid an allocation and use our local buffer."},
{"lineNum":"  317","line":"        if (tls_image.alloc_align <= mem.page_size and","class":"lineCov","hits":"1","order":"70","possible_hits":"1",},
{"lineNum":"  318","line":"            tls_image.alloc_size <= main_thread_tls_buffer.len)","class":"lineCov","hits":"1","order":"71","possible_hits":"1",},
{"lineNum":"  319","line":"        {"},
{"lineNum":"  320","line":"            break :blk main_thread_tls_buffer[0..tls_image.alloc_size];","class":"lineCov","hits":"1","order":"72","possible_hits":"1",},
{"lineNum":"  321","line":"        }"},
{"lineNum":"  322","line":""},
{"lineNum":"  323","line":"        const alloc_tls_area = os.mmap(","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  324","line":"            null,"},
{"lineNum":"  325","line":"            tls_image.alloc_size + tls_image.alloc_align - 1,","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  326","line":"            os.PROT.READ | os.PROT.WRITE,"},
{"lineNum":"  327","line":"            os.MAP.PRIVATE | os.MAP.ANONYMOUS,"},
{"lineNum":"  328","line":"            -1,"},
{"lineNum":"  329","line":"            0,"},
{"lineNum":"  330","line":"        ) catch os.abort();","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  331","line":""},
{"lineNum":"  332","line":"        // Make sure the slice is correctly aligned."},
{"lineNum":"  333","line":"        const begin_addr = @intFromPtr(alloc_tls_area.ptr);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  334","line":"        const begin_aligned_addr = mem.alignForward(usize, begin_addr, tls_image.alloc_align);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  335","line":"        const start = begin_aligned_addr - begin_addr;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  336","line":"        break :blk alloc_tls_area[start .. start + tls_image.alloc_size];","class":"linePartCov","hits":"1","order":"73","possible_hits":"2",},
{"lineNum":"  337","line":"    };"},
{"lineNum":"  338","line":""},
{"lineNum":"  339","line":"    const tp_value = prepareTLS(tls_area);","class":"lineCov","hits":"1","order":"74","possible_hits":"1",},
{"lineNum":"  340","line":"    setThreadPointer(tp_value);","class":"lineCov","hits":"1","order":"89","possible_hits":"1",},
{"lineNum":"  341","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test", "date" : "2024-04-26 16:14:49", "instrumented" : 59, "covered" : 50,};
var merged_data = [];
