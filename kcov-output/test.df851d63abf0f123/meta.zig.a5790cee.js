var data = {lines:[
{"lineNum":"    1","line":"const std = @import(\"std.zig\");"},
{"lineNum":"    2","line":"const debug = std.debug;"},
{"lineNum":"    3","line":"const mem = std.mem;"},
{"lineNum":"    4","line":"const math = std.math;"},
{"lineNum":"    5","line":"const testing = std.testing;"},
{"lineNum":"    6","line":"const root = @import(\"root\");"},
{"lineNum":"    7","line":""},
{"lineNum":"    8","line":"pub const trait = @import(\"meta/trait.zig\");"},
{"lineNum":"    9","line":"pub const TrailerFlags = @import(\"meta/trailer_flags.zig\").TrailerFlags;"},
{"lineNum":"   10","line":""},
{"lineNum":"   11","line":"const Type = std.builtin.Type;"},
{"lineNum":"   12","line":""},
{"lineNum":"   13","line":"test {"},
{"lineNum":"   14","line":"    _ = TrailerFlags;"},
{"lineNum":"   15","line":"}"},
{"lineNum":"   16","line":""},
{"lineNum":"   17","line":"pub const tagName = @compileError(\"deprecated; use @tagName or @errorName directly\");"},
{"lineNum":"   18","line":""},
{"lineNum":"   19","line":"pub const isTag = @compileError(\"deprecated; use \'tagged_value == @field(E, tag_name)\' directly\");"},
{"lineNum":"   20","line":""},
{"lineNum":"   21","line":"/// Returns the variant of an enum type, `T`, which is named `str`, or `null` if no such variant exists."},
{"lineNum":"   22","line":"pub fn stringToEnum(comptime T: type, str: []const u8) ?T {"},
{"lineNum":"   23","line":"    // Using ComptimeStringMap here is more performant, but it will start to take too"},
{"lineNum":"   24","line":"    // long to compile if the enum is large enough, due to the current limits of comptime"},
{"lineNum":"   25","line":"    // performance when doing things like constructing lookup maps at comptime."},
{"lineNum":"   26","line":"    // TODO The \'100\' here is arbitrary and should be increased when possible:"},
{"lineNum":"   27","line":"    // - https://github.com/ziglang/zig/issues/4055"},
{"lineNum":"   28","line":"    // - https://github.com/ziglang/zig/issues/3863"},
{"lineNum":"   29","line":"    if (@typeInfo(T).Enum.fields.len <= 100) {"},
{"lineNum":"   30","line":"        const kvs = comptime build_kvs: {"},
{"lineNum":"   31","line":"            const EnumKV = struct { []const u8, T };"},
{"lineNum":"   32","line":"            var kvs_array: [@typeInfo(T).Enum.fields.len]EnumKV = undefined;"},
{"lineNum":"   33","line":"            inline for (@typeInfo(T).Enum.fields, 0..) |enumField, i| {"},
{"lineNum":"   34","line":"                kvs_array[i] = .{ enumField.name, @field(T, enumField.name) };"},
{"lineNum":"   35","line":"            }"},
{"lineNum":"   36","line":"            break :build_kvs kvs_array[0..];"},
{"lineNum":"   37","line":"        };"},
{"lineNum":"   38","line":"        const map = std.ComptimeStringMap(T, kvs);"},
{"lineNum":"   39","line":"        return map.get(str);"},
{"lineNum":"   40","line":"    } else {"},
{"lineNum":"   41","line":"        inline for (@typeInfo(T).Enum.fields) |enumField| {"},
{"lineNum":"   42","line":"            if (mem.eql(u8, str, enumField.name)) {"},
{"lineNum":"   43","line":"                return @field(T, enumField.name);"},
{"lineNum":"   44","line":"            }"},
{"lineNum":"   45","line":"        }"},
{"lineNum":"   46","line":"        return null;"},
{"lineNum":"   47","line":"    }"},
{"lineNum":"   48","line":"}"},
{"lineNum":"   49","line":""},
{"lineNum":"   50","line":"test \"std.meta.stringToEnum\" {"},
{"lineNum":"   51","line":"    const E1 = enum {"},
{"lineNum":"   52","line":"        A,"},
{"lineNum":"   53","line":"        B,"},
{"lineNum":"   54","line":"    };"},
{"lineNum":"   55","line":"    try testing.expect(E1.A == stringToEnum(E1, \"A\").?);"},
{"lineNum":"   56","line":"    try testing.expect(E1.B == stringToEnum(E1, \"B\").?);"},
{"lineNum":"   57","line":"    try testing.expect(null == stringToEnum(E1, \"C\"));"},
{"lineNum":"   58","line":"}"},
{"lineNum":"   59","line":""},
{"lineNum":"   60","line":"/// Returns the alignment of type T."},
{"lineNum":"   61","line":"/// Note that if T is a pointer or function type the result is different than"},
{"lineNum":"   62","line":"/// the one returned by @alignOf(T)."},
{"lineNum":"   63","line":"/// If T is a pointer type the alignment of the type it points to is returned."},
{"lineNum":"   64","line":"/// If T is a function type the alignment a target-dependent value is returned."},
{"lineNum":"   65","line":"pub fn alignment(comptime T: type) comptime_int {"},
{"lineNum":"   66","line":"    return switch (@typeInfo(T)) {"},
{"lineNum":"   67","line":"        .Optional => |info| switch (@typeInfo(info.child)) {"},
{"lineNum":"   68","line":"            .Pointer, .Fn => alignment(info.child),"},
{"lineNum":"   69","line":"            else => @alignOf(T),"},
{"lineNum":"   70","line":"        },"},
{"lineNum":"   71","line":"        .Pointer => |info| info.alignment,"},
{"lineNum":"   72","line":"        .Fn => |info| info.alignment,"},
{"lineNum":"   73","line":"        else => @alignOf(T),"},
{"lineNum":"   74","line":"    };"},
{"lineNum":"   75","line":"}"},
{"lineNum":"   76","line":""},
{"lineNum":"   77","line":"test \"std.meta.alignment\" {"},
{"lineNum":"   78","line":"    try testing.expect(alignment(u8) == 1);"},
{"lineNum":"   79","line":"    try testing.expect(alignment(*align(1) u8) == 1);"},
{"lineNum":"   80","line":"    try testing.expect(alignment(*align(2) u8) == 2);"},
{"lineNum":"   81","line":"    try testing.expect(alignment([]align(1) u8) == 1);"},
{"lineNum":"   82","line":"    try testing.expect(alignment([]align(2) u8) == 2);"},
{"lineNum":"   83","line":"    try testing.expect(alignment(fn () void) > 0);"},
{"lineNum":"   84","line":"    try testing.expect(alignment(fn () align(128) void) == 128);"},
{"lineNum":"   85","line":"}"},
{"lineNum":"   86","line":""},
{"lineNum":"   87","line":"/// Given a parameterized type (array, vector, pointer, optional), returns the \"child type\"."},
{"lineNum":"   88","line":"pub fn Child(comptime T: type) type {"},
{"lineNum":"   89","line":"    return switch (@typeInfo(T)) {"},
{"lineNum":"   90","line":"        .Array => |info| info.child,"},
{"lineNum":"   91","line":"        .Vector => |info| info.child,"},
{"lineNum":"   92","line":"        .Pointer => |info| info.child,"},
{"lineNum":"   93","line":"        .Optional => |info| info.child,"},
{"lineNum":"   94","line":"        else => @compileError(\"Expected pointer, optional, array or vector type, found \'\" ++ @typeName(T) ++ \"\'\"),"},
{"lineNum":"   95","line":"    };"},
{"lineNum":"   96","line":"}"},
{"lineNum":"   97","line":""},
{"lineNum":"   98","line":"test \"std.meta.Child\" {"},
{"lineNum":"   99","line":"    try testing.expect(Child([1]u8) == u8);"},
{"lineNum":"  100","line":"    try testing.expect(Child(*u8) == u8);"},
{"lineNum":"  101","line":"    try testing.expect(Child([]u8) == u8);"},
{"lineNum":"  102","line":"    try testing.expect(Child(?u8) == u8);"},
{"lineNum":"  103","line":"    try testing.expect(Child(@Vector(2, u8)) == u8);"},
{"lineNum":"  104","line":"}"},
{"lineNum":"  105","line":""},
{"lineNum":"  106","line":"/// Given a \"memory span\" type (array, slice, vector, or pointer to such), returns the \"element type\"."},
{"lineNum":"  107","line":"pub fn Elem(comptime T: type) type {"},
{"lineNum":"  108","line":"    switch (@typeInfo(T)) {"},
{"lineNum":"  109","line":"        .Array => |info| return info.child,"},
{"lineNum":"  110","line":"        .Vector => |info| return info.child,"},
{"lineNum":"  111","line":"        .Pointer => |info| switch (info.size) {"},
{"lineNum":"  112","line":"            .One => switch (@typeInfo(info.child)) {"},
{"lineNum":"  113","line":"                .Array => |array_info| return array_info.child,"},
{"lineNum":"  114","line":"                .Vector => |vector_info| return vector_info.child,"},
{"lineNum":"  115","line":"                else => {},"},
{"lineNum":"  116","line":"            },"},
{"lineNum":"  117","line":"            .Many, .C, .Slice => return info.child,"},
{"lineNum":"  118","line":"        },"},
{"lineNum":"  119","line":"        .Optional => |info| return Elem(info.child),"},
{"lineNum":"  120","line":"        else => {},"},
{"lineNum":"  121","line":"    }"},
{"lineNum":"  122","line":"    @compileError(\"Expected pointer, slice, array or vector type, found \'\" ++ @typeName(T) ++ \"\'\");"},
{"lineNum":"  123","line":"}"},
{"lineNum":"  124","line":""},
{"lineNum":"  125","line":"test \"std.meta.Elem\" {"},
{"lineNum":"  126","line":"    try testing.expect(Elem([1]u8) == u8);"},
{"lineNum":"  127","line":"    try testing.expect(Elem([*]u8) == u8);"},
{"lineNum":"  128","line":"    try testing.expect(Elem([]u8) == u8);"},
{"lineNum":"  129","line":"    try testing.expect(Elem(*[10]u8) == u8);"},
{"lineNum":"  130","line":"    try testing.expect(Elem(@Vector(2, u8)) == u8);"},
{"lineNum":"  131","line":"    try testing.expect(Elem(*@Vector(2, u8)) == u8);"},
{"lineNum":"  132","line":"    try testing.expect(Elem(?[*]u8) == u8);"},
{"lineNum":"  133","line":"}"},
{"lineNum":"  134","line":""},
{"lineNum":"  135","line":"/// Given a type which can have a sentinel e.g. `[:0]u8`, returns the sentinel value,"},
{"lineNum":"  136","line":"/// or `null` if there is not one."},
{"lineNum":"  137","line":"/// Types which cannot possibly have a sentinel will be a compile error."},
{"lineNum":"  138","line":"pub fn sentinel(comptime T: type) ?Elem(T) {"},
{"lineNum":"  139","line":"    switch (@typeInfo(T)) {"},
{"lineNum":"  140","line":"        .Array => |info| {"},
{"lineNum":"  141","line":"            const sentinel_ptr = info.sentinel orelse return null;"},
{"lineNum":"  142","line":"            return @as(*const info.child, @ptrCast(sentinel_ptr)).*;"},
{"lineNum":"  143","line":"        },"},
{"lineNum":"  144","line":"        .Pointer => |info| {"},
{"lineNum":"  145","line":"            switch (info.size) {"},
{"lineNum":"  146","line":"                .Many, .Slice => {"},
{"lineNum":"  147","line":"                    const sentinel_ptr = info.sentinel orelse return null;"},
{"lineNum":"  148","line":"                    return @as(*align(1) const info.child, @ptrCast(sentinel_ptr)).*;"},
{"lineNum":"  149","line":"                },"},
{"lineNum":"  150","line":"                .One => switch (@typeInfo(info.child)) {"},
{"lineNum":"  151","line":"                    .Array => |array_info| {"},
{"lineNum":"  152","line":"                        const sentinel_ptr = array_info.sentinel orelse return null;"},
{"lineNum":"  153","line":"                        return @as(*align(1) const array_info.child, @ptrCast(sentinel_ptr)).*;"},
{"lineNum":"  154","line":"                    },"},
{"lineNum":"  155","line":"                    else => {},"},
{"lineNum":"  156","line":"                },"},
{"lineNum":"  157","line":"                else => {},"},
{"lineNum":"  158","line":"            }"},
{"lineNum":"  159","line":"        },"},
{"lineNum":"  160","line":"        else => {},"},
{"lineNum":"  161","line":"    }"},
{"lineNum":"  162","line":"    @compileError(\"type \'\" ++ @typeName(T) ++ \"\' cannot possibly have a sentinel\");"},
{"lineNum":"  163","line":"}"},
{"lineNum":"  164","line":""},
{"lineNum":"  165","line":"test \"std.meta.sentinel\" {"},
{"lineNum":"  166","line":"    try testSentinel();"},
{"lineNum":"  167","line":"    try comptime testSentinel();"},
{"lineNum":"  168","line":"}"},
{"lineNum":"  169","line":""},
{"lineNum":"  170","line":"fn testSentinel() !void {"},
{"lineNum":"  171","line":"    try testing.expectEqual(@as(u8, 0), sentinel([:0]u8).?);"},
{"lineNum":"  172","line":"    try testing.expectEqual(@as(u8, 0), sentinel([*:0]u8).?);"},
{"lineNum":"  173","line":"    try testing.expectEqual(@as(u8, 0), sentinel([5:0]u8).?);"},
{"lineNum":"  174","line":"    try testing.expectEqual(@as(u8, 0), sentinel(*const [5:0]u8).?);"},
{"lineNum":"  175","line":""},
{"lineNum":"  176","line":"    try testing.expect(sentinel([]u8) == null);"},
{"lineNum":"  177","line":"    try testing.expect(sentinel([*]u8) == null);"},
{"lineNum":"  178","line":"    try testing.expect(sentinel([5]u8) == null);"},
{"lineNum":"  179","line":"    try testing.expect(sentinel(*const [5]u8) == null);"},
{"lineNum":"  180","line":"}"},
{"lineNum":"  181","line":""},
{"lineNum":"  182","line":"/// Given a \"memory span\" type, returns the same type except with the given sentinel value."},
{"lineNum":"  183","line":"pub fn Sentinel(comptime T: type, comptime sentinel_val: Elem(T)) type {"},
{"lineNum":"  184","line":"    switch (@typeInfo(T)) {"},
{"lineNum":"  185","line":"        .Pointer => |info| switch (info.size) {"},
{"lineNum":"  186","line":"            .One => switch (@typeInfo(info.child)) {"},
{"lineNum":"  187","line":"                .Array => |array_info| return @Type(.{"},
{"lineNum":"  188","line":"                    .Pointer = .{"},
{"lineNum":"  189","line":"                        .size = info.size,"},
{"lineNum":"  190","line":"                        .is_const = info.is_const,"},
{"lineNum":"  191","line":"                        .is_volatile = info.is_volatile,"},
{"lineNum":"  192","line":"                        .alignment = info.alignment,"},
{"lineNum":"  193","line":"                        .address_space = info.address_space,"},
{"lineNum":"  194","line":"                        .child = @Type(.{"},
{"lineNum":"  195","line":"                            .Array = .{"},
{"lineNum":"  196","line":"                                .len = array_info.len,"},
{"lineNum":"  197","line":"                                .child = array_info.child,"},
{"lineNum":"  198","line":"                                .sentinel = @as(?*const anyopaque, @ptrCast(&sentinel_val)),"},
{"lineNum":"  199","line":"                            },"},
{"lineNum":"  200","line":"                        }),"},
{"lineNum":"  201","line":"                        .is_allowzero = info.is_allowzero,"},
{"lineNum":"  202","line":"                        .sentinel = info.sentinel,"},
{"lineNum":"  203","line":"                    },"},
{"lineNum":"  204","line":"                }),"},
{"lineNum":"  205","line":"                else => {},"},
{"lineNum":"  206","line":"            },"},
{"lineNum":"  207","line":"            .Many, .Slice => return @Type(.{"},
{"lineNum":"  208","line":"                .Pointer = .{"},
{"lineNum":"  209","line":"                    .size = info.size,"},
{"lineNum":"  210","line":"                    .is_const = info.is_const,"},
{"lineNum":"  211","line":"                    .is_volatile = info.is_volatile,"},
{"lineNum":"  212","line":"                    .alignment = info.alignment,"},
{"lineNum":"  213","line":"                    .address_space = info.address_space,"},
{"lineNum":"  214","line":"                    .child = info.child,"},
{"lineNum":"  215","line":"                    .is_allowzero = info.is_allowzero,"},
{"lineNum":"  216","line":"                    .sentinel = @as(?*const anyopaque, @ptrCast(&sentinel_val)),"},
{"lineNum":"  217","line":"                },"},
{"lineNum":"  218","line":"            }),"},
{"lineNum":"  219","line":"            else => {},"},
{"lineNum":"  220","line":"        },"},
{"lineNum":"  221","line":"        .Optional => |info| switch (@typeInfo(info.child)) {"},
{"lineNum":"  222","line":"            .Pointer => |ptr_info| switch (ptr_info.size) {"},
{"lineNum":"  223","line":"                .Many => return @Type(.{"},
{"lineNum":"  224","line":"                    .Optional = .{"},
{"lineNum":"  225","line":"                        .child = @Type(.{"},
{"lineNum":"  226","line":"                            .Pointer = .{"},
{"lineNum":"  227","line":"                                .size = ptr_info.size,"},
{"lineNum":"  228","line":"                                .is_const = ptr_info.is_const,"},
{"lineNum":"  229","line":"                                .is_volatile = ptr_info.is_volatile,"},
{"lineNum":"  230","line":"                                .alignment = ptr_info.alignment,"},
{"lineNum":"  231","line":"                                .address_space = ptr_info.address_space,"},
{"lineNum":"  232","line":"                                .child = ptr_info.child,"},
{"lineNum":"  233","line":"                                .is_allowzero = ptr_info.is_allowzero,"},
{"lineNum":"  234","line":"                                .sentinel = @as(?*const anyopaque, @ptrCast(&sentinel_val)),"},
{"lineNum":"  235","line":"                            },"},
{"lineNum":"  236","line":"                        }),"},
{"lineNum":"  237","line":"                    },"},
{"lineNum":"  238","line":"                }),"},
{"lineNum":"  239","line":"                else => {},"},
{"lineNum":"  240","line":"            },"},
{"lineNum":"  241","line":"            else => {},"},
{"lineNum":"  242","line":"        },"},
{"lineNum":"  243","line":"        else => {},"},
{"lineNum":"  244","line":"    }"},
{"lineNum":"  245","line":"    @compileError(\"Unable to derive a sentinel pointer type from \" ++ @typeName(T));"},
{"lineNum":"  246","line":"}"},
{"lineNum":"  247","line":""},
{"lineNum":"  248","line":"pub const assumeSentinel = @compileError(\"This function has been removed, consider using std.mem.sliceTo() or if needed a @ptrCast()\");"},
{"lineNum":"  249","line":""},
{"lineNum":"  250","line":"pub fn containerLayout(comptime T: type) Type.ContainerLayout {"},
{"lineNum":"  251","line":"    return switch (@typeInfo(T)) {"},
{"lineNum":"  252","line":"        .Struct => |info| info.layout,"},
{"lineNum":"  253","line":"        .Union => |info| info.layout,"},
{"lineNum":"  254","line":"        else => @compileError(\"expected struct or union type, found \'\" ++ @typeName(T) ++ \"\'\"),"},
{"lineNum":"  255","line":"    };"},
{"lineNum":"  256","line":"}"},
{"lineNum":"  257","line":""},
{"lineNum":"  258","line":"test \"std.meta.containerLayout\" {"},
{"lineNum":"  259","line":"    const S1 = struct {};"},
{"lineNum":"  260","line":"    const S2 = packed struct {};"},
{"lineNum":"  261","line":"    const S3 = extern struct {};"},
{"lineNum":"  262","line":"    const U1 = union {"},
{"lineNum":"  263","line":"        a: u8,"},
{"lineNum":"  264","line":"    };"},
{"lineNum":"  265","line":"    const U2 = packed union {"},
{"lineNum":"  266","line":"        a: u8,"},
{"lineNum":"  267","line":"    };"},
{"lineNum":"  268","line":"    const U3 = extern union {"},
{"lineNum":"  269","line":"        a: u8,"},
{"lineNum":"  270","line":"    };"},
{"lineNum":"  271","line":""},
{"lineNum":"  272","line":"    try testing.expect(containerLayout(S1) == .Auto);"},
{"lineNum":"  273","line":"    try testing.expect(containerLayout(S2) == .Packed);"},
{"lineNum":"  274","line":"    try testing.expect(containerLayout(S3) == .Extern);"},
{"lineNum":"  275","line":"    try testing.expect(containerLayout(U1) == .Auto);"},
{"lineNum":"  276","line":"    try testing.expect(containerLayout(U2) == .Packed);"},
{"lineNum":"  277","line":"    try testing.expect(containerLayout(U3) == .Extern);"},
{"lineNum":"  278","line":"}"},
{"lineNum":"  279","line":""},
{"lineNum":"  280","line":"/// Instead of this function, prefer to use e.g. `@typeInfo(foo).Struct.decls`"},
{"lineNum":"  281","line":"/// directly when you know what kind of type it is."},
{"lineNum":"  282","line":"pub fn declarations(comptime T: type) []const Type.Declaration {"},
{"lineNum":"  283","line":"    return switch (@typeInfo(T)) {"},
{"lineNum":"  284","line":"        .Struct => |info| info.decls,"},
{"lineNum":"  285","line":"        .Enum => |info| info.decls,"},
{"lineNum":"  286","line":"        .Union => |info| info.decls,"},
{"lineNum":"  287","line":"        .Opaque => |info| info.decls,"},
{"lineNum":"  288","line":"        else => @compileError(\"Expected struct, enum, union, or opaque type, found \'\" ++ @typeName(T) ++ \"\'\"),"},
{"lineNum":"  289","line":"    };"},
{"lineNum":"  290","line":"}"},
{"lineNum":"  291","line":""},
{"lineNum":"  292","line":"test \"std.meta.declarations\" {"},
{"lineNum":"  293","line":"    const E1 = enum {"},
{"lineNum":"  294","line":"        A,"},
{"lineNum":"  295","line":""},
{"lineNum":"  296","line":"        pub fn a() void {}"},
{"lineNum":"  297","line":"    };"},
{"lineNum":"  298","line":"    const S1 = struct {"},
{"lineNum":"  299","line":"        pub fn a() void {}"},
{"lineNum":"  300","line":"    };"},
{"lineNum":"  301","line":"    const U1 = union {"},
{"lineNum":"  302","line":"        a: u8,"},
{"lineNum":"  303","line":""},
{"lineNum":"  304","line":"        pub fn a() void {}"},
{"lineNum":"  305","line":"    };"},
{"lineNum":"  306","line":"    const O1 = opaque {"},
{"lineNum":"  307","line":"        pub fn a() void {}"},
{"lineNum":"  308","line":"    };"},
{"lineNum":"  309","line":""},
{"lineNum":"  310","line":"    const decls = comptime [_][]const Type.Declaration{"},
{"lineNum":"  311","line":"        declarations(E1),"},
{"lineNum":"  312","line":"        declarations(S1),"},
{"lineNum":"  313","line":"        declarations(U1),"},
{"lineNum":"  314","line":"        declarations(O1),"},
{"lineNum":"  315","line":"    };"},
{"lineNum":"  316","line":""},
{"lineNum":"  317","line":"    inline for (decls) |decl| {"},
{"lineNum":"  318","line":"        try testing.expect(decl.len == 1);"},
{"lineNum":"  319","line":"        try testing.expect(comptime mem.eql(u8, decl[0].name, \"a\"));"},
{"lineNum":"  320","line":"    }"},
{"lineNum":"  321","line":"}"},
{"lineNum":"  322","line":""},
{"lineNum":"  323","line":"pub fn declarationInfo(comptime T: type, comptime decl_name: []const u8) Type.Declaration {"},
{"lineNum":"  324","line":"    inline for (comptime declarations(T)) |decl| {"},
{"lineNum":"  325","line":"        if (comptime mem.eql(u8, decl.name, decl_name))"},
{"lineNum":"  326","line":"            return decl;"},
{"lineNum":"  327","line":"    }"},
{"lineNum":"  328","line":""},
{"lineNum":"  329","line":"    @compileError(\"\'\" ++ @typeName(T) ++ \"\' has no declaration \'\" ++ decl_name ++ \"\'\");"},
{"lineNum":"  330","line":"}"},
{"lineNum":"  331","line":""},
{"lineNum":"  332","line":"test \"std.meta.declarationInfo\" {"},
{"lineNum":"  333","line":"    const E1 = enum {"},
{"lineNum":"  334","line":"        A,"},
{"lineNum":"  335","line":""},
{"lineNum":"  336","line":"        pub fn a() void {}"},
{"lineNum":"  337","line":"    };"},
{"lineNum":"  338","line":"    const S1 = struct {"},
{"lineNum":"  339","line":"        pub fn a() void {}"},
{"lineNum":"  340","line":"    };"},
{"lineNum":"  341","line":"    const U1 = union {"},
{"lineNum":"  342","line":"        a: u8,"},
{"lineNum":"  343","line":""},
{"lineNum":"  344","line":"        pub fn a() void {}"},
{"lineNum":"  345","line":"    };"},
{"lineNum":"  346","line":""},
{"lineNum":"  347","line":"    const infos = comptime [_]Type.Declaration{"},
{"lineNum":"  348","line":"        declarationInfo(E1, \"a\"),"},
{"lineNum":"  349","line":"        declarationInfo(S1, \"a\"),"},
{"lineNum":"  350","line":"        declarationInfo(U1, \"a\"),"},
{"lineNum":"  351","line":"    };"},
{"lineNum":"  352","line":""},
{"lineNum":"  353","line":"    inline for (infos) |info| {"},
{"lineNum":"  354","line":"        try testing.expect(comptime mem.eql(u8, info.name, \"a\"));"},
{"lineNum":"  355","line":"    }"},
{"lineNum":"  356","line":"}"},
{"lineNum":"  357","line":"pub fn fields(comptime T: type) switch (@typeInfo(T)) {"},
{"lineNum":"  358","line":"    .Struct => []const Type.StructField,"},
{"lineNum":"  359","line":"    .Union => []const Type.UnionField,"},
{"lineNum":"  360","line":"    .ErrorSet => []const Type.Error,"},
{"lineNum":"  361","line":"    .Enum => []const Type.EnumField,"},
{"lineNum":"  362","line":"    else => @compileError(\"Expected struct, union, error set or enum type, found \'\" ++ @typeName(T) ++ \"\'\"),"},
{"lineNum":"  363","line":"} {"},
{"lineNum":"  364","line":"    return switch (@typeInfo(T)) {"},
{"lineNum":"  365","line":"        .Struct => |info| info.fields,"},
{"lineNum":"  366","line":"        .Union => |info| info.fields,"},
{"lineNum":"  367","line":"        .Enum => |info| info.fields,"},
{"lineNum":"  368","line":"        .ErrorSet => |errors| errors.?, // must be non global error set"},
{"lineNum":"  369","line":"        else => @compileError(\"Expected struct, union, error set or enum type, found \'\" ++ @typeName(T) ++ \"\'\"),"},
{"lineNum":"  370","line":"    };"},
{"lineNum":"  371","line":"}"},
{"lineNum":"  372","line":""},
{"lineNum":"  373","line":"test \"std.meta.fields\" {"},
{"lineNum":"  374","line":"    const E1 = enum {"},
{"lineNum":"  375","line":"        A,"},
{"lineNum":"  376","line":"    };"},
{"lineNum":"  377","line":"    const E2 = error{A};"},
{"lineNum":"  378","line":"    const S1 = struct {"},
{"lineNum":"  379","line":"        a: u8,"},
{"lineNum":"  380","line":"    };"},
{"lineNum":"  381","line":"    const U1 = union {"},
{"lineNum":"  382","line":"        a: u8,"},
{"lineNum":"  383","line":"    };"},
{"lineNum":"  384","line":""},
{"lineNum":"  385","line":"    const e1f = comptime fields(E1);"},
{"lineNum":"  386","line":"    const e2f = comptime fields(E2);"},
{"lineNum":"  387","line":"    const sf = comptime fields(S1);"},
{"lineNum":"  388","line":"    const uf = comptime fields(U1);"},
{"lineNum":"  389","line":""},
{"lineNum":"  390","line":"    try testing.expect(e1f.len == 1);"},
{"lineNum":"  391","line":"    try testing.expect(e2f.len == 1);"},
{"lineNum":"  392","line":"    try testing.expect(sf.len == 1);"},
{"lineNum":"  393","line":"    try testing.expect(uf.len == 1);"},
{"lineNum":"  394","line":"    try testing.expect(mem.eql(u8, e1f[0].name, \"A\"));"},
{"lineNum":"  395","line":"    try testing.expect(mem.eql(u8, e2f[0].name, \"A\"));"},
{"lineNum":"  396","line":"    try testing.expect(mem.eql(u8, sf[0].name, \"a\"));"},
{"lineNum":"  397","line":"    try testing.expect(mem.eql(u8, uf[0].name, \"a\"));"},
{"lineNum":"  398","line":"    try testing.expect(comptime sf[0].type == u8);"},
{"lineNum":"  399","line":"    try testing.expect(comptime uf[0].type == u8);"},
{"lineNum":"  400","line":"}"},
{"lineNum":"  401","line":""},
{"lineNum":"  402","line":"pub fn fieldInfo(comptime T: type, comptime field: FieldEnum(T)) switch (@typeInfo(T)) {"},
{"lineNum":"  403","line":"    .Struct => Type.StructField,"},
{"lineNum":"  404","line":"    .Union => Type.UnionField,"},
{"lineNum":"  405","line":"    .ErrorSet => Type.Error,"},
{"lineNum":"  406","line":"    .Enum => Type.EnumField,"},
{"lineNum":"  407","line":"    else => @compileError(\"Expected struct, union, error set or enum type, found \'\" ++ @typeName(T) ++ \"\'\"),"},
{"lineNum":"  408","line":"} {"},
{"lineNum":"  409","line":"    return fields(T)[@intFromEnum(field)];"},
{"lineNum":"  410","line":"}"},
{"lineNum":"  411","line":""},
{"lineNum":"  412","line":"test \"std.meta.fieldInfo\" {"},
{"lineNum":"  413","line":"    const E1 = enum {"},
{"lineNum":"  414","line":"        A,"},
{"lineNum":"  415","line":"    };"},
{"lineNum":"  416","line":"    const E2 = error{A};"},
{"lineNum":"  417","line":"    const S1 = struct {"},
{"lineNum":"  418","line":"        a: u8,"},
{"lineNum":"  419","line":"    };"},
{"lineNum":"  420","line":"    const U1 = union {"},
{"lineNum":"  421","line":"        a: u8,"},
{"lineNum":"  422","line":"    };"},
{"lineNum":"  423","line":""},
{"lineNum":"  424","line":"    const e1f = fieldInfo(E1, .A);"},
{"lineNum":"  425","line":"    const e2f = fieldInfo(E2, .A);"},
{"lineNum":"  426","line":"    const sf = fieldInfo(S1, .a);"},
{"lineNum":"  427","line":"    const uf = fieldInfo(U1, .a);"},
{"lineNum":"  428","line":""},
{"lineNum":"  429","line":"    try testing.expect(mem.eql(u8, e1f.name, \"A\"));"},
{"lineNum":"  430","line":"    try testing.expect(mem.eql(u8, e2f.name, \"A\"));"},
{"lineNum":"  431","line":"    try testing.expect(mem.eql(u8, sf.name, \"a\"));"},
{"lineNum":"  432","line":"    try testing.expect(mem.eql(u8, uf.name, \"a\"));"},
{"lineNum":"  433","line":"    try testing.expect(comptime sf.type == u8);"},
{"lineNum":"  434","line":"    try testing.expect(comptime uf.type == u8);"},
{"lineNum":"  435","line":"}"},
{"lineNum":"  436","line":""},
{"lineNum":"  437","line":"pub fn FieldType(comptime T: type, comptime field: FieldEnum(T)) type {"},
{"lineNum":"  438","line":"    if (@typeInfo(T) != .Struct and @typeInfo(T) != .Union) {"},
{"lineNum":"  439","line":"        @compileError(\"Expected struct or union, found \'\" ++ @typeName(T) ++ \"\'\");"},
{"lineNum":"  440","line":"    }"},
{"lineNum":"  441","line":""},
{"lineNum":"  442","line":"    return fieldInfo(T, field).type;"},
{"lineNum":"  443","line":"}"},
{"lineNum":"  444","line":""},
{"lineNum":"  445","line":"test \"std.meta.FieldType\" {"},
{"lineNum":"  446","line":"    const S = struct {"},
{"lineNum":"  447","line":"        a: u8,"},
{"lineNum":"  448","line":"        b: u16,"},
{"lineNum":"  449","line":"    };"},
{"lineNum":"  450","line":""},
{"lineNum":"  451","line":"    const U = union {"},
{"lineNum":"  452","line":"        c: u32,"},
{"lineNum":"  453","line":"        d: *const u8,"},
{"lineNum":"  454","line":"    };"},
{"lineNum":"  455","line":""},
{"lineNum":"  456","line":"    try testing.expect(FieldType(S, .a) == u8);"},
{"lineNum":"  457","line":"    try testing.expect(FieldType(S, .b) == u16);"},
{"lineNum":"  458","line":""},
{"lineNum":"  459","line":"    try testing.expect(FieldType(U, .c) == u32);"},
{"lineNum":"  460","line":"    try testing.expect(FieldType(U, .d) == *const u8);"},
{"lineNum":"  461","line":"}"},
{"lineNum":"  462","line":""},
{"lineNum":"  463","line":"pub fn fieldNames(comptime T: type) *const [fields(T).len][]const u8 {"},
{"lineNum":"  464","line":"    return comptime blk: {"},
{"lineNum":"  465","line":"        const fieldInfos = fields(T);"},
{"lineNum":"  466","line":"        var names: [fieldInfos.len][]const u8 = undefined;"},
{"lineNum":"  467","line":"        for (fieldInfos, 0..) |field, i| {"},
{"lineNum":"  468","line":"            names[i] = field.name;"},
{"lineNum":"  469","line":"        }"},
{"lineNum":"  470","line":"        break :blk &names;"},
{"lineNum":"  471","line":"    };"},
{"lineNum":"  472","line":"}"},
{"lineNum":"  473","line":""},
{"lineNum":"  474","line":"test \"std.meta.fieldNames\" {"},
{"lineNum":"  475","line":"    const E1 = enum { A, B };"},
{"lineNum":"  476","line":"    const E2 = error{A};"},
{"lineNum":"  477","line":"    const S1 = struct {"},
{"lineNum":"  478","line":"        a: u8,"},
{"lineNum":"  479","line":"    };"},
{"lineNum":"  480","line":"    const U1 = union {"},
{"lineNum":"  481","line":"        a: u8,"},
{"lineNum":"  482","line":"        b: void,"},
{"lineNum":"  483","line":"    };"},
{"lineNum":"  484","line":""},
{"lineNum":"  485","line":"    const e1names = fieldNames(E1);"},
{"lineNum":"  486","line":"    const e2names = fieldNames(E2);"},
{"lineNum":"  487","line":"    const s1names = fieldNames(S1);"},
{"lineNum":"  488","line":"    const u1names = fieldNames(U1);"},
{"lineNum":"  489","line":""},
{"lineNum":"  490","line":"    try testing.expect(e1names.len == 2);"},
{"lineNum":"  491","line":"    try testing.expectEqualSlices(u8, e1names[0], \"A\");"},
{"lineNum":"  492","line":"    try testing.expectEqualSlices(u8, e1names[1], \"B\");"},
{"lineNum":"  493","line":"    try testing.expect(e2names.len == 1);"},
{"lineNum":"  494","line":"    try testing.expectEqualSlices(u8, e2names[0], \"A\");"},
{"lineNum":"  495","line":"    try testing.expect(s1names.len == 1);"},
{"lineNum":"  496","line":"    try testing.expectEqualSlices(u8, s1names[0], \"a\");"},
{"lineNum":"  497","line":"    try testing.expect(u1names.len == 2);"},
{"lineNum":"  498","line":"    try testing.expectEqualSlices(u8, u1names[0], \"a\");"},
{"lineNum":"  499","line":"    try testing.expectEqualSlices(u8, u1names[1], \"b\");"},
{"lineNum":"  500","line":"}"},
{"lineNum":"  501","line":""},
{"lineNum":"  502","line":"/// Given an enum or error set type, returns a pointer to an array containing all tags for that"},
{"lineNum":"  503","line":"/// enum or error set."},
{"lineNum":"  504","line":"pub fn tags(comptime T: type) *const [fields(T).len]T {"},
{"lineNum":"  505","line":"    return comptime blk: {"},
{"lineNum":"  506","line":"        const fieldInfos = fields(T);"},
{"lineNum":"  507","line":"        var res: [fieldInfos.len]T = undefined;"},
{"lineNum":"  508","line":"        for (fieldInfos, 0..) |field, i| {"},
{"lineNum":"  509","line":"            res[i] = @field(T, field.name);"},
{"lineNum":"  510","line":"        }"},
{"lineNum":"  511","line":"        break :blk &res;"},
{"lineNum":"  512","line":"    };"},
{"lineNum":"  513","line":"}"},
{"lineNum":"  514","line":""},
{"lineNum":"  515","line":"test \"std.meta.tags\" {"},
{"lineNum":"  516","line":"    const E1 = enum { A, B };"},
{"lineNum":"  517","line":"    const E2 = error{A};"},
{"lineNum":"  518","line":""},
{"lineNum":"  519","line":"    const e1_tags = tags(E1);"},
{"lineNum":"  520","line":"    const e2_tags = tags(E2);"},
{"lineNum":"  521","line":""},
{"lineNum":"  522","line":"    try testing.expect(e1_tags.len == 2);"},
{"lineNum":"  523","line":"    try testing.expectEqual(E1.A, e1_tags[0]);"},
{"lineNum":"  524","line":"    try testing.expectEqual(E1.B, e1_tags[1]);"},
{"lineNum":"  525","line":"    try testing.expect(e2_tags.len == 1);"},
{"lineNum":"  526","line":"    try testing.expectEqual(E2.A, e2_tags[0]);"},
{"lineNum":"  527","line":"}"},
{"lineNum":"  528","line":""},
{"lineNum":"  529","line":"/// Returns an enum with a variant named after each field of `T`."},
{"lineNum":"  530","line":"pub fn FieldEnum(comptime T: type) type {"},
{"lineNum":"  531","line":"    const field_infos = fields(T);"},
{"lineNum":"  532","line":""},
{"lineNum":"  533","line":"    if (field_infos.len == 0) {"},
{"lineNum":"  534","line":"        return @Type(.{"},
{"lineNum":"  535","line":"            .Enum = .{"},
{"lineNum":"  536","line":"                .tag_type = u0,"},
{"lineNum":"  537","line":"                .fields = &.{},"},
{"lineNum":"  538","line":"                .decls = &.{},"},
{"lineNum":"  539","line":"                .is_exhaustive = true,"},
{"lineNum":"  540","line":"            },"},
{"lineNum":"  541","line":"        });"},
{"lineNum":"  542","line":"    }"},
{"lineNum":"  543","line":""},
{"lineNum":"  544","line":"    if (@typeInfo(T) == .Union) {"},
{"lineNum":"  545","line":"        if (@typeInfo(T).Union.tag_type) |tag_type| {"},
{"lineNum":"  546","line":"            for (std.enums.values(tag_type), 0..) |v, i| {"},
{"lineNum":"  547","line":"                if (@intFromEnum(v) != i) break; // enum values not consecutive"},
{"lineNum":"  548","line":"                if (!std.mem.eql(u8, @tagName(v), field_infos[i].name)) break; // fields out of order"},
{"lineNum":"  549","line":"            } else {"},
{"lineNum":"  550","line":"                return tag_type;"},
{"lineNum":"  551","line":"            }"},
{"lineNum":"  552","line":"        }"},
{"lineNum":"  553","line":"    }"},
{"lineNum":"  554","line":""},
{"lineNum":"  555","line":"    var enumFields: [field_infos.len]std.builtin.Type.EnumField = undefined;"},
{"lineNum":"  556","line":"    var decls = [_]std.builtin.Type.Declaration{};"},
{"lineNum":"  557","line":"    inline for (field_infos, 0..) |field, i| {"},
{"lineNum":"  558","line":"        enumFields[i] = .{"},
{"lineNum":"  559","line":"            .name = field.name,"},
{"lineNum":"  560","line":"            .value = i,"},
{"lineNum":"  561","line":"        };"},
{"lineNum":"  562","line":"    }"},
{"lineNum":"  563","line":"    return @Type(.{"},
{"lineNum":"  564","line":"        .Enum = .{"},
{"lineNum":"  565","line":"            .tag_type = std.math.IntFittingRange(0, field_infos.len - 1),"},
{"lineNum":"  566","line":"            .fields = &enumFields,"},
{"lineNum":"  567","line":"            .decls = &decls,"},
{"lineNum":"  568","line":"            .is_exhaustive = true,"},
{"lineNum":"  569","line":"        },"},
{"lineNum":"  570","line":"    });"},
{"lineNum":"  571","line":"}"},
{"lineNum":"  572","line":""},
{"lineNum":"  573","line":"fn expectEqualEnum(expected: anytype, actual: @TypeOf(expected)) !void {"},
{"lineNum":"  574","line":"    // TODO: https://github.com/ziglang/zig/issues/7419"},
{"lineNum":"  575","line":"    // testing.expectEqual(@typeInfo(expected).Enum, @typeInfo(actual).Enum);"},
{"lineNum":"  576","line":"    try testing.expectEqual("},
{"lineNum":"  577","line":"        @typeInfo(expected).Enum.tag_type,"},
{"lineNum":"  578","line":"        @typeInfo(actual).Enum.tag_type,"},
{"lineNum":"  579","line":"    );"},
{"lineNum":"  580","line":"    // For comparing decls and fields, we cannot use the meta eql function here"},
{"lineNum":"  581","line":"    // because the language does not guarantee that the slice pointers for field names"},
{"lineNum":"  582","line":"    // and decl names will be the same."},
{"lineNum":"  583","line":"    comptime {"},
{"lineNum":"  584","line":"        const expected_fields = @typeInfo(expected).Enum.fields;"},
{"lineNum":"  585","line":"        const actual_fields = @typeInfo(actual).Enum.fields;"},
{"lineNum":"  586","line":"        if (expected_fields.len != actual_fields.len) return error.FailedTest;"},
{"lineNum":"  587","line":"        for (expected_fields, 0..) |expected_field, i| {"},
{"lineNum":"  588","line":"            const actual_field = actual_fields[i];"},
{"lineNum":"  589","line":"            try testing.expectEqual(expected_field.value, actual_field.value);"},
{"lineNum":"  590","line":"            try testing.expectEqualStrings(expected_field.name, actual_field.name);"},
{"lineNum":"  591","line":"        }"},
{"lineNum":"  592","line":"    }"},
{"lineNum":"  593","line":"    comptime {"},
{"lineNum":"  594","line":"        const expected_decls = @typeInfo(expected).Enum.decls;"},
{"lineNum":"  595","line":"        const actual_decls = @typeInfo(actual).Enum.decls;"},
{"lineNum":"  596","line":"        if (expected_decls.len != actual_decls.len) return error.FailedTest;"},
{"lineNum":"  597","line":"        for (expected_decls, 0..) |expected_decl, i| {"},
{"lineNum":"  598","line":"            const actual_decl = actual_decls[i];"},
{"lineNum":"  599","line":"            try testing.expectEqualStrings(expected_decl.name, actual_decl.name);"},
{"lineNum":"  600","line":"        }"},
{"lineNum":"  601","line":"    }"},
{"lineNum":"  602","line":"    try testing.expectEqual("},
{"lineNum":"  603","line":"        @typeInfo(expected).Enum.is_exhaustive,"},
{"lineNum":"  604","line":"        @typeInfo(actual).Enum.is_exhaustive,"},
{"lineNum":"  605","line":"    );"},
{"lineNum":"  606","line":"}"},
{"lineNum":"  607","line":""},
{"lineNum":"  608","line":"test \"std.meta.FieldEnum\" {"},
{"lineNum":"  609","line":"    try expectEqualEnum(enum {}, FieldEnum(struct {}));"},
{"lineNum":"  610","line":"    try expectEqualEnum(enum { a }, FieldEnum(struct { a: u8 }));"},
{"lineNum":"  611","line":"    try expectEqualEnum(enum { a, b, c }, FieldEnum(struct { a: u8, b: void, c: f32 }));"},
{"lineNum":"  612","line":"    try expectEqualEnum(enum { a, b, c }, FieldEnum(union { a: u8, b: void, c: f32 }));"},
{"lineNum":"  613","line":""},
{"lineNum":"  614","line":"    const Tagged = union(enum) { a: u8, b: void, c: f32 };"},
{"lineNum":"  615","line":"    try testing.expectEqual(Tag(Tagged), FieldEnum(Tagged));"},
{"lineNum":"  616","line":""},
{"lineNum":"  617","line":"    const Tag2 = enum { b, c, a };"},
{"lineNum":"  618","line":"    const Tagged2 = union(Tag2) { a: u8, b: void, c: f32 };"},
{"lineNum":"  619","line":"    try testing.expect(Tag(Tagged2) != FieldEnum(Tagged2));"},
{"lineNum":"  620","line":""},
{"lineNum":"  621","line":"    const Tag3 = enum(u8) { a, b, c = 7 };"},
{"lineNum":"  622","line":"    const Tagged3 = union(Tag3) { a: u8, b: void, c: f32 };"},
{"lineNum":"  623","line":"    try testing.expect(Tag(Tagged3) != FieldEnum(Tagged3));"},
{"lineNum":"  624","line":"}"},
{"lineNum":"  625","line":""},
{"lineNum":"  626","line":"pub fn DeclEnum(comptime T: type) type {"},
{"lineNum":"  627","line":"    const fieldInfos = std.meta.declarations(T);"},
{"lineNum":"  628","line":"    var enumDecls: [fieldInfos.len]std.builtin.Type.EnumField = undefined;"},
{"lineNum":"  629","line":"    var decls = [_]std.builtin.Type.Declaration{};"},
{"lineNum":"  630","line":"    inline for (fieldInfos, 0..) |field, i| {"},
{"lineNum":"  631","line":"        enumDecls[i] = .{ .name = field.name, .value = i };"},
{"lineNum":"  632","line":"    }"},
{"lineNum":"  633","line":"    return @Type(.{"},
{"lineNum":"  634","line":"        .Enum = .{"},
{"lineNum":"  635","line":"            .tag_type = std.math.IntFittingRange(0, fieldInfos.len - 1),"},
{"lineNum":"  636","line":"            .fields = &enumDecls,"},
{"lineNum":"  637","line":"            .decls = &decls,"},
{"lineNum":"  638","line":"            .is_exhaustive = true,"},
{"lineNum":"  639","line":"        },"},
{"lineNum":"  640","line":"    });"},
{"lineNum":"  641","line":"}"},
{"lineNum":"  642","line":""},
{"lineNum":"  643","line":"test \"std.meta.DeclEnum\" {"},
{"lineNum":"  644","line":"    const A = struct {"},
{"lineNum":"  645","line":"        pub const a: u8 = 0;"},
{"lineNum":"  646","line":"    };"},
{"lineNum":"  647","line":"    const B = union {"},
{"lineNum":"  648","line":"        foo: void,"},
{"lineNum":"  649","line":""},
{"lineNum":"  650","line":"        pub const a: u8 = 0;"},
{"lineNum":"  651","line":"        pub const b: void = {};"},
{"lineNum":"  652","line":"        pub const c: f32 = 0;"},
{"lineNum":"  653","line":"    };"},
{"lineNum":"  654","line":"    const C = enum {"},
{"lineNum":"  655","line":"        bar,"},
{"lineNum":"  656","line":""},
{"lineNum":"  657","line":"        pub const a: u8 = 0;"},
{"lineNum":"  658","line":"        pub const b: void = {};"},
{"lineNum":"  659","line":"        pub const c: f32 = 0;"},
{"lineNum":"  660","line":"    };"},
{"lineNum":"  661","line":"    try expectEqualEnum(enum { a }, DeclEnum(A));"},
{"lineNum":"  662","line":"    try expectEqualEnum(enum { a, b, c }, DeclEnum(B));"},
{"lineNum":"  663","line":"    try expectEqualEnum(enum { a, b, c }, DeclEnum(C));"},
{"lineNum":"  664","line":"}"},
{"lineNum":"  665","line":""},
{"lineNum":"  666","line":"pub fn Tag(comptime T: type) type {"},
{"lineNum":"  667","line":"    return switch (@typeInfo(T)) {"},
{"lineNum":"  668","line":"        .Enum => |info| info.tag_type,"},
{"lineNum":"  669","line":"        .Union => |info| info.tag_type orelse @compileError(@typeName(T) ++ \" has no tag type\"),"},
{"lineNum":"  670","line":"        else => @compileError(\"expected enum or union type, found \'\" ++ @typeName(T) ++ \"\'\"),"},
{"lineNum":"  671","line":"    };"},
{"lineNum":"  672","line":"}"},
{"lineNum":"  673","line":""},
{"lineNum":"  674","line":"test \"std.meta.Tag\" {"},
{"lineNum":"  675","line":"    const E = enum(u8) {"},
{"lineNum":"  676","line":"        C = 33,"},
{"lineNum":"  677","line":"        D,"},
{"lineNum":"  678","line":"    };"},
{"lineNum":"  679","line":"    const U = union(E) {"},
{"lineNum":"  680","line":"        C: u8,"},
{"lineNum":"  681","line":"        D: u16,"},
{"lineNum":"  682","line":"    };"},
{"lineNum":"  683","line":""},
{"lineNum":"  684","line":"    try testing.expect(Tag(E) == u8);"},
{"lineNum":"  685","line":"    try testing.expect(Tag(U) == E);"},
{"lineNum":"  686","line":"}"},
{"lineNum":"  687","line":""},
{"lineNum":"  688","line":"///Returns the active tag of a tagged union"},
{"lineNum":"  689","line":"pub fn activeTag(u: anytype) Tag(@TypeOf(u)) {"},
{"lineNum":"  690","line":"    const T = @TypeOf(u);"},
{"lineNum":"  691","line":"    return @as(Tag(T), u);"},
{"lineNum":"  692","line":"}"},
{"lineNum":"  693","line":""},
{"lineNum":"  694","line":"test \"std.meta.activeTag\" {"},
{"lineNum":"  695","line":"    const UE = enum {"},
{"lineNum":"  696","line":"        Int,"},
{"lineNum":"  697","line":"        Float,"},
{"lineNum":"  698","line":"    };"},
{"lineNum":"  699","line":""},
{"lineNum":"  700","line":"    const U = union(UE) {"},
{"lineNum":"  701","line":"        Int: u32,"},
{"lineNum":"  702","line":"        Float: f32,"},
{"lineNum":"  703","line":"    };"},
{"lineNum":"  704","line":""},
{"lineNum":"  705","line":"    var u = U{ .Int = 32 };"},
{"lineNum":"  706","line":"    try testing.expect(activeTag(u) == UE.Int);"},
{"lineNum":"  707","line":""},
{"lineNum":"  708","line":"    u = U{ .Float = 112.9876 };"},
{"lineNum":"  709","line":"    try testing.expect(activeTag(u) == UE.Float);"},
{"lineNum":"  710","line":"}"},
{"lineNum":"  711","line":""},
{"lineNum":"  712","line":"const TagPayloadType = TagPayload;"},
{"lineNum":"  713","line":""},
{"lineNum":"  714","line":"pub fn TagPayloadByName(comptime U: type, comptime tag_name: []const u8) type {"},
{"lineNum":"  715","line":"    comptime debug.assert(trait.is(.Union)(U));"},
{"lineNum":"  716","line":""},
{"lineNum":"  717","line":"    const info = @typeInfo(U).Union;"},
{"lineNum":"  718","line":""},
{"lineNum":"  719","line":"    inline for (info.fields) |field_info| {"},
{"lineNum":"  720","line":"        if (comptime mem.eql(u8, field_info.name, tag_name))"},
{"lineNum":"  721","line":"            return field_info.type;"},
{"lineNum":"  722","line":"    }"},
{"lineNum":"  723","line":""},
{"lineNum":"  724","line":"    unreachable;"},
{"lineNum":"  725","line":"}"},
{"lineNum":"  726","line":""},
{"lineNum":"  727","line":"/// Given a tagged union type, and an enum, return the type of the union field"},
{"lineNum":"  728","line":"/// corresponding to the enum tag."},
{"lineNum":"  729","line":"pub fn TagPayload(comptime U: type, comptime tag: Tag(U)) type {"},
{"lineNum":"  730","line":"    return TagPayloadByName(U, @tagName(tag));"},
{"lineNum":"  731","line":"}"},
{"lineNum":"  732","line":""},
{"lineNum":"  733","line":"test \"std.meta.TagPayload\" {"},
{"lineNum":"  734","line":"    const Event = union(enum) {"},
{"lineNum":"  735","line":"        Moved: struct {"},
{"lineNum":"  736","line":"            from: i32,"},
{"lineNum":"  737","line":"            to: i32,"},
{"lineNum":"  738","line":"        },"},
{"lineNum":"  739","line":"    };"},
{"lineNum":"  740","line":"    const MovedEvent = TagPayload(Event, Event.Moved);"},
{"lineNum":"  741","line":"    var e: Event = undefined;"},
{"lineNum":"  742","line":"    try testing.expect(MovedEvent == @TypeOf(e.Moved));"},
{"lineNum":"  743","line":"}"},
{"lineNum":"  744","line":""},
{"lineNum":"  745","line":"/// Compares two of any type for equality. Containers are compared on a field-by-field basis,"},
{"lineNum":"  746","line":"/// where possible. Pointers are not followed."},
{"lineNum":"  747","line":"pub fn eql(a: anytype, b: @TypeOf(a)) bool {","class":"linePartCov","hits":"1","order":"3104","possible_hits":"2",},
{"lineNum":"  748","line":"    const T = @TypeOf(a);"},
{"lineNum":"  749","line":""},
{"lineNum":"  750","line":"    switch (@typeInfo(T)) {"},
{"lineNum":"  751","line":"        .Struct => |info| {"},
{"lineNum":"  752","line":"            inline for (info.fields) |field_info| {"},
{"lineNum":"  753","line":"                if (!eql(@field(a, field_info.name), @field(b, field_info.name))) return false;"},
{"lineNum":"  754","line":"            }"},
{"lineNum":"  755","line":"            return true;"},
{"lineNum":"  756","line":"        },"},
{"lineNum":"  757","line":"        .ErrorUnion => {"},
{"lineNum":"  758","line":"            if (a) |a_p| {"},
{"lineNum":"  759","line":"                if (b) |b_p| return eql(a_p, b_p) else |_| return false;"},
{"lineNum":"  760","line":"            } else |a_e| {"},
{"lineNum":"  761","line":"                if (b) |_| return false else |b_e| return a_e == b_e;"},
{"lineNum":"  762","line":"            }"},
{"lineNum":"  763","line":"        },"},
{"lineNum":"  764","line":"        .Union => |info| {"},
{"lineNum":"  765","line":"            if (info.tag_type) |UnionTag| {"},
{"lineNum":"  766","line":"                const tag_a = activeTag(a);"},
{"lineNum":"  767","line":"                const tag_b = activeTag(b);"},
{"lineNum":"  768","line":"                if (tag_a != tag_b) return false;"},
{"lineNum":"  769","line":""},
{"lineNum":"  770","line":"                inline for (info.fields) |field_info| {"},
{"lineNum":"  771","line":"                    if (@field(UnionTag, field_info.name) == tag_a) {"},
{"lineNum":"  772","line":"                        return eql(@field(a, field_info.name), @field(b, field_info.name));"},
{"lineNum":"  773","line":"                    }"},
{"lineNum":"  774","line":"                }"},
{"lineNum":"  775","line":"                return false;"},
{"lineNum":"  776","line":"            }"},
{"lineNum":"  777","line":""},
{"lineNum":"  778","line":"            @compileError(\"cannot compare untagged union type \" ++ @typeName(T));"},
{"lineNum":"  779","line":"        },"},
{"lineNum":"  780","line":"        .Array => {"},
{"lineNum":"  781","line":"            if (a.len != b.len) return false;"},
{"lineNum":"  782","line":"            for (a, 0..) |e, i|"},
{"lineNum":"  783","line":"                if (!eql(e, b[i])) return false;"},
{"lineNum":"  784","line":"            return true;"},
{"lineNum":"  785","line":"        },"},
{"lineNum":"  786","line":"        .Vector => |info| {"},
{"lineNum":"  787","line":"            var i: usize = 0;"},
{"lineNum":"  788","line":"            while (i < info.len) : (i += 1) {"},
{"lineNum":"  789","line":"                if (!eql(a[i], b[i])) return false;"},
{"lineNum":"  790","line":"            }"},
{"lineNum":"  791","line":"            return true;"},
{"lineNum":"  792","line":"        },"},
{"lineNum":"  793","line":"        .Pointer => |info| {"},
{"lineNum":"  794","line":"            return switch (info.size) {"},
{"lineNum":"  795","line":"                .One, .Many, .C => a == b,"},
{"lineNum":"  796","line":"                .Slice => a.ptr == b.ptr and a.len == b.len,"},
{"lineNum":"  797","line":"            };"},
{"lineNum":"  798","line":"        },"},
{"lineNum":"  799","line":"        .Optional => {"},
{"lineNum":"  800","line":"            if (a == null and b == null) return true;"},
{"lineNum":"  801","line":"            if (a == null or b == null) return false;"},
{"lineNum":"  802","line":"            return eql(a.?, b.?);"},
{"lineNum":"  803","line":"        },"},
{"lineNum":"  804","line":"        else => return a == b,","class":"linePartCov","hits":"1","order":"3105","possible_hits":"2",},
{"lineNum":"  805","line":"    }"},
{"lineNum":"  806","line":"}"},
{"lineNum":"  807","line":""},
{"lineNum":"  808","line":"test \"std.meta.eql\" {"},
{"lineNum":"  809","line":"    const S = struct {"},
{"lineNum":"  810","line":"        a: u32,"},
{"lineNum":"  811","line":"        b: f64,"},
{"lineNum":"  812","line":"        c: [5]u8,"},
{"lineNum":"  813","line":"    };"},
{"lineNum":"  814","line":""},
{"lineNum":"  815","line":"    const U = union(enum) {"},
{"lineNum":"  816","line":"        s: S,"},
{"lineNum":"  817","line":"        f: ?f32,"},
{"lineNum":"  818","line":"    };"},
{"lineNum":"  819","line":""},
{"lineNum":"  820","line":"    const s_1 = S{"},
{"lineNum":"  821","line":"        .a = 134,"},
{"lineNum":"  822","line":"        .b = 123.3,"},
{"lineNum":"  823","line":"        .c = \"12345\".*,"},
{"lineNum":"  824","line":"    };"},
{"lineNum":"  825","line":""},
{"lineNum":"  826","line":"    var s_3 = S{"},
{"lineNum":"  827","line":"        .a = 134,"},
{"lineNum":"  828","line":"        .b = 123.3,"},
{"lineNum":"  829","line":"        .c = \"12345\".*,"},
{"lineNum":"  830","line":"    };"},
{"lineNum":"  831","line":""},
{"lineNum":"  832","line":"    const u_1 = U{ .f = 24 };"},
{"lineNum":"  833","line":"    const u_2 = U{ .s = s_1 };"},
{"lineNum":"  834","line":"    const u_3 = U{ .f = 24 };"},
{"lineNum":"  835","line":""},
{"lineNum":"  836","line":"    try testing.expect(eql(s_1, s_3));"},
{"lineNum":"  837","line":"    try testing.expect(eql(&s_1, &s_1));"},
{"lineNum":"  838","line":"    try testing.expect(!eql(&s_1, &s_3));"},
{"lineNum":"  839","line":"    try testing.expect(eql(u_1, u_3));"},
{"lineNum":"  840","line":"    try testing.expect(!eql(u_1, u_2));"},
{"lineNum":"  841","line":""},
{"lineNum":"  842","line":"    var a1 = \"abcdef\".*;"},
{"lineNum":"  843","line":"    var a2 = \"abcdef\".*;"},
{"lineNum":"  844","line":"    var a3 = \"ghijkl\".*;"},
{"lineNum":"  845","line":""},
{"lineNum":"  846","line":"    try testing.expect(eql(a1, a2));"},
{"lineNum":"  847","line":"    try testing.expect(!eql(a1, a3));"},
{"lineNum":"  848","line":"    try testing.expect(!eql(a1[0..], a2[0..]));"},
{"lineNum":"  849","line":""},
{"lineNum":"  850","line":"    const EU = struct {"},
{"lineNum":"  851","line":"        fn tst(err: bool) !u8 {"},
{"lineNum":"  852","line":"            if (err) return error.Error;"},
{"lineNum":"  853","line":"            return @as(u8, 5);"},
{"lineNum":"  854","line":"        }"},
{"lineNum":"  855","line":"    };"},
{"lineNum":"  856","line":""},
{"lineNum":"  857","line":"    try testing.expect(eql(EU.tst(true), EU.tst(true)));"},
{"lineNum":"  858","line":"    try testing.expect(eql(EU.tst(false), EU.tst(false)));"},
{"lineNum":"  859","line":"    try testing.expect(!eql(EU.tst(false), EU.tst(true)));"},
{"lineNum":"  860","line":""},
{"lineNum":"  861","line":"    const V = @Vector(4, u32);"},
{"lineNum":"  862","line":"    var v1: V = @splat(1);"},
{"lineNum":"  863","line":"    var v2: V = @splat(1);"},
{"lineNum":"  864","line":"    var v3: V = @splat(2);"},
{"lineNum":"  865","line":""},
{"lineNum":"  866","line":"    try testing.expect(eql(v1, v2));"},
{"lineNum":"  867","line":"    try testing.expect(!eql(v1, v3));"},
{"lineNum":"  868","line":"}"},
{"lineNum":"  869","line":""},
{"lineNum":"  870","line":"test \"intToEnum with error return\" {"},
{"lineNum":"  871","line":"    const E1 = enum {"},
{"lineNum":"  872","line":"        A,"},
{"lineNum":"  873","line":"    };"},
{"lineNum":"  874","line":"    const E2 = enum {"},
{"lineNum":"  875","line":"        A,"},
{"lineNum":"  876","line":"        B,"},
{"lineNum":"  877","line":"    };"},
{"lineNum":"  878","line":"    const E3 = enum(i8) { A, _ };"},
{"lineNum":"  879","line":""},
{"lineNum":"  880","line":"    var zero: u8 = 0;"},
{"lineNum":"  881","line":"    var one: u16 = 1;"},
{"lineNum":"  882","line":"    try testing.expect(intToEnum(E1, zero) catch unreachable == E1.A);"},
{"lineNum":"  883","line":"    try testing.expect(intToEnum(E2, one) catch unreachable == E2.B);"},
{"lineNum":"  884","line":"    try testing.expect(intToEnum(E3, zero) catch unreachable == E3.A);"},
{"lineNum":"  885","line":"    try testing.expect(intToEnum(E3, 127) catch unreachable == @as(E3, @enumFromInt(127)));"},
{"lineNum":"  886","line":"    try testing.expect(intToEnum(E3, -128) catch unreachable == @as(E3, @enumFromInt(-128)));"},
{"lineNum":"  887","line":"    try testing.expectError(error.InvalidEnumTag, intToEnum(E1, one));"},
{"lineNum":"  888","line":"    try testing.expectError(error.InvalidEnumTag, intToEnum(E3, 128));"},
{"lineNum":"  889","line":"    try testing.expectError(error.InvalidEnumTag, intToEnum(E3, -129));"},
{"lineNum":"  890","line":"}"},
{"lineNum":"  891","line":""},
{"lineNum":"  892","line":"pub const IntToEnumError = error{InvalidEnumTag};"},
{"lineNum":"  893","line":""},
{"lineNum":"  894","line":"pub fn intToEnum(comptime EnumTag: type, tag_int: anytype) IntToEnumError!EnumTag {"},
{"lineNum":"  895","line":"    const enum_info = @typeInfo(EnumTag).Enum;"},
{"lineNum":"  896","line":""},
{"lineNum":"  897","line":"    if (!enum_info.is_exhaustive) {"},
{"lineNum":"  898","line":"        if (std.math.cast(enum_info.tag_type, tag_int)) |tag| {"},
{"lineNum":"  899","line":"            return @as(EnumTag, @enumFromInt(tag));"},
{"lineNum":"  900","line":"        }"},
{"lineNum":"  901","line":"        return error.InvalidEnumTag;"},
{"lineNum":"  902","line":"    }"},
{"lineNum":"  903","line":""},
{"lineNum":"  904","line":"    inline for (enum_info.fields) |f| {"},
{"lineNum":"  905","line":"        const this_tag_value = @field(EnumTag, f.name);"},
{"lineNum":"  906","line":"        if (tag_int == @intFromEnum(this_tag_value)) {"},
{"lineNum":"  907","line":"            return this_tag_value;"},
{"lineNum":"  908","line":"        }"},
{"lineNum":"  909","line":"    }"},
{"lineNum":"  910","line":"    return error.InvalidEnumTag;"},
{"lineNum":"  911","line":"}"},
{"lineNum":"  912","line":""},
{"lineNum":"  913","line":"/// Given a type and a name, return the field index according to source order."},
{"lineNum":"  914","line":"/// Returns `null` if the field is not found."},
{"lineNum":"  915","line":"pub fn fieldIndex(comptime T: type, comptime name: []const u8) ?comptime_int {"},
{"lineNum":"  916","line":"    inline for (fields(T), 0..) |field, i| {"},
{"lineNum":"  917","line":"        if (mem.eql(u8, field.name, name))"},
{"lineNum":"  918","line":"            return i;"},
{"lineNum":"  919","line":"    }"},
{"lineNum":"  920","line":"    return null;"},
{"lineNum":"  921","line":"}"},
{"lineNum":"  922","line":""},
{"lineNum":"  923","line":"pub const refAllDecls = @compileError(\"refAllDecls has been moved from std.meta to std.testing\");"},
{"lineNum":"  924","line":""},
{"lineNum":"  925","line":"/// Returns a slice of pointers to public declarations of a namespace."},
{"lineNum":"  926","line":"pub fn declList(comptime Namespace: type, comptime Decl: type) []const *const Decl {"},
{"lineNum":"  927","line":"    const S = struct {"},
{"lineNum":"  928","line":"        fn declNameLessThan(context: void, lhs: *const Decl, rhs: *const Decl) bool {"},
{"lineNum":"  929","line":"            _ = context;"},
{"lineNum":"  930","line":"            return mem.lessThan(u8, lhs.name, rhs.name);"},
{"lineNum":"  931","line":"        }"},
{"lineNum":"  932","line":"    };"},
{"lineNum":"  933","line":"    comptime {"},
{"lineNum":"  934","line":"        const decls = declarations(Namespace);"},
{"lineNum":"  935","line":"        var array: [decls.len]*const Decl = undefined;"},
{"lineNum":"  936","line":"        for (decls, 0..) |decl, i| {"},
{"lineNum":"  937","line":"            array[i] = &@field(Namespace, decl.name);"},
{"lineNum":"  938","line":"        }"},
{"lineNum":"  939","line":"        mem.sort(*const Decl, &array, {}, S.declNameLessThan);"},
{"lineNum":"  940","line":"        return &array;"},
{"lineNum":"  941","line":"    }"},
{"lineNum":"  942","line":"}"},
{"lineNum":"  943","line":""},
{"lineNum":"  944","line":"pub const IntType = @compileError(\"replaced by std.meta.Int\");"},
{"lineNum":"  945","line":""},
{"lineNum":"  946","line":"pub fn Int(comptime signedness: std.builtin.Signedness, comptime bit_count: u16) type {"},
{"lineNum":"  947","line":"    return @Type(.{"},
{"lineNum":"  948","line":"        .Int = .{"},
{"lineNum":"  949","line":"            .signedness = signedness,"},
{"lineNum":"  950","line":"            .bits = bit_count,"},
{"lineNum":"  951","line":"        },"},
{"lineNum":"  952","line":"    });"},
{"lineNum":"  953","line":"}"},
{"lineNum":"  954","line":""},
{"lineNum":"  955","line":"pub fn Float(comptime bit_count: u8) type {"},
{"lineNum":"  956","line":"    return @Type(.{"},
{"lineNum":"  957","line":"        .Float = .{ .bits = bit_count },"},
{"lineNum":"  958","line":"    });"},
{"lineNum":"  959","line":"}"},
{"lineNum":"  960","line":""},
{"lineNum":"  961","line":"test \"std.meta.Float\" {"},
{"lineNum":"  962","line":"    try testing.expectEqual(f16, Float(16));"},
{"lineNum":"  963","line":"    try testing.expectEqual(f32, Float(32));"},
{"lineNum":"  964","line":"    try testing.expectEqual(f64, Float(64));"},
{"lineNum":"  965","line":"    try testing.expectEqual(f128, Float(128));"},
{"lineNum":"  966","line":"}"},
{"lineNum":"  967","line":""},
{"lineNum":"  968","line":"/// For a given function type, returns a tuple type which fields will"},
{"lineNum":"  969","line":"/// correspond to the argument types."},
{"lineNum":"  970","line":"///"},
{"lineNum":"  971","line":"/// Examples:"},
{"lineNum":"  972","line":"/// - `ArgsTuple(fn() void)`  `tuple { }`"},
{"lineNum":"  973","line":"/// - `ArgsTuple(fn(a: u32) u32)`  `tuple { u32 }`"},
{"lineNum":"  974","line":"/// - `ArgsTuple(fn(a: u32, b: f16) noreturn)`  `tuple { u32, f16 }`"},
{"lineNum":"  975","line":"pub fn ArgsTuple(comptime Function: type) type {"},
{"lineNum":"  976","line":"    const info = @typeInfo(Function);"},
{"lineNum":"  977","line":"    if (info != .Fn)"},
{"lineNum":"  978","line":"        @compileError(\"ArgsTuple expects a function type\");"},
{"lineNum":"  979","line":""},
{"lineNum":"  980","line":"    const function_info = info.Fn;"},
{"lineNum":"  981","line":"    if (function_info.is_var_args)"},
{"lineNum":"  982","line":"        @compileError(\"Cannot create ArgsTuple for variadic function\");"},
{"lineNum":"  983","line":""},
{"lineNum":"  984","line":"    var argument_field_list: [function_info.params.len]type = undefined;"},
{"lineNum":"  985","line":"    inline for (function_info.params, 0..) |arg, i| {"},
{"lineNum":"  986","line":"        const T = arg.type orelse @compileError(\"cannot create ArgsTuple for function with an \'anytype\' parameter\");"},
{"lineNum":"  987","line":"        argument_field_list[i] = T;"},
{"lineNum":"  988","line":"    }"},
{"lineNum":"  989","line":""},
{"lineNum":"  990","line":"    return CreateUniqueTuple(argument_field_list.len, argument_field_list);"},
{"lineNum":"  991","line":"}"},
{"lineNum":"  992","line":""},
{"lineNum":"  993","line":"/// For a given anonymous list of types, returns a new tuple type"},
{"lineNum":"  994","line":"/// with those types as fields."},
{"lineNum":"  995","line":"///"},
{"lineNum":"  996","line":"/// Examples:"},
{"lineNum":"  997","line":"/// - `Tuple(&[_]type {})`  `tuple { }`"},
{"lineNum":"  998","line":"/// - `Tuple(&[_]type {f32})`  `tuple { f32 }`"},
{"lineNum":"  999","line":"/// - `Tuple(&[_]type {f32,u32})`  `tuple { f32, u32 }`"},
{"lineNum":" 1000","line":"pub fn Tuple(comptime types: []const type) type {"},
{"lineNum":" 1001","line":"    return CreateUniqueTuple(types.len, types[0..types.len].*);"},
{"lineNum":" 1002","line":"}"},
{"lineNum":" 1003","line":""},
{"lineNum":" 1004","line":"fn CreateUniqueTuple(comptime N: comptime_int, comptime types: [N]type) type {"},
{"lineNum":" 1005","line":"    var tuple_fields: [types.len]std.builtin.Type.StructField = undefined;"},
{"lineNum":" 1006","line":"    inline for (types, 0..) |T, i| {"},
{"lineNum":" 1007","line":"        @setEvalBranchQuota(10_000);"},
{"lineNum":" 1008","line":"        var num_buf: [128]u8 = undefined;"},
{"lineNum":" 1009","line":"        tuple_fields[i] = .{"},
{"lineNum":" 1010","line":"            .name = std.fmt.bufPrint(&num_buf, \"{d}\", .{i}) catch unreachable,"},
{"lineNum":" 1011","line":"            .type = T,"},
{"lineNum":" 1012","line":"            .default_value = null,"},
{"lineNum":" 1013","line":"            .is_comptime = false,"},
{"lineNum":" 1014","line":"            .alignment = if (@sizeOf(T) > 0) @alignOf(T) else 0,"},
{"lineNum":" 1015","line":"        };"},
{"lineNum":" 1016","line":"    }"},
{"lineNum":" 1017","line":""},
{"lineNum":" 1018","line":"    return @Type(.{"},
{"lineNum":" 1019","line":"        .Struct = .{"},
{"lineNum":" 1020","line":"            .is_tuple = true,"},
{"lineNum":" 1021","line":"            .layout = .Auto,"},
{"lineNum":" 1022","line":"            .decls = &.{},"},
{"lineNum":" 1023","line":"            .fields = &tuple_fields,"},
{"lineNum":" 1024","line":"        },"},
{"lineNum":" 1025","line":"    });"},
{"lineNum":" 1026","line":"}"},
{"lineNum":" 1027","line":""},
{"lineNum":" 1028","line":"const TupleTester = struct {"},
{"lineNum":" 1029","line":"    fn assertTypeEqual(comptime Expected: type, comptime Actual: type) void {"},
{"lineNum":" 1030","line":"        if (Expected != Actual)"},
{"lineNum":" 1031","line":"            @compileError(\"Expected type \" ++ @typeName(Expected) ++ \", but got type \" ++ @typeName(Actual));"},
{"lineNum":" 1032","line":"    }"},
{"lineNum":" 1033","line":""},
{"lineNum":" 1034","line":"    fn assertTuple(comptime expected: anytype, comptime Actual: type) void {"},
{"lineNum":" 1035","line":"        const info = @typeInfo(Actual);"},
{"lineNum":" 1036","line":"        if (info != .Struct)"},
{"lineNum":" 1037","line":"            @compileError(\"Expected struct type\");"},
{"lineNum":" 1038","line":"        if (!info.Struct.is_tuple)"},
{"lineNum":" 1039","line":"            @compileError(\"Struct type must be a tuple type\");"},
{"lineNum":" 1040","line":""},
{"lineNum":" 1041","line":"        const fields_list = std.meta.fields(Actual);"},
{"lineNum":" 1042","line":"        if (expected.len != fields_list.len)"},
{"lineNum":" 1043","line":"            @compileError(\"Argument count mismatch\");"},
{"lineNum":" 1044","line":""},
{"lineNum":" 1045","line":"        inline for (fields_list, 0..) |fld, i| {"},
{"lineNum":" 1046","line":"            if (expected[i] != fld.type) {"},
{"lineNum":" 1047","line":"                @compileError(\"Field \" ++ fld.name ++ \" expected to be type \" ++ @typeName(expected[i]) ++ \", but was type \" ++ @typeName(fld.type));"},
{"lineNum":" 1048","line":"            }"},
{"lineNum":" 1049","line":"        }"},
{"lineNum":" 1050","line":"    }"},
{"lineNum":" 1051","line":"};"},
{"lineNum":" 1052","line":""},
{"lineNum":" 1053","line":"test \"ArgsTuple\" {"},
{"lineNum":" 1054","line":"    TupleTester.assertTuple(.{}, ArgsTuple(fn () void));"},
{"lineNum":" 1055","line":"    TupleTester.assertTuple(.{u32}, ArgsTuple(fn (a: u32) []const u8));"},
{"lineNum":" 1056","line":"    TupleTester.assertTuple(.{ u32, f16 }, ArgsTuple(fn (a: u32, b: f16) noreturn));"},
{"lineNum":" 1057","line":"    TupleTester.assertTuple(.{ u32, f16, []const u8, void }, ArgsTuple(fn (a: u32, b: f16, c: []const u8, void) noreturn));"},
{"lineNum":" 1058","line":"    TupleTester.assertTuple(.{u32}, ArgsTuple(fn (comptime a: u32) []const u8));"},
{"lineNum":" 1059","line":"}"},
{"lineNum":" 1060","line":""},
{"lineNum":" 1061","line":"test \"Tuple\" {"},
{"lineNum":" 1062","line":"    TupleTester.assertTuple(.{}, Tuple(&[_]type{}));"},
{"lineNum":" 1063","line":"    TupleTester.assertTuple(.{u32}, Tuple(&[_]type{u32}));"},
{"lineNum":" 1064","line":"    TupleTester.assertTuple(.{ u32, f16 }, Tuple(&[_]type{ u32, f16 }));"},
{"lineNum":" 1065","line":"    TupleTester.assertTuple(.{ u32, f16, []const u8, void }, Tuple(&[_]type{ u32, f16, []const u8, void }));"},
{"lineNum":" 1066","line":"}"},
{"lineNum":" 1067","line":""},
{"lineNum":" 1068","line":"test \"Tuple deduplication\" {"},
{"lineNum":" 1069","line":"    const T1 = std.meta.Tuple(&.{ u32, f32, i8 });"},
{"lineNum":" 1070","line":"    const T2 = std.meta.Tuple(&.{ u32, f32, i8 });"},
{"lineNum":" 1071","line":"    const T3 = std.meta.Tuple(&.{ u32, f32, i7 });"},
{"lineNum":" 1072","line":""},
{"lineNum":" 1073","line":"    if (T1 != T2) {"},
{"lineNum":" 1074","line":"        @compileError(\"std.meta.Tuple doesn\'t deduplicate tuple types.\");"},
{"lineNum":" 1075","line":"    }"},
{"lineNum":" 1076","line":"    if (T1 == T3) {"},
{"lineNum":" 1077","line":"        @compileError(\"std.meta.Tuple fails to generate different types.\");"},
{"lineNum":" 1078","line":"    }"},
{"lineNum":" 1079","line":"}"},
{"lineNum":" 1080","line":""},
{"lineNum":" 1081","line":"test \"ArgsTuple forwarding\" {"},
{"lineNum":" 1082","line":"    const T1 = std.meta.Tuple(&.{ u32, f32, i8 });"},
{"lineNum":" 1083","line":"    const T2 = std.meta.ArgsTuple(fn (u32, f32, i8) void);"},
{"lineNum":" 1084","line":"    const T3 = std.meta.ArgsTuple(fn (u32, f32, i8) callconv(.C) noreturn);"},
{"lineNum":" 1085","line":""},
{"lineNum":" 1086","line":"    if (T1 != T2) {"},
{"lineNum":" 1087","line":"        @compileError(\"std.meta.ArgsTuple produces different types than std.meta.Tuple\");"},
{"lineNum":" 1088","line":"    }"},
{"lineNum":" 1089","line":"    if (T1 != T3) {"},
{"lineNum":" 1090","line":"        @compileError(\"std.meta.ArgsTuple produces different types for the same argument lists.\");"},
{"lineNum":" 1091","line":"    }"},
{"lineNum":" 1092","line":"}"},
{"lineNum":" 1093","line":""},
{"lineNum":" 1094","line":"/// TODO: https://github.com/ziglang/zig/issues/425"},
{"lineNum":" 1095","line":"pub fn globalOption(comptime name: []const u8, comptime T: type) ?T {"},
{"lineNum":" 1096","line":"    if (!@hasDecl(root, name))"},
{"lineNum":" 1097","line":"        return null;"},
{"lineNum":" 1098","line":"    return @as(T, @field(root, name));"},
{"lineNum":" 1099","line":"}"},
{"lineNum":" 1100","line":""},
{"lineNum":" 1101","line":"/// Returns whether `error_union` contains an error."},
{"lineNum":" 1102","line":"pub fn isError(error_union: anytype) bool {"},
{"lineNum":" 1103","line":"    return if (error_union) |_| false else |_| true;"},
{"lineNum":" 1104","line":"}"},
{"lineNum":" 1105","line":""},
{"lineNum":" 1106","line":"test \"isError\" {"},
{"lineNum":" 1107","line":"    try std.testing.expect(isError(math.absInt(@as(i8, -128))));"},
{"lineNum":" 1108","line":"    try std.testing.expect(!isError(math.absInt(@as(i8, -127))));"},
{"lineNum":" 1109","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test", "date" : "2024-04-26 16:14:49", "instrumented" : 2, "covered" : 2,};
var merged_data = [];
