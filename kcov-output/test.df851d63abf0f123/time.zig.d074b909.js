var data = {lines:[
{"lineNum":"    1","line":"const std = @import(\"std.zig\");"},
{"lineNum":"    2","line":"const builtin = @import(\"builtin\");"},
{"lineNum":"    3","line":"const assert = std.debug.assert;"},
{"lineNum":"    4","line":"const testing = std.testing;"},
{"lineNum":"    5","line":"const os = std.os;"},
{"lineNum":"    6","line":"const math = std.math;"},
{"lineNum":"    7","line":""},
{"lineNum":"    8","line":"pub const epoch = @import(\"time/epoch.zig\");"},
{"lineNum":"    9","line":""},
{"lineNum":"   10","line":"/// Spurious wakeups are possible and no precision of timing is guaranteed."},
{"lineNum":"   11","line":"pub fn sleep(nanoseconds: u64) void {"},
{"lineNum":"   12","line":"    // TODO: opting out of async sleeping?"},
{"lineNum":"   13","line":"    if (std.io.is_async) {"},
{"lineNum":"   14","line":"        return std.event.Loop.instance.?.sleep(nanoseconds);"},
{"lineNum":"   15","line":"    }"},
{"lineNum":"   16","line":""},
{"lineNum":"   17","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":"   18","line":"        const big_ms_from_ns = nanoseconds / ns_per_ms;"},
{"lineNum":"   19","line":"        const ms = math.cast(os.windows.DWORD, big_ms_from_ns) orelse math.maxInt(os.windows.DWORD);"},
{"lineNum":"   20","line":"        os.windows.kernel32.Sleep(ms);"},
{"lineNum":"   21","line":"        return;"},
{"lineNum":"   22","line":"    }"},
{"lineNum":"   23","line":""},
{"lineNum":"   24","line":"    if (builtin.os.tag == .wasi) {"},
{"lineNum":"   25","line":"        const w = std.os.wasi;"},
{"lineNum":"   26","line":"        const userdata: w.userdata_t = 0x0123_45678;"},
{"lineNum":"   27","line":"        const clock = w.subscription_clock_t{"},
{"lineNum":"   28","line":"            .id = w.CLOCK.MONOTONIC,"},
{"lineNum":"   29","line":"            .timeout = nanoseconds,"},
{"lineNum":"   30","line":"            .precision = 0,"},
{"lineNum":"   31","line":"            .flags = 0,"},
{"lineNum":"   32","line":"        };"},
{"lineNum":"   33","line":"        const in = w.subscription_t{"},
{"lineNum":"   34","line":"            .userdata = userdata,"},
{"lineNum":"   35","line":"            .u = w.subscription_u_t{"},
{"lineNum":"   36","line":"                .tag = w.EVENTTYPE_CLOCK,"},
{"lineNum":"   37","line":"                .u = w.subscription_u_u_t{"},
{"lineNum":"   38","line":"                    .clock = clock,"},
{"lineNum":"   39","line":"                },"},
{"lineNum":"   40","line":"            },"},
{"lineNum":"   41","line":"        };"},
{"lineNum":"   42","line":""},
{"lineNum":"   43","line":"        var event: w.event_t = undefined;"},
{"lineNum":"   44","line":"        var nevents: usize = undefined;"},
{"lineNum":"   45","line":"        _ = w.poll_oneoff(&in, &event, 1, &nevents);"},
{"lineNum":"   46","line":"        return;"},
{"lineNum":"   47","line":"    }"},
{"lineNum":"   48","line":""},
{"lineNum":"   49","line":"    if (builtin.os.tag == .uefi) {"},
{"lineNum":"   50","line":"        const boot_services = os.uefi.system_table.boot_services.?;"},
{"lineNum":"   51","line":"        const us_from_ns = nanoseconds / ns_per_us;"},
{"lineNum":"   52","line":"        const us = math.cast(usize, us_from_ns) orelse math.maxInt(usize);"},
{"lineNum":"   53","line":"        _ = boot_services.stall(us);"},
{"lineNum":"   54","line":"        return;"},
{"lineNum":"   55","line":"    }"},
{"lineNum":"   56","line":""},
{"lineNum":"   57","line":"    const s = nanoseconds / ns_per_s;"},
{"lineNum":"   58","line":"    const ns = nanoseconds % ns_per_s;"},
{"lineNum":"   59","line":"    std.os.nanosleep(s, ns);"},
{"lineNum":"   60","line":"}"},
{"lineNum":"   61","line":""},
{"lineNum":"   62","line":"test \"sleep\" {"},
{"lineNum":"   63","line":"    sleep(1);"},
{"lineNum":"   64","line":"}"},
{"lineNum":"   65","line":""},
{"lineNum":"   66","line":"/// Get a calendar timestamp, in seconds, relative to UTC 1970-01-01."},
{"lineNum":"   67","line":"/// Precision of timing depends on the hardware and operating system."},
{"lineNum":"   68","line":"/// The return value is signed because it is possible to have a date that is"},
{"lineNum":"   69","line":"/// before the epoch."},
{"lineNum":"   70","line":"/// See `std.os.clock_gettime` for a POSIX timestamp."},
{"lineNum":"   71","line":"pub fn timestamp() i64 {"},
{"lineNum":"   72","line":"    return @divFloor(milliTimestamp(), ms_per_s);"},
{"lineNum":"   73","line":"}"},
{"lineNum":"   74","line":""},
{"lineNum":"   75","line":"/// Get a calendar timestamp, in milliseconds, relative to UTC 1970-01-01."},
{"lineNum":"   76","line":"/// Precision of timing depends on the hardware and operating system."},
{"lineNum":"   77","line":"/// The return value is signed because it is possible to have a date that is"},
{"lineNum":"   78","line":"/// before the epoch."},
{"lineNum":"   79","line":"/// See `std.os.clock_gettime` for a POSIX timestamp."},
{"lineNum":"   80","line":"pub fn milliTimestamp() i64 {"},
{"lineNum":"   81","line":"    return @as(i64, @intCast(@divFloor(nanoTimestamp(), ns_per_ms)));"},
{"lineNum":"   82","line":"}"},
{"lineNum":"   83","line":""},
{"lineNum":"   84","line":"/// Get a calendar timestamp, in microseconds, relative to UTC 1970-01-01."},
{"lineNum":"   85","line":"/// Precision of timing depends on the hardware and operating system."},
{"lineNum":"   86","line":"/// The return value is signed because it is possible to have a date that is"},
{"lineNum":"   87","line":"/// before the epoch."},
{"lineNum":"   88","line":"/// See `std.os.clock_gettime` for a POSIX timestamp."},
{"lineNum":"   89","line":"pub fn microTimestamp() i64 {"},
{"lineNum":"   90","line":"    return @as(i64, @intCast(@divFloor(nanoTimestamp(), ns_per_us)));"},
{"lineNum":"   91","line":"}"},
{"lineNum":"   92","line":""},
{"lineNum":"   93","line":"/// Get a calendar timestamp, in nanoseconds, relative to UTC 1970-01-01."},
{"lineNum":"   94","line":"/// Precision of timing depends on the hardware and operating system."},
{"lineNum":"   95","line":"/// On Windows this has a maximum granularity of 100 nanoseconds."},
{"lineNum":"   96","line":"/// The return value is signed because it is possible to have a date that is"},
{"lineNum":"   97","line":"/// before the epoch."},
{"lineNum":"   98","line":"/// See `std.os.clock_gettime` for a POSIX timestamp."},
{"lineNum":"   99","line":"pub fn nanoTimestamp() i128 {"},
{"lineNum":"  100","line":"    if (builtin.os.tag == .windows) {"},
{"lineNum":"  101","line":"        // FileTime has a granularity of 100 nanoseconds and uses the NTFS/Windows epoch,"},
{"lineNum":"  102","line":"        // which is 1601-01-01."},
{"lineNum":"  103","line":"        const epoch_adj = epoch.windows * (ns_per_s / 100);"},
{"lineNum":"  104","line":"        var ft: os.windows.FILETIME = undefined;"},
{"lineNum":"  105","line":"        os.windows.kernel32.GetSystemTimeAsFileTime(&ft);"},
{"lineNum":"  106","line":"        const ft64 = (@as(u64, ft.dwHighDateTime) << 32) | ft.dwLowDateTime;"},
{"lineNum":"  107","line":"        return @as(i128, @as(i64, @bitCast(ft64)) + epoch_adj) * 100;"},
{"lineNum":"  108","line":"    }"},
{"lineNum":"  109","line":""},
{"lineNum":"  110","line":"    if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":"  111","line":"        var ns: os.wasi.timestamp_t = undefined;"},
{"lineNum":"  112","line":"        const err = os.wasi.clock_time_get(os.wasi.CLOCK.REALTIME, 1, &ns);"},
{"lineNum":"  113","line":"        assert(err == .SUCCESS);"},
{"lineNum":"  114","line":"        return ns;"},
{"lineNum":"  115","line":"    }"},
{"lineNum":"  116","line":""},
{"lineNum":"  117","line":"    var ts: os.timespec = undefined;"},
{"lineNum":"  118","line":"    os.clock_gettime(os.CLOCK.REALTIME, &ts) catch |err| switch (err) {"},
{"lineNum":"  119","line":"        error.UnsupportedClock, error.Unexpected => return 0, // \"Precision of timing depends on hardware and OS\"."},
{"lineNum":"  120","line":"    };"},
{"lineNum":"  121","line":"    return (@as(i128, ts.tv_sec) * ns_per_s) + ts.tv_nsec;"},
{"lineNum":"  122","line":"}"},
{"lineNum":"  123","line":""},
{"lineNum":"  124","line":"test \"timestamp\" {"},
{"lineNum":"  125","line":"    const margin = ns_per_ms * 50;"},
{"lineNum":"  126","line":""},
{"lineNum":"  127","line":"    const time_0 = milliTimestamp();"},
{"lineNum":"  128","line":"    sleep(ns_per_ms);"},
{"lineNum":"  129","line":"    const time_1 = milliTimestamp();"},
{"lineNum":"  130","line":"    const interval = time_1 - time_0;"},
{"lineNum":"  131","line":"    try testing.expect(interval > 0);"},
{"lineNum":"  132","line":"    // Tests should not depend on timings: skip test if outside margin."},
{"lineNum":"  133","line":"    if (!(interval < margin)) return error.SkipZigTest;"},
{"lineNum":"  134","line":"}"},
{"lineNum":"  135","line":""},
{"lineNum":"  136","line":"// Divisions of a nanosecond."},
{"lineNum":"  137","line":"pub const ns_per_us = 1000;"},
{"lineNum":"  138","line":"pub const ns_per_ms = 1000 * ns_per_us;"},
{"lineNum":"  139","line":"pub const ns_per_s = 1000 * ns_per_ms;"},
{"lineNum":"  140","line":"pub const ns_per_min = 60 * ns_per_s;"},
{"lineNum":"  141","line":"pub const ns_per_hour = 60 * ns_per_min;"},
{"lineNum":"  142","line":"pub const ns_per_day = 24 * ns_per_hour;"},
{"lineNum":"  143","line":"pub const ns_per_week = 7 * ns_per_day;"},
{"lineNum":"  144","line":""},
{"lineNum":"  145","line":"// Divisions of a microsecond."},
{"lineNum":"  146","line":"pub const us_per_ms = 1000;"},
{"lineNum":"  147","line":"pub const us_per_s = 1000 * us_per_ms;"},
{"lineNum":"  148","line":"pub const us_per_min = 60 * us_per_s;"},
{"lineNum":"  149","line":"pub const us_per_hour = 60 * us_per_min;"},
{"lineNum":"  150","line":"pub const us_per_day = 24 * us_per_hour;"},
{"lineNum":"  151","line":"pub const us_per_week = 7 * us_per_day;"},
{"lineNum":"  152","line":""},
{"lineNum":"  153","line":"// Divisions of a millisecond."},
{"lineNum":"  154","line":"pub const ms_per_s = 1000;"},
{"lineNum":"  155","line":"pub const ms_per_min = 60 * ms_per_s;"},
{"lineNum":"  156","line":"pub const ms_per_hour = 60 * ms_per_min;"},
{"lineNum":"  157","line":"pub const ms_per_day = 24 * ms_per_hour;"},
{"lineNum":"  158","line":"pub const ms_per_week = 7 * ms_per_day;"},
{"lineNum":"  159","line":""},
{"lineNum":"  160","line":"// Divisions of a second."},
{"lineNum":"  161","line":"pub const s_per_min = 60;"},
{"lineNum":"  162","line":"pub const s_per_hour = s_per_min * 60;"},
{"lineNum":"  163","line":"pub const s_per_day = s_per_hour * 24;"},
{"lineNum":"  164","line":"pub const s_per_week = s_per_day * 7;"},
{"lineNum":"  165","line":""},
{"lineNum":"  166","line":"/// An Instant represents a timestamp with respect to the currently"},
{"lineNum":"  167","line":"/// executing program that ticks during suspend and can be used to"},
{"lineNum":"  168","line":"/// record elapsed time unlike `nanoTimestamp`."},
{"lineNum":"  169","line":"///"},
{"lineNum":"  170","line":"/// It tries to sample the system\'s fastest and most precise timer available."},
{"lineNum":"  171","line":"/// It also tries to be monotonic, but this is not a guarantee due to OS/hardware bugs."},
{"lineNum":"  172","line":"/// If you need monotonic readings for elapsed time, consider `Timer` instead."},
{"lineNum":"  173","line":"pub const Instant = struct {"},
{"lineNum":"  174","line":"    timestamp: if (is_posix) os.timespec else u64,"},
{"lineNum":"  175","line":""},
{"lineNum":"  176","line":"    // true if we should use clock_gettime()"},
{"lineNum":"  177","line":"    const is_posix = switch (builtin.os.tag) {"},
{"lineNum":"  178","line":"        .wasi => builtin.link_libc,"},
{"lineNum":"  179","line":"        .windows => false,"},
{"lineNum":"  180","line":"        else => true,"},
{"lineNum":"  181","line":"    };"},
{"lineNum":"  182","line":""},
{"lineNum":"  183","line":"    /// Queries the system for the current moment of time as an Instant."},
{"lineNum":"  184","line":"    /// This is not guaranteed to be monotonic or steadily increasing, but for most implementations it is."},
{"lineNum":"  185","line":"    /// Returns `error.Unsupported` when a suitable clock is not detected."},
{"lineNum":"  186","line":"    pub fn now() error{Unsupported}!Instant {","class":"lineCov","hits":"1","order":"400","possible_hits":"1",},
{"lineNum":"  187","line":"        // QPC on windows doesn\'t fail on >= XP/2000 and includes time suspended."},
{"lineNum":"  188","line":"        if (builtin.os.tag == .windows) {"},
{"lineNum":"  189","line":"            return Instant{ .timestamp = os.windows.QueryPerformanceCounter() };"},
{"lineNum":"  190","line":"        }"},
{"lineNum":"  191","line":""},
{"lineNum":"  192","line":"        // On WASI without libc, use clock_time_get directly."},
{"lineNum":"  193","line":"        if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":"  194","line":"            var ns: os.wasi.timestamp_t = undefined;"},
{"lineNum":"  195","line":"            const rc = os.wasi.clock_time_get(os.wasi.CLOCK.MONOTONIC, 1, &ns);"},
{"lineNum":"  196","line":"            if (rc != .SUCCESS) return error.Unsupported;"},
{"lineNum":"  197","line":"            return Instant{ .timestamp = ns };"},
{"lineNum":"  198","line":"        }"},
{"lineNum":"  199","line":""},
{"lineNum":"  200","line":"        // On darwin, use UPTIME_RAW instead of MONOTONIC as it ticks while suspended."},
{"lineNum":"  201","line":"        // On linux, use BOOTTIME instead of MONOTONIC as it ticks while suspended."},
{"lineNum":"  202","line":"        // On freebsd derivatives, use MONOTONIC_FAST as currently there\'s no precision tradeoff."},
{"lineNum":"  203","line":"        // On other posix systems, MONOTONIC is generally the fastest and ticks while suspended."},
{"lineNum":"  204","line":"        const clock_id = switch (builtin.os.tag) {"},
{"lineNum":"  205","line":"            .macos, .ios, .tvos, .watchos => os.CLOCK.UPTIME_RAW,"},
{"lineNum":"  206","line":"            .freebsd, .dragonfly => os.CLOCK.MONOTONIC_FAST,"},
{"lineNum":"  207","line":"            .linux => os.CLOCK.BOOTTIME,"},
{"lineNum":"  208","line":"            else => os.CLOCK.MONOTONIC,"},
{"lineNum":"  209","line":"        };"},
{"lineNum":"  210","line":""},
{"lineNum":"  211","line":"        var ts: os.timespec = undefined;","class":"lineCov","hits":"1","order":"401","possible_hits":"1",},
{"lineNum":"  212","line":"        os.clock_gettime(clock_id, &ts) catch return error.Unsupported;","class":"lineCov","hits":"2","order":"402","possible_hits":"2",},
{"lineNum":"  213","line":"        return Instant{ .timestamp = ts };","class":"lineCov","hits":"2","order":"478","possible_hits":"2",},
{"lineNum":"  214","line":"    }"},
{"lineNum":"  215","line":""},
{"lineNum":"  216","line":"    /// Quickly compares two instances between each other."},
{"lineNum":"  217","line":"    pub fn order(self: Instant, other: Instant) std.math.Order {","class":"lineCov","hits":"1","order":"539","possible_hits":"1",},
{"lineNum":"  218","line":"        // windows and wasi timestamps are in u64 which is easily comparible"},
{"lineNum":"  219","line":"        if (!is_posix) {"},
{"lineNum":"  220","line":"            return std.math.order(self.timestamp, other.timestamp);"},
{"lineNum":"  221","line":"        }"},
{"lineNum":"  222","line":""},
{"lineNum":"  223","line":"        var ord = std.math.order(self.timestamp.tv_sec, other.timestamp.tv_sec);","class":"lineCov","hits":"1","order":"540","possible_hits":"1",},
{"lineNum":"  224","line":"        if (ord == .eq) {","class":"lineCov","hits":"1","order":"544","possible_hits":"1",},
{"lineNum":"  225","line":"            ord = std.math.order(self.timestamp.tv_nsec, other.timestamp.tv_nsec);","class":"lineCov","hits":"1","order":"545","possible_hits":"1",},
{"lineNum":"  226","line":"        }"},
{"lineNum":"  227","line":"        return ord;","class":"lineCov","hits":"1","order":"549","possible_hits":"1",},
{"lineNum":"  228","line":"    }"},
{"lineNum":"  229","line":""},
{"lineNum":"  230","line":"    /// Returns elapsed time in nanoseconds since the `earlier` Instant."},
{"lineNum":"  231","line":"    /// This assumes that the `earlier` Instant represents a moment in time before or equal to `self`."},
{"lineNum":"  232","line":"    /// This also assumes that the time that has passed between both Instants fits inside a u64 (~585 yrs)."},
{"lineNum":"  233","line":"    pub fn since(self: Instant, earlier: Instant) u64 {","class":"lineCov","hits":"1","order":"553","possible_hits":"1",},
{"lineNum":"  234","line":"        if (builtin.os.tag == .windows) {"},
{"lineNum":"  235","line":"            // We don\'t need to cache QPF as it\'s internally just a memory read to KUSER_SHARED_DATA"},
{"lineNum":"  236","line":"            // (a read-only page of info updated and mapped by the kernel to all processes):"},
{"lineNum":"  237","line":"            // https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddk/ns-ntddk-kuser_shared_data"},
{"lineNum":"  238","line":"            // https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/ntexapi_x/kuser_shared_data/index.htm"},
{"lineNum":"  239","line":"            const qpc = self.timestamp - earlier.timestamp;"},
{"lineNum":"  240","line":"            const qpf = os.windows.QueryPerformanceFrequency();"},
{"lineNum":"  241","line":""},
{"lineNum":"  242","line":"            // 10Mhz (1 qpc tick every 100ns) is a common enough QPF value that we can optimize on it."},
{"lineNum":"  243","line":"            // https://github.com/microsoft/STL/blob/785143a0c73f030238ef618890fd4d6ae2b3a3a0/stl/inc/chrono#L694-L701"},
{"lineNum":"  244","line":"            const common_qpf = 10_000_000;"},
{"lineNum":"  245","line":"            if (qpf == common_qpf) {"},
{"lineNum":"  246","line":"                return qpc * (ns_per_s / common_qpf);"},
{"lineNum":"  247","line":"            }"},
{"lineNum":"  248","line":""},
{"lineNum":"  249","line":"            // Convert to ns using fixed point."},
{"lineNum":"  250","line":"            const scale = @as(u64, std.time.ns_per_s << 32) / @as(u32, @intCast(qpf));"},
{"lineNum":"  251","line":"            const result = (@as(u96, qpc) * scale) >> 32;"},
{"lineNum":"  252","line":"            return @as(u64, @truncate(result));"},
{"lineNum":"  253","line":"        }"},
{"lineNum":"  254","line":""},
{"lineNum":"  255","line":"        // WASI timestamps are directly in nanoseconds"},
{"lineNum":"  256","line":"        if (builtin.os.tag == .wasi and !builtin.link_libc) {"},
{"lineNum":"  257","line":"            return self.timestamp - earlier.timestamp;"},
{"lineNum":"  258","line":"        }"},
{"lineNum":"  259","line":""},
{"lineNum":"  260","line":"        // Convert timespec diff to ns"},
{"lineNum":"  261","line":"        const seconds = @as(u64, @intCast(self.timestamp.tv_sec - earlier.timestamp.tv_sec));","class":"lineCov","hits":"2","order":"554","possible_hits":"2",},
{"lineNum":"  262","line":"        const elapsed = (seconds * ns_per_s) + @as(u32, @intCast(self.timestamp.tv_nsec));","class":"linePartCov","hits":"1","order":"555","possible_hits":"2",},
{"lineNum":"  263","line":"        return elapsed - @as(u32, @intCast(earlier.timestamp.tv_nsec));","class":"lineCov","hits":"1","order":"556","possible_hits":"1",},
{"lineNum":"  264","line":"    }"},
{"lineNum":"  265","line":"};"},
{"lineNum":"  266","line":""},
{"lineNum":"  267","line":"/// A monotonic, high performance timer."},
{"lineNum":"  268","line":"///"},
{"lineNum":"  269","line":"/// Timer.start() is used to initialize the timer"},
{"lineNum":"  270","line":"/// and gives the caller an opportunity to check for the existence of a supported clock."},
{"lineNum":"  271","line":"/// Once a supported clock is discovered,"},
{"lineNum":"  272","line":"/// it is assumed that it will be available for the duration of the Timer\'s use."},
{"lineNum":"  273","line":"///"},
{"lineNum":"  274","line":"/// Monotonicity is ensured by saturating on the most previous sample."},
{"lineNum":"  275","line":"/// This means that while timings reported are monotonic,"},
{"lineNum":"  276","line":"/// they\'re not guaranteed to tick at a steady rate as this is up to the underlying system."},
{"lineNum":"  277","line":"pub const Timer = struct {"},
{"lineNum":"  278","line":"    started: Instant,"},
{"lineNum":"  279","line":"    previous: Instant,"},
{"lineNum":"  280","line":""},
{"lineNum":"  281","line":"    pub const Error = error{TimerUnsupported};"},
{"lineNum":"  282","line":""},
{"lineNum":"  283","line":"    /// Initialize the timer by querying for a supported clock."},
{"lineNum":"  284","line":"    /// Returns `error.TimerUnsupported` when such a clock is unavailable."},
{"lineNum":"  285","line":"    /// This should only fail in hostile environments such as linux seccomp misuse."},
{"lineNum":"  286","line":"    pub fn start() Error!Timer {","class":"lineCov","hits":"1","order":"398","possible_hits":"1",},
{"lineNum":"  287","line":"        const current = Instant.now() catch return error.TimerUnsupported;","class":"lineCov","hits":"2","order":"399","possible_hits":"2",},
{"lineNum":"  288","line":"        return Timer{ .started = current, .previous = current };","class":"lineCov","hits":"2","order":"479","possible_hits":"2",},
{"lineNum":"  289","line":"    }"},
{"lineNum":"  290","line":""},
{"lineNum":"  291","line":"    /// Reads the timer value since start or the last reset in nanoseconds."},
{"lineNum":"  292","line":"    pub fn read(self: *Timer) u64 {","class":"lineCov","hits":"1","order":"534","possible_hits":"1",},
{"lineNum":"  293","line":"        const current = self.sample();","class":"lineCov","hits":"1","order":"535","possible_hits":"1",},
{"lineNum":"  294","line":"        return current.since(self.started);","class":"lineCov","hits":"1","order":"552","possible_hits":"1",},
{"lineNum":"  295","line":"    }"},
{"lineNum":"  296","line":""},
{"lineNum":"  297","line":"    /// Resets the timer value to 0/now."},
{"lineNum":"  298","line":"    pub fn reset(self: *Timer) void {"},
{"lineNum":"  299","line":"        const current = self.sample();"},
{"lineNum":"  300","line":"        self.started = current;"},
{"lineNum":"  301","line":"    }"},
{"lineNum":"  302","line":""},
{"lineNum":"  303","line":"    /// Returns the current value of the timer in nanoseconds, then resets it."},
{"lineNum":"  304","line":"    pub fn lap(self: *Timer) u64 {"},
{"lineNum":"  305","line":"        const current = self.sample();"},
{"lineNum":"  306","line":"        defer self.started = current;"},
{"lineNum":"  307","line":"        return current.since(self.started);"},
{"lineNum":"  308","line":"    }"},
{"lineNum":"  309","line":""},
{"lineNum":"  310","line":"    /// Returns an Instant sampled at the callsite that is"},
{"lineNum":"  311","line":"    /// guaranteed to be monotonic with respect to the timer\'s starting point."},
{"lineNum":"  312","line":"    fn sample(self: *Timer) Instant {","class":"lineCov","hits":"1","order":"536","possible_hits":"1",},
{"lineNum":"  313","line":"        const current = Instant.now() catch unreachable;","class":"lineCov","hits":"2","order":"537","possible_hits":"2",},
{"lineNum":"  314","line":"        if (current.order(self.previous) == .gt) {","class":"lineCov","hits":"1","order":"538","possible_hits":"1",},
{"lineNum":"  315","line":"            self.previous = current;","class":"lineCov","hits":"1","order":"550","possible_hits":"1",},
{"lineNum":"  316","line":"        }"},
{"lineNum":"  317","line":"        return self.previous;","class":"lineCov","hits":"1","order":"551","possible_hits":"1",},
{"lineNum":"  318","line":"    }"},
{"lineNum":"  319","line":"};"},
{"lineNum":"  320","line":""},
{"lineNum":"  321","line":"test \"Timer + Instant\" {"},
{"lineNum":"  322","line":"    const margin = ns_per_ms * 150;"},
{"lineNum":"  323","line":""},
{"lineNum":"  324","line":"    var timer = try Timer.start();"},
{"lineNum":"  325","line":"    sleep(10 * ns_per_ms);"},
{"lineNum":"  326","line":"    const time_0 = timer.read();"},
{"lineNum":"  327","line":"    try testing.expect(time_0 > 0);"},
{"lineNum":"  328","line":"    // Tests should not depend on timings: skip test if outside margin."},
{"lineNum":"  329","line":"    if (!(time_0 < margin)) return error.SkipZigTest;"},
{"lineNum":"  330","line":""},
{"lineNum":"  331","line":"    const time_1 = timer.lap();"},
{"lineNum":"  332","line":"    try testing.expect(time_1 >= time_0);"},
{"lineNum":"  333","line":""},
{"lineNum":"  334","line":"    timer.reset();"},
{"lineNum":"  335","line":"    try testing.expect(timer.read() < time_1);"},
{"lineNum":"  336","line":"}"},
{"lineNum":"  337","line":""},
{"lineNum":"  338","line":"test {"},
{"lineNum":"  339","line":"    _ = epoch;"},
{"lineNum":"  340","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test", "date" : "2024-04-26 16:14:48", "instrumented" : 24, "covered" : 24,};
var merged_data = [];
